nat : sttfa.type.

O : sttfa.etap (sttfa.p nat).

S : sttfa.etap (sttfa.p (sttfa.arrow nat nat)).

match_nat_prop :
  sttfa.eps
    (sttfa.forall
       (sttfa.arrow nat sttfa.bool)
       (return:(sttfa.etap (sttfa.p (sttfa.arrow nat sttfa.bool))) =>
        sttfa.impl
          (return O)
          (sttfa.impl
             (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => return (S n)))
             (sttfa.forall nat (z:(sttfa.etap (sttfa.p nat)) => return z))))).

match_nat_type :
  sttfa.etap
    (sttfa.forallK
       (return:sttfa.type =>
        sttfa.p (sttfa.arrow return (sttfa.arrow (sttfa.arrow nat return) (sttfa.arrow nat return))))).

axiom_match_nat_type_O :
  sttfa.eps
    (sttfa.forallP
       (return_type:sttfa.type =>
        sttfa.forall
          return_type
          (case_O:(sttfa.etap (sttfa.p return_type)) =>
           sttfa.forall
             (sttfa.arrow nat return_type)
             (case_S:(sttfa.etap (sttfa.p (sttfa.arrow nat return_type))) =>
              connectives.equal return_type (match_nat_type return_type case_O case_S O) case_O)))).

def eq_match_nat_type_O :
  sttfa.eps
    (sttfa.forallP
       (return_type:sttfa.type =>
        sttfa.forall
          return_type
          (case_O:(sttfa.etap (sttfa.p return_type)) =>
           sttfa.forall
             (sttfa.arrow nat return_type)
             (case_S:(sttfa.etap (sttfa.p (sttfa.arrow nat return_type))) =>
              sttfa.forall
                (sttfa.arrow return_type sttfa.bool)
                (P:(sttfa.eta (sttfa.arrow return_type sttfa.bool)) =>
                 sttfa.impl (P (match_nat_type return_type case_O case_S O)) (P case_O))))))
  :=
  return_type:sttfa.type =>
  case_O:(sttfa.etap (sttfa.p return_type)) =>
  case_S:(sttfa.etap (sttfa.p (sttfa.arrow nat return_type))) =>
  connectives.equal_leibniz
    return_type
    (match_nat_type return_type case_O case_S O)
    case_O
    (axiom_match_nat_type_O return_type case_O case_S).

def sym_eq_match_nat_type_O :
  sttfa.eps
    (sttfa.forallP
       (return_type:sttfa.type =>
        sttfa.forall
          return_type
          (case_O:(sttfa.etap (sttfa.p return_type)) =>
           sttfa.forall
             (sttfa.arrow nat return_type)
             (case_S:(sttfa.etap (sttfa.p (sttfa.arrow nat return_type))) =>
              sttfa.forall
                (sttfa.arrow return_type sttfa.bool)
                (P:(sttfa.eta (sttfa.arrow return_type sttfa.bool)) =>
                 sttfa.impl (P case_O) (P (match_nat_type return_type case_O case_S O)))))))
  :=
  return_type:sttfa.type =>
  case_O:(sttfa.etap (sttfa.p return_type)) =>
  case_S:(sttfa.etap (sttfa.p (sttfa.arrow nat return_type))) =>
  leibniz.sym_leibniz
    return_type
    (match_nat_type return_type case_O case_S O)
    case_O
    (eq_match_nat_type_O return_type case_O case_S).

axiom_match_nat_type_S :
  sttfa.eps
    (sttfa.forallP
       (return_type:sttfa.type =>
        sttfa.forall
          return_type
          (case_O:(sttfa.etap (sttfa.p return_type)) =>
           sttfa.forall
             (sttfa.arrow nat return_type)
             (case_S:(sttfa.etap (sttfa.p (sttfa.arrow nat return_type))) =>
              sttfa.forall
                nat
                (n:(sttfa.etap (sttfa.p nat)) =>
                 connectives.equal
                   return_type
                   (match_nat_type return_type case_O case_S (S n))
                   (case_S n)))))).

def eq_match_nat_type_S :
  sttfa.eps
    (sttfa.forallP
       (return_type:sttfa.type =>
        sttfa.forall
          return_type
          (case_O:(sttfa.etap (sttfa.p return_type)) =>
           sttfa.forall
             (sttfa.arrow nat return_type)
             (case_S:(sttfa.etap (sttfa.p (sttfa.arrow nat return_type))) =>
              sttfa.forall
                nat
                (n:(sttfa.etap (sttfa.p nat)) =>
                 sttfa.forall
                   (sttfa.arrow return_type sttfa.bool)
                   (P:(sttfa.eta (sttfa.arrow return_type sttfa.bool)) =>
                    sttfa.impl
                      (P (match_nat_type return_type case_O case_S (S n)))
                      (P (case_S n))))))))
  :=
  return_type:sttfa.type =>
  case_O:(sttfa.etap (sttfa.p return_type)) =>
  case_S:(sttfa.etap (sttfa.p (sttfa.arrow nat return_type))) =>
  n:(sttfa.etap (sttfa.p nat)) =>
  connectives.equal_leibniz
    return_type
    (match_nat_type return_type case_O case_S (S n))
    (case_S n)
    (axiom_match_nat_type_S return_type case_O case_S n).

def sym_eq_match_nat_type_S :
  sttfa.eps
    (sttfa.forallP
       (return_type:sttfa.type =>
        sttfa.forall
          return_type
          (case_O:(sttfa.etap (sttfa.p return_type)) =>
           sttfa.forall
             (sttfa.arrow nat return_type)
             (case_S:(sttfa.etap (sttfa.p (sttfa.arrow nat return_type))) =>
              sttfa.forall
                nat
                (n:(sttfa.etap (sttfa.p nat)) =>
                 sttfa.forall
                   (sttfa.arrow return_type sttfa.bool)
                   (P:(sttfa.eta (sttfa.arrow return_type sttfa.bool)) =>
                    sttfa.impl
                      (P (case_S n))
                      (P (match_nat_type return_type case_O case_S (S n)))))))))
  :=
  return_type:sttfa.type =>
  case_O:(sttfa.etap (sttfa.p return_type)) =>
  case_S:(sttfa.etap (sttfa.p (sttfa.arrow nat return_type))) =>
  n:(sttfa.etap (sttfa.p nat)) =>
  leibniz.sym_leibniz
    return_type
    (match_nat_type return_type case_O case_S (S n))
    (case_S n)
    (eq_match_nat_type_S return_type case_O case_S n).

filter_nat_type :
  sttfa.etap
    (sttfa.forallK
       (return:sttfa.type => sttfa.p (sttfa.arrow (sttfa.arrow nat return) (sttfa.arrow nat return)))).

axiom_filter_nat_type_O :
  sttfa.eps
    (sttfa.forallP
       (return_type:sttfa.type =>
        sttfa.forall
          (sttfa.arrow nat return_type)
          (return:(sttfa.etap (sttfa.p (sttfa.arrow nat return_type))) =>
           connectives.equal return_type (filter_nat_type return_type return O) (return O)))).

def eq_filter_nat_type_O :
  sttfa.eps
    (sttfa.forallP
       (return_type:sttfa.type =>
        sttfa.forall
          (sttfa.arrow nat return_type)
          (return:(sttfa.etap (sttfa.p (sttfa.arrow nat return_type))) =>
           sttfa.forall
             (sttfa.arrow return_type sttfa.bool)
             (P:(sttfa.eta (sttfa.arrow return_type sttfa.bool)) =>
              sttfa.impl (P (filter_nat_type return_type return O)) (P (return O))))))
  :=
  return_type:sttfa.type =>
  return:(sttfa.etap (sttfa.p (sttfa.arrow nat return_type))) =>
  connectives.equal_leibniz
    return_type
    (filter_nat_type return_type return O)
    (return O)
    (axiom_filter_nat_type_O return_type return).

def sym_eq_filter_nat_type_O :
  sttfa.eps
    (sttfa.forallP
       (return_type:sttfa.type =>
        sttfa.forall
          (sttfa.arrow nat return_type)
          (return:(sttfa.etap (sttfa.p (sttfa.arrow nat return_type))) =>
           sttfa.forall
             (sttfa.arrow return_type sttfa.bool)
             (P:(sttfa.eta (sttfa.arrow return_type sttfa.bool)) =>
              sttfa.impl (P (return O)) (P (filter_nat_type return_type return O))))))
  :=
  return_type:sttfa.type =>
  return:(sttfa.etap (sttfa.p (sttfa.arrow nat return_type))) =>
  leibniz.sym_leibniz
    return_type
    (filter_nat_type return_type return O)
    (return O)
    (eq_filter_nat_type_O return_type return).

axiom_filter_nat_type_S :
  sttfa.eps
    (sttfa.forallP
       (return_type:sttfa.type =>
        sttfa.forall
          (sttfa.arrow nat return_type)
          (return:(sttfa.etap (sttfa.p (sttfa.arrow nat return_type))) =>
           sttfa.forall
             nat
             (n:(sttfa.etap (sttfa.p nat)) =>
              connectives.equal
                return_type
                (filter_nat_type return_type return (S n))
                (return (S n)))))).

def eq_filter_nat_type_S :
  sttfa.eps
    (sttfa.forallP
       (return_type:sttfa.type =>
        sttfa.forall
          (sttfa.arrow nat return_type)
          (return:(sttfa.etap (sttfa.p (sttfa.arrow nat return_type))) =>
           sttfa.forall
             nat
             (n:(sttfa.etap (sttfa.p nat)) =>
              sttfa.forall
                (sttfa.arrow return_type sttfa.bool)
                (P:(sttfa.eta (sttfa.arrow return_type sttfa.bool)) =>
                 sttfa.impl (P (filter_nat_type return_type return (S n))) (P (return (S n))))))))
  :=
  return_type:sttfa.type =>
  return:(sttfa.etap (sttfa.p (sttfa.arrow nat return_type))) =>
  n:(sttfa.etap (sttfa.p nat)) =>
  connectives.equal_leibniz
    return_type
    (filter_nat_type return_type return (S n))
    (return (S n))
    (axiom_filter_nat_type_S return_type return n).

def sym_eq_filter_nat_type_S :
  sttfa.eps
    (sttfa.forallP
       (return_type:sttfa.type =>
        sttfa.forall
          (sttfa.arrow nat return_type)
          (return:(sttfa.etap (sttfa.p (sttfa.arrow nat return_type))) =>
           sttfa.forall
             nat
             (n:(sttfa.etap (sttfa.p nat)) =>
              sttfa.forall
                (sttfa.arrow return_type sttfa.bool)
                (P:(sttfa.eta (sttfa.arrow return_type sttfa.bool)) =>
                 sttfa.impl (P (return (S n))) (P (filter_nat_type return_type return (S n))))))))
  :=
  return_type:sttfa.type =>
  return:(sttfa.etap (sttfa.p (sttfa.arrow nat return_type))) =>
  n:(sttfa.etap (sttfa.p nat)) =>
  leibniz.sym_leibniz
    return_type
    (filter_nat_type return_type return (S n))
    (return (S n))
    (eq_filter_nat_type_S return_type return n).

nat_ind :
  sttfa.eps
    (sttfa.forall
       (sttfa.arrow nat sttfa.bool)
       (Q:(sttfa.etap (sttfa.p (sttfa.arrow nat sttfa.bool))) =>
        sttfa.impl
          (Q O)
          (sttfa.impl
             (sttfa.forall nat (x:(sttfa.etap (sttfa.p nat)) => sttfa.impl (Q x) (Q (S x))))
             (sttfa.forall nat (x:(sttfa.etap (sttfa.p nat)) => Q x))))).

def pred :
  sttfa.etap (sttfa.p (sttfa.arrow nat nat))
  :=
  n:(sttfa.etap (sttfa.p nat)) => match_nat_type nat O (p:(sttfa.etap (sttfa.p nat)) => p) n.

def not_zero :
  sttfa.etap (sttfa.p (sttfa.arrow nat sttfa.bool))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  match_nat_type sttfa.bool connectives.False (p:(sttfa.etap (sttfa.p nat)) => connectives.True) n.

le : sttfa.etap (sttfa.p (sttfa.arrow nat (sttfa.arrow nat sttfa.bool))).

le_n : sttfa.eps (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => le n n)).

le_S :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (le n m) (le n (S m))))).

match_le_prop :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow nat sttfa.bool)
          (return:(sttfa.etap (sttfa.p (sttfa.arrow nat sttfa.bool))) =>
           sttfa.impl
             (return n)
             (sttfa.impl
                (sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => return (S m)))
                (sttfa.forall
                   nat
                   (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (le n m) (return m))))))).

le_ind :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow nat sttfa.bool)
          (Q:(sttfa.etap (sttfa.p (sttfa.arrow nat sttfa.bool))) =>
           sttfa.impl
             (Q n)
             (sttfa.impl
                (sttfa.forall
                   nat
                   (m:(sttfa.etap (sttfa.p nat)) =>
                    sttfa.impl (le n m) (sttfa.impl (Q m) (Q (S m)))))
                (sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (le n m) (Q m))))))).

def lt :
  sttfa.etap (sttfa.p (sttfa.arrow nat (sttfa.arrow nat sttfa.bool)))
  :=
  n:(sttfa.etap (sttfa.p nat)) => m:(sttfa.etap (sttfa.p nat)) => le (S n) m.

plus : sttfa.etap (sttfa.p (sttfa.arrow nat (sttfa.arrow nat nat))).

plus_body : sttfa.etap (sttfa.p (sttfa.arrow nat (sttfa.arrow nat nat))).

axiom_plus :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        connectives.equal
          (sttfa.arrow nat nat)
          (plus n)
          (filter_nat_type (sttfa.arrow nat nat) plus_body n))).

def eq_plus :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)
          (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)) =>
           sttfa.impl (P (plus n)) (P (filter_nat_type (sttfa.arrow nat nat) plus_body n)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  connectives.equal_leibniz
    (sttfa.arrow nat nat)
    (plus n)
    (filter_nat_type (sttfa.arrow nat nat) plus_body n)
    (axiom_plus n).

def sym_eq_plus :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)
          (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)) =>
           sttfa.impl (P (filter_nat_type (sttfa.arrow nat nat) plus_body n)) (P (plus n)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  leibniz.sym_leibniz
    (sttfa.arrow nat nat)
    (plus n)
    (filter_nat_type (sttfa.arrow nat nat) plus_body n)
    (eq_plus n).

axiom_plus_body_O :
  sttfa.eps
    (connectives.equal (sttfa.arrow nat nat) (plus_body O) (m:(sttfa.etap (sttfa.p nat)) => m)).

def eq_plus_body_O :
  sttfa.eps
    (sttfa.forall
       (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)
       (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)) =>
        sttfa.impl (P (plus_body O)) (P (m:(sttfa.etap (sttfa.p nat)) => m))))
  :=
  connectives.equal_leibniz
    (sttfa.arrow nat nat)
    (plus_body O)
    (m:(sttfa.etap (sttfa.p nat)) => m)
    axiom_plus_body_O.

def sym_eq_plus_body_O :
  sttfa.eps
    (sttfa.forall
       (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)
       (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)) =>
        sttfa.impl (P (m:(sttfa.etap (sttfa.p nat)) => m)) (P (plus_body O))))
  :=
  leibniz.sym_leibniz
    (sttfa.arrow nat nat)
    (plus_body O)
    (m:(sttfa.etap (sttfa.p nat)) => m)
    eq_plus_body_O.

axiom_plus_body_S :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        connectives.equal
          (sttfa.arrow nat nat)
          (plus_body (S n))
          (m:(sttfa.etap (sttfa.p nat)) => S (plus n m)))).

def eq_plus_body_S :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)
          (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)) =>
           sttfa.impl (P (plus_body (S n))) (P (m:(sttfa.etap (sttfa.p nat)) => S (plus n m))))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  connectives.equal_leibniz
    (sttfa.arrow nat nat)
    (plus_body (S n))
    (m:(sttfa.etap (sttfa.p nat)) => S (plus n m))
    (axiom_plus_body_S n).

def sym_eq_plus_body_S :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)
          (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)) =>
           sttfa.impl (P (m:(sttfa.etap (sttfa.p nat)) => S (plus n m))) (P (plus_body (S n))))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  leibniz.sym_leibniz
    (sttfa.arrow nat nat)
    (plus_body (S n))
    (m:(sttfa.etap (sttfa.p nat)) => S (plus n m))
    (eq_plus_body_S n).

times : sttfa.etap (sttfa.p (sttfa.arrow nat (sttfa.arrow nat nat))).

times_body : sttfa.etap (sttfa.p (sttfa.arrow nat (sttfa.arrow nat nat))).

axiom_times :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        connectives.equal
          (sttfa.arrow nat nat)
          (times n)
          (filter_nat_type (sttfa.arrow nat nat) times_body n))).

def eq_times :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)
          (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)) =>
           sttfa.impl (P (times n)) (P (filter_nat_type (sttfa.arrow nat nat) times_body n)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  connectives.equal_leibniz
    (sttfa.arrow nat nat)
    (times n)
    (filter_nat_type (sttfa.arrow nat nat) times_body n)
    (axiom_times n).

def sym_eq_times :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)
          (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)) =>
           sttfa.impl (P (filter_nat_type (sttfa.arrow nat nat) times_body n)) (P (times n)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  leibniz.sym_leibniz
    (sttfa.arrow nat nat)
    (times n)
    (filter_nat_type (sttfa.arrow nat nat) times_body n)
    (eq_times n).

axiom_times_body_O :
  sttfa.eps
    (connectives.equal (sttfa.arrow nat nat) (times_body O) (m:(sttfa.etap (sttfa.p nat)) => O)).

def eq_times_body_O :
  sttfa.eps
    (sttfa.forall
       (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)
       (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)) =>
        sttfa.impl (P (times_body O)) (P (m:(sttfa.etap (sttfa.p nat)) => O))))
  :=
  connectives.equal_leibniz
    (sttfa.arrow nat nat)
    (times_body O)
    (m:(sttfa.etap (sttfa.p nat)) => O)
    axiom_times_body_O.

def sym_eq_times_body_O :
  sttfa.eps
    (sttfa.forall
       (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)
       (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)) =>
        sttfa.impl (P (m:(sttfa.etap (sttfa.p nat)) => O)) (P (times_body O))))
  :=
  leibniz.sym_leibniz
    (sttfa.arrow nat nat)
    (times_body O)
    (m:(sttfa.etap (sttfa.p nat)) => O)
    eq_times_body_O.

axiom_times_body_S :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        connectives.equal
          (sttfa.arrow nat nat)
          (times_body (S n))
          (m:(sttfa.etap (sttfa.p nat)) => plus m (times n m)))).

def eq_times_body_S :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)
          (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)) =>
           sttfa.impl
             (P (times_body (S n)))
             (P (m:(sttfa.etap (sttfa.p nat)) => plus m (times n m))))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  connectives.equal_leibniz
    (sttfa.arrow nat nat)
    (times_body (S n))
    (m:(sttfa.etap (sttfa.p nat)) => plus m (times n m))
    (axiom_times_body_S n).

def sym_eq_times_body_S :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)
          (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)) =>
           sttfa.impl
             (P (m:(sttfa.etap (sttfa.p nat)) => plus m (times n m)))
             (P (times_body (S n))))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  leibniz.sym_leibniz
    (sttfa.arrow nat nat)
    (times_body (S n))
    (m:(sttfa.etap (sttfa.p nat)) => plus m (times n m))
    (eq_times_body_S n).

minus : sttfa.etap (sttfa.p (sttfa.arrow nat (sttfa.arrow nat nat))).

minus_body : sttfa.etap (sttfa.p (sttfa.arrow nat (sttfa.arrow nat nat))).

axiom_minus :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        connectives.equal
          (sttfa.arrow nat nat)
          (minus n)
          (filter_nat_type (sttfa.arrow nat nat) minus_body n))).

def eq_minus :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)
          (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)) =>
           sttfa.impl (P (minus n)) (P (filter_nat_type (sttfa.arrow nat nat) minus_body n)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  connectives.equal_leibniz
    (sttfa.arrow nat nat)
    (minus n)
    (filter_nat_type (sttfa.arrow nat nat) minus_body n)
    (axiom_minus n).

def sym_eq_minus :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)
          (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)) =>
           sttfa.impl (P (filter_nat_type (sttfa.arrow nat nat) minus_body n)) (P (minus n)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  leibniz.sym_leibniz
    (sttfa.arrow nat nat)
    (minus n)
    (filter_nat_type (sttfa.arrow nat nat) minus_body n)
    (eq_minus n).

axiom_minus_body_O :
  sttfa.eps
    (connectives.equal (sttfa.arrow nat nat) (minus_body O) (m:(sttfa.etap (sttfa.p nat)) => O)).

def eq_minus_body_O :
  sttfa.eps
    (sttfa.forall
       (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)
       (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)) =>
        sttfa.impl (P (minus_body O)) (P (m:(sttfa.etap (sttfa.p nat)) => O))))
  :=
  connectives.equal_leibniz
    (sttfa.arrow nat nat)
    (minus_body O)
    (m:(sttfa.etap (sttfa.p nat)) => O)
    axiom_minus_body_O.

def sym_eq_minus_body_O :
  sttfa.eps
    (sttfa.forall
       (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)
       (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)) =>
        sttfa.impl (P (m:(sttfa.etap (sttfa.p nat)) => O)) (P (minus_body O))))
  :=
  leibniz.sym_leibniz
    (sttfa.arrow nat nat)
    (minus_body O)
    (m:(sttfa.etap (sttfa.p nat)) => O)
    eq_minus_body_O.

axiom_minus_body_S :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        connectives.equal
          (sttfa.arrow nat nat)
          (minus_body (S n))
          (m:(sttfa.etap (sttfa.p nat)) =>
           match_nat_type nat (S n) (q:(sttfa.etap (sttfa.p nat)) => minus n q) m))).

def eq_minus_body_S :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)
          (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)) =>
           sttfa.impl
             (P (minus_body (S n)))
             (P
                (m:(sttfa.etap (sttfa.p nat)) =>
                 match_nat_type nat (S n) (q:(sttfa.etap (sttfa.p nat)) => minus n q) m)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  connectives.equal_leibniz
    (sttfa.arrow nat nat)
    (minus_body (S n))
    (m:(sttfa.etap (sttfa.p nat)) =>
     match_nat_type nat (S n) (q:(sttfa.etap (sttfa.p nat)) => minus n q) m)
    (axiom_minus_body_S n).

def sym_eq_minus_body_S :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)
          (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat nat) sttfa.bool)) =>
           sttfa.impl
             (P
                (m:(sttfa.etap (sttfa.p nat)) =>
                 match_nat_type nat (S n) (q:(sttfa.etap (sttfa.p nat)) => minus n q) m))
             (P (minus_body (S n))))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  leibniz.sym_leibniz
    (sttfa.arrow nat nat)
    (minus_body (S n))
    (m:(sttfa.etap (sttfa.p nat)) =>
     match_nat_type nat (S n) (q:(sttfa.etap (sttfa.p nat)) => minus n q) m)
    (eq_minus_body_S n).

def nat_case :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow nat sttfa.bool)
          (P:(sttfa.etap (sttfa.p (sttfa.arrow nat sttfa.bool))) =>
           sttfa.impl
             (sttfa.impl (logic.eq nat n O) (P O))
             (sttfa.impl
                (sttfa.forall
                   nat
                   (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (logic.eq nat n (S m)) (P (S m))))
                (P n)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  P:(sttfa.etap (sttfa.p (sttfa.arrow nat sttfa.bool))) =>
  nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat)) =>
     sttfa.impl
       (sttfa.impl (logic.eq nat _x_365 O) (P O))
       (sttfa.impl
          (sttfa.forall
             nat
             (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (logic.eq nat _x_365 (S m)) (P (S m))))
          (P _x_365)))
    (auto:(sttfa.eps (sttfa.impl (logic.eq nat O O) (P O))) =>
     auto':(sttfa.eps
              (sttfa.forall
                 nat
                 (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (logic.eq nat O (S m)) (P (S m))))) =>
     auto (logic.refl nat O))
    (x_366:(sttfa.etap (sttfa.p nat)) =>
     _x_368:(sttfa.eps
               (sttfa.impl
                  (sttfa.impl (logic.eq nat x_366 O) (P O))
                  (sttfa.impl
                     (sttfa.forall
                        nat
                        (m:(sttfa.etap (sttfa.p nat)) =>
                         sttfa.impl (logic.eq nat x_366 (S m)) (P (S m))))
                     (P x_366)))) =>
     auto:(sttfa.eps (sttfa.impl (logic.eq nat (S x_366) O) (P O))) =>
     auto':(sttfa.eps
              (sttfa.forall
                 nat
                 (m:(sttfa.etap (sttfa.p nat)) =>
                  sttfa.impl (logic.eq nat (S x_366) (S m)) (P (S m))))) =>
     auto' x_366 (logic.refl nat (S x_366)))
    n.

def nat_elim2 :
  sttfa.eps
    (sttfa.forall
       (sttfa.arrow nat (sttfa.arrow nat sttfa.bool))
       (R:(sttfa.etap (sttfa.p (sttfa.arrow nat (sttfa.arrow nat sttfa.bool)))) =>
        sttfa.impl
          (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => R O n))
          (sttfa.impl
             (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => R (S n) O))
             (sttfa.impl
                (sttfa.forall
                   nat
                   (n:(sttfa.etap (sttfa.p nat)) =>
                    sttfa.forall
                      nat
                      (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (R n m) (R (S n) (S m)))))
                (sttfa.forall
                   nat
                   (n:(sttfa.etap (sttfa.p nat)) =>
                    sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => R n m)))))))
  :=
  R:(sttfa.etap (sttfa.p (sttfa.arrow nat (sttfa.arrow nat sttfa.bool)))) =>
  ROn:(sttfa.eps (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => R O n))) =>
  RSO:(sttfa.eps (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => R (S n) O))) =>
  RSS:(sttfa.eps
         (sttfa.forall
            nat
            (n:(sttfa.etap (sttfa.p nat)) =>
             sttfa.forall
               nat
               (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (R n m) (R (S n) (S m)))))) =>
  n:(sttfa.etap (sttfa.p nat)) =>
  nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat)) =>
     sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => R _x_365 m))
    (m:(sttfa.etap (sttfa.p nat)) => ROn m)
    (n0:(sttfa.etap (sttfa.p nat)) =>
     Rn0m:(sttfa.eps (sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => R n0 m))) =>
     m:(sttfa.etap (sttfa.p nat)) =>
     match_nat_prop
       (__:(sttfa.etap (sttfa.p nat)) => R (S n0) __)
       (RSO n0)
       (auto:(sttfa.etap (sttfa.p nat)) => RSS n0 auto (Rn0m auto))
       m)
    n.

def le_gen :
  sttfa.eps
    (sttfa.forall
       (sttfa.arrow nat sttfa.bool)
       (P:(sttfa.etap (sttfa.p (sttfa.arrow nat sttfa.bool))) =>
        sttfa.forall
          nat
          (n:(sttfa.etap (sttfa.p nat)) =>
           sttfa.impl
             (sttfa.forall nat (i:(sttfa.etap (sttfa.p nat)) => sttfa.impl (le i n) (P i)))
             (P n))))
  :=
  P:(sttfa.etap (sttfa.p (sttfa.arrow nat sttfa.bool))) =>
  n:(sttfa.etap (sttfa.p nat)) =>
  auto:(sttfa.eps (sttfa.forall nat (i:(sttfa.etap (sttfa.p nat)) => sttfa.impl (le i n) (P i)))) =>
  auto n (le_n n).

def pred_Sn :
  sttfa.eps (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => logic.eq nat n (pred (S n))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  sym_eq_match_nat_type_S
    nat
    O
    (p:(sttfa.etap (sttfa.p nat)) => p)
    n
    (y:(sttfa.etap (sttfa.p nat)) => logic.eq nat n y)
    (logic.refl nat n).

def injective_S :
  sttfa.eps (relations.injective_ nat nat S)
  :=
  x:(sttfa.etap (sttfa.p nat)) =>
  y:(sttfa.etap (sttfa.p nat)) =>
  auto:(sttfa.eps (logic.eq nat (S x) (S y))) =>
  logic.rewrite_l
    nat
    y
    (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat __ y)
    (logic.refl nat y)
    x
    (logic.rewrite_r
       nat
       (pred (S x))
       (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat y __)
       (logic.rewrite_r
          nat
          (S y)
          (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat y (pred __))
          (pred_Sn y)
          (S x)
          auto)
       x
       (pred_Sn x)).

def S_pred :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) => sttfa.impl (lt O n) (logic.eq nat (S (pred n)) n)))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  posn:(sttfa.eps (lt O n)) =>
  match_le_prop
    (S O)
    (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat (S (pred __)) __)
    (logic.rewrite_l
       nat
       O
       (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat (S __) (S O))
       (logic.refl nat (S O))
       (pred (S O))
       (pred_Sn O))
    (m:(sttfa.etap (sttfa.p nat)) =>
     logic.rewrite_l
       nat
       m
       (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat (S __) (S m))
       (logic.refl nat (S m))
       (pred (S m))
       (pred_Sn m))
    n
    posn.

def plus_O_n :
  sttfa.eps (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => logic.eq nat n (plus O n)))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  sym_eq_plus
    O
    (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat n (y n))
    (sym_eq_filter_nat_type_O
       (sttfa.arrow nat nat)
       plus_body
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat n (y n))
       (sym_eq_plus_body_O
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat n (y n))
          (logic.refl nat n))).

def plus_n_O :
  sttfa.eps (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => logic.eq nat n (plus n O)))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat)) => logic.eq nat _x_365 (plus _x_365 O))
    (sym_eq_plus
       O
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat O (y O))
       (sym_eq_filter_nat_type_O
          (sttfa.arrow nat nat)
          plus_body
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat O (y O))
          (sym_eq_plus_body_O
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat O (y O))
             (logic.refl nat O))))
    (x_366:(sttfa.etap (sttfa.p nat)) =>
     _x_368:(sttfa.eps (logic.eq nat x_366 (plus x_366 O))) =>
     sym_eq_plus
       (S x_366)
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat (S x_366) (y O))
       (sym_eq_filter_nat_type_S
          (sttfa.arrow nat nat)
          plus_body
          x_366
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat (S x_366) (y O))
          (sym_eq_plus_body_S
             x_366
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat (S x_366) (y O))
             (logic.rewrite_l
                nat
                x_366
                (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat (S x_366) (S __))
                (logic.refl nat (S x_366))
                (plus x_366 O)
                _x_368))))
    n.

def plus_n_Sm :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) => logic.eq nat (S (plus n m)) (plus n (S m)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat)) =>
     sttfa.forall
       nat
       (m:(sttfa.etap (sttfa.p nat)) => logic.eq nat (S (plus _x_365 m)) (plus _x_365 (S m))))
    (m:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_plus
       O
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat (S (y m)) (plus O (S m)))
       (sym_eq_plus
          O
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           logic.eq nat (S (filter_nat_type (sttfa.arrow nat nat) plus_body O m)) (y (S m)))
          (sym_eq_filter_nat_type_O
             (sttfa.arrow nat nat)
             plus_body
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              logic.eq nat (S (filter_nat_type (sttfa.arrow nat nat) plus_body O m)) (y (S m)))
             (sym_eq_filter_nat_type_O
                (sttfa.arrow nat nat)
                plus_body
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                 logic.eq nat (S (y m)) (plus_body O (S m)))
                (sym_eq_plus_body_O
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                    logic.eq nat (S (y m)) (plus_body O (S m)))
                   (sym_eq_plus_body_O
                      (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                       logic.eq nat (S m) (y (S m)))
                      (logic.refl nat (S m))))))))
    (x_366:(sttfa.etap (sttfa.p nat)) =>
     _x_368:(sttfa.eps
               (sttfa.forall
                  nat
                  (m:(sttfa.etap (sttfa.p nat)) =>
                   logic.eq nat (S (plus x_366 m)) (plus x_366 (S m))))) =>
     m:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_plus
       (S x_366)
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
        logic.eq nat (S (y m)) (plus (S x_366) (S m)))
       (sym_eq_plus
          (S x_366)
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           logic.eq nat (S (filter_nat_type (sttfa.arrow nat nat) plus_body (S x_366) m)) (y (S m)))
          (sym_eq_filter_nat_type_S
             (sttfa.arrow nat nat)
             plus_body
             x_366
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              logic.eq
                nat
                (S (filter_nat_type (sttfa.arrow nat nat) plus_body (S x_366) m))
                (y (S m)))
             (sym_eq_filter_nat_type_S
                (sttfa.arrow nat nat)
                plus_body
                x_366
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                 logic.eq nat (S (y m)) (plus_body (S x_366) (S m)))
                (sym_eq_plus_body_S
                   x_366
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                    logic.eq nat (S (y m)) (plus_body (S x_366) (S m)))
                   (sym_eq_plus_body_S
                      x_366
                      (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                       logic.eq nat (S (S (plus x_366 m))) (y (S m)))
                      (logic.rewrite_r
                         nat
                         (plus x_366 (S m))
                         (__:(sttfa.etap (sttfa.p nat)) =>
                          logic.eq nat (S __) (S (plus x_366 (S m))))
                         (logic.rewrite_r
                            nat
                            (plus x_366 (S (S m)))
                            (__:(sttfa.etap (sttfa.p nat)) =>
                             logic.eq nat __ (S (plus x_366 (S m))))
                            (logic.rewrite_r
                               nat
                               (plus x_366 (S (S m)))
                               (__:(sttfa.etap (sttfa.p nat)) =>
                                logic.eq nat (plus x_366 (S (S m))) __)
                               (logic.refl nat (plus x_366 (S (S m))))
                               (S (plus x_366 (S m)))
                               (_x_368 (S m)))
                            (S (plus x_366 (S m)))
                            (_x_368 (S m)))
                         (S (plus x_366 m))
                         (_x_368 m))))))))
    n.

def commutative_plus :
  sttfa.eps (relations.commutative nat plus)
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat)) =>
     sttfa.forall nat (y:(sttfa.etap (sttfa.p nat)) => logic.eq nat (plus _x_365 y) (plus y _x_365)))
    (y:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_plus
       O
       (z:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat (z y) (plus y O))
       (sym_eq_filter_nat_type_O
          (sttfa.arrow nat nat)
          plus_body
          (z:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat (z y) (plus y O))
          (sym_eq_plus_body_O
             (z:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat (z y) (plus y O))
             (logic.rewrite_l
                nat
                y
                (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat y __)
                (logic.refl nat y)
                (plus y O)
                (plus_n_O y)))))
    (x_366:(sttfa.etap (sttfa.p nat)) =>
     _x_368:(sttfa.eps
               (sttfa.forall
                  nat
                  (y:(sttfa.etap (sttfa.p nat)) => logic.eq nat (plus x_366 y) (plus y x_366)))) =>
     y:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_plus
       (S x_366)
       (z:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat (z y) (plus y (S x_366)))
       (sym_eq_filter_nat_type_S
          (sttfa.arrow nat nat)
          plus_body
          x_366
          (z:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat (z y) (plus y (S x_366)))
          (sym_eq_plus_body_S
             x_366
             (z:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              logic.eq nat (z y) (plus y (S x_366)))
             (logic.rewrite_r
                nat
                (plus x_366 (S y))
                (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat __ (plus y (S x_366)))
                (logic.rewrite_r
                   nat
                   (plus y (S x_366))
                   (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat __ (plus y (S x_366)))
                   (logic.refl nat (plus y (S x_366)))
                   (plus x_366 (S y))
                   (logic.rewrite_l
                      nat
                      (S (plus x_366 y))
                      (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat __ (plus y (S x_366)))
                      (logic.rewrite_r
                         nat
                         (plus y x_366)
                         (__:(sttfa.etap (sttfa.p nat)) =>
                          logic.eq nat (S __) (plus y (S x_366)))
                         (plus_n_Sm y x_366)
                         (plus x_366 y)
                         (_x_368 y))
                      (plus x_366 (S y))
                      (plus_n_Sm x_366 y)))
                (S (plus x_366 y))
                (plus_n_Sm x_366 y)))))
    n.

def associative_plus :
  sttfa.eps (relations.associative nat plus)
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat)) =>
     sttfa.forall
       nat
       (y:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (z:(sttfa.etap (sttfa.p nat)) =>
           logic.eq nat (plus (plus _x_365 y) z) (plus _x_365 (plus y z)))))
    (y:(sttfa.etap (sttfa.p nat)) =>
     z:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_plus
       O
       (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
        logic.eq nat (plus (plus O y) z) (x (plus y z)))
       (sym_eq_plus
          O
          (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           logic.eq
             nat
             (plus (x y) z)
             (filter_nat_type (sttfa.arrow nat nat) plus_body O (plus y z)))
          (sym_eq_filter_nat_type_O
             (sttfa.arrow nat nat)
             plus_body
             (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              logic.eq
                nat
                (plus (x y) z)
                (filter_nat_type (sttfa.arrow nat nat) plus_body O (plus y z)))
             (sym_eq_filter_nat_type_O
                (sttfa.arrow nat nat)
                plus_body
                (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                 logic.eq nat (plus (plus_body O y) z) (x (plus y z)))
                (sym_eq_plus_body_O
                   (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                    logic.eq nat (plus (plus_body O y) z) (x (plus y z)))
                   (sym_eq_plus_body_O
                      (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                       logic.eq nat (plus (x y) z) (plus y z))
                      (logic.refl nat (plus y z))))))))
    (x_366:(sttfa.etap (sttfa.p nat)) =>
     _x_368:(sttfa.eps
               (sttfa.forall
                  nat
                  (y:(sttfa.etap (sttfa.p nat)) =>
                   sttfa.forall
                     nat
                     (z:(sttfa.etap (sttfa.p nat)) =>
                      logic.eq nat (plus (plus x_366 y) z) (plus x_366 (plus y z)))))) =>
     y:(sttfa.etap (sttfa.p nat)) =>
     z:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_plus
       (S x_366)
       (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
        logic.eq nat (plus (plus (S x_366) y) z) (x (plus y z)))
       (sym_eq_plus
          (S x_366)
          (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           logic.eq
             nat
             (plus (x y) z)
             (filter_nat_type (sttfa.arrow nat nat) plus_body (S x_366) (plus y z)))
          (sym_eq_filter_nat_type_S
             (sttfa.arrow nat nat)
             plus_body
             x_366
             (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              logic.eq
                nat
                (plus (x y) z)
                (filter_nat_type (sttfa.arrow nat nat) plus_body (S x_366) (plus y z)))
             (sym_eq_filter_nat_type_S
                (sttfa.arrow nat nat)
                plus_body
                x_366
                (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                 logic.eq nat (plus (plus_body (S x_366) y) z) (x (plus y z)))
                (sym_eq_plus_body_S
                   x_366
                   (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                    logic.eq nat (plus (plus_body (S x_366) y) z) (x (plus y z)))
                   (sym_eq_plus_body_S
                      x_366
                      (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                       logic.eq nat (plus (x y) z) (S (plus x_366 (plus y z))))
                      (sym_eq_plus
                         (S (plus x_366 y))
                         (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                          logic.eq nat (x z) (S (plus x_366 (plus y z))))
                         (sym_eq_filter_nat_type_S
                            (sttfa.arrow nat nat)
                            plus_body
                            (plus x_366 y)
                            (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                             logic.eq nat (x z) (S (plus x_366 (plus y z))))
                            (sym_eq_plus_body_S
                               (plus x_366 y)
                               (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                                logic.eq nat (x z) (S (plus x_366 (plus y z))))
                               (logic.rewrite_r
                                  nat
                                  (plus x_366 (plus y z))
                                  (__:(sttfa.etap (sttfa.p nat)) =>
                                   logic.eq nat (S __) (S (plus x_366 (plus y z))))
                                  (logic.refl nat (S (plus x_366 (plus y z))))
                                  (plus (plus x_366 y) z)
                                  (_x_368 y z)))))))))))
    n.

def assoc_plus1 :
  sttfa.eps
    (sttfa.forall
       nat
       (a:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (b:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (c:(sttfa.etap (sttfa.p nat)) => logic.eq nat (plus c (plus b a)) (plus (plus b c) a)))))
  :=
  a:(sttfa.etap (sttfa.p nat)) =>
  b:(sttfa.etap (sttfa.p nat)) =>
  c:(sttfa.etap (sttfa.p nat)) =>
  logic.rewrite_r
    nat
    (plus a b)
    (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat (plus c __) (plus (plus b c) a))
    (logic.rewrite_r
       nat
       (plus a (plus b c))
       (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat (plus c (plus a b)) __)
       (logic.rewrite_r
          nat
          (plus a (plus b c))
          (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat __ (plus a (plus b c)))
          (logic.refl nat (plus a (plus b c)))
          (plus c (plus a b))
          (logic.rewrite_l
             nat
             (plus (plus a b) c)
             (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat (plus c (plus a b)) __)
             (commutative_plus c (plus a b))
             (plus a (plus b c))
             (associative_plus a b c)))
       (plus (plus b c) a)
       (commutative_plus (plus b c) a))
    (plus b a)
    (commutative_plus b a).

def injective_plus_r :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        relations.injective_ nat nat (m:(sttfa.etap (sttfa.p nat)) => plus n m)))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat)) =>
     relations.injective_ nat nat (m:(sttfa.etap (sttfa.p nat)) => plus _x_365 m))
    (sym_eq_plus
       O
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
        relations.injective_ nat nat (m:(sttfa.etap (sttfa.p nat)) => y m))
       (sym_eq_filter_nat_type_O
          (sttfa.arrow nat nat)
          plus_body
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           relations.injective_ nat nat (m:(sttfa.etap (sttfa.p nat)) => y m))
          (sym_eq_plus_body_O
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              relations.injective_ nat nat (m:(sttfa.etap (sttfa.p nat)) => y m))
             (x:(sttfa.etap (sttfa.p nat)) =>
              y:(sttfa.etap (sttfa.p nat)) =>
              auto:(sttfa.eps (logic.eq nat x y)) =>
              logic.rewrite_l
                nat
                x
                (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat x __)
                (logic.refl nat x)
                y
                auto))))
    (x_366:(sttfa.etap (sttfa.p nat)) =>
     _x_368:(sttfa.eps
               (sttfa.forall
                  nat
                  (x:(sttfa.etap (sttfa.p nat)) =>
                   sttfa.forall
                     nat
                     (y:(sttfa.etap (sttfa.p nat)) =>
                      sttfa.impl
                        (logic.eq nat (plus x_366 x) (plus x_366 y))
                        (logic.eq nat x y))))) =>
     sym_eq_plus
       (S x_366)
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
        relations.injective_ nat nat (m:(sttfa.etap (sttfa.p nat)) => y m))
       (sym_eq_filter_nat_type_S
          (sttfa.arrow nat nat)
          plus_body
          x_366
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           relations.injective_ nat nat (m:(sttfa.etap (sttfa.p nat)) => y m))
          (sym_eq_plus_body_S
             x_366
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              relations.injective_ nat nat (m:(sttfa.etap (sttfa.p nat)) => y m))
             (x:(sttfa.etap (sttfa.p nat)) =>
              y:(sttfa.etap (sttfa.p nat)) =>
              auto:(sttfa.eps (logic.eq nat (S (plus x_366 x)) (S (plus x_366 y)))) =>
              _x_368
                x
                y
                (injective_S
                   (plus x_366 x)
                   (plus x_366 y)
                   (logic.rewrite_r
                      nat
                      (plus x_366 (S x))
                      (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat __ (S (plus x_366 y)))
                      (logic.rewrite_r
                         nat
                         (plus x_366 (S y))
                         (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat (plus x_366 (S x)) __)
                         (logic.rewrite_l
                            nat
                            (plus x_366 (S x))
                            (__:(sttfa.etap (sttfa.p nat)) =>
                             logic.eq nat (plus x_366 (S x)) __)
                            (logic.refl nat (plus x_366 (S x)))
                            (plus x_366 (S y))
                            (logic.rewrite_l
                               nat
                               (S (plus x_366 y))
                               (__:(sttfa.etap (sttfa.p nat)) =>
                                logic.eq nat (plus x_366 (S x)) __)
                               (logic.rewrite_l
                                  nat
                                  (S (plus x_366 x))
                                  (__:(sttfa.etap (sttfa.p nat)) =>
                                   logic.eq nat __ (S (plus x_366 y)))
                                  auto
                                  (plus x_366 (S x))
                                  (plus_n_Sm x_366 x))
                               (plus x_366 (S y))
                               (plus_n_Sm x_366 y)))
                         (S (plus x_366 y))
                         (plus_n_Sm x_366 y))
                      (S (plus x_366 x))
                      (plus_n_Sm x_366 x)))))))
    n.

def times_Sn_m :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) => logic.eq nat (plus m (times n m)) (times (S n) m))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  sym_eq_times
    (S n)
    (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat (plus m (times n m)) (y m))
    (sym_eq_filter_nat_type_S
       (sttfa.arrow nat nat)
       times_body
       n
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat (plus m (times n m)) (y m))
       (sym_eq_times_body_S
          n
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           logic.eq nat (plus m (times n m)) (y m))
          (logic.refl nat (plus m (times n m))))).

def times_O_n :
  sttfa.eps (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => logic.eq nat O (times O n)))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  sym_eq_times
    O
    (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat O (y n))
    (sym_eq_filter_nat_type_O
       (sttfa.arrow nat nat)
       times_body
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat O (y n))
       (sym_eq_times_body_O
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat O (y n))
          (logic.refl nat O))).

def times_n_O :
  sttfa.eps (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => logic.eq nat O (times n O)))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat)) => logic.eq nat O (times _x_365 O))
    (logic.rewrite_l
       nat
       O
       (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat O __)
       (logic.refl nat O)
       (times O O)
       (times_O_n O))
    (x_366:(sttfa.etap (sttfa.p nat)) =>
     _x_368:(sttfa.eps (logic.eq nat O (times x_366 O))) =>
     logic.rewrite_l
       nat
       (plus O (times x_366 O))
       (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat O __)
       (logic.rewrite_l
          nat
          O
          (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat O (plus O __))
          (logic.rewrite_l
             nat
             O
             (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat O __)
             (logic.refl nat O)
             (plus O O)
             (plus_O_n O))
          (times x_366 O)
          _x_368)
       (times (S x_366) O)
       (times_Sn_m x_366 O))
    n.

def times_n_Sm :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) => logic.eq nat (plus n (times n m)) (times n (S m)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat)) =>
     sttfa.forall
       nat
       (m:(sttfa.etap (sttfa.p nat)) =>
        logic.eq nat (plus _x_365 (times _x_365 m)) (times _x_365 (S m))))
    (sym_eq_times
       O
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) => logic.eq nat (plus O (times O m)) (y (S m))))
       (sym_eq_times
          O
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           sttfa.forall
             nat
             (m:(sttfa.etap (sttfa.p nat)) =>
              logic.eq
                nat
                (plus O (y m))
                (filter_nat_type (sttfa.arrow nat nat) times_body O (S m))))
          (sym_eq_filter_nat_type_O
             (sttfa.arrow nat nat)
             times_body
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              sttfa.forall
                nat
                (m:(sttfa.etap (sttfa.p nat)) =>
                 logic.eq
                   nat
                   (plus O (y m))
                   (filter_nat_type (sttfa.arrow nat nat) times_body O (S m))))
             (sym_eq_filter_nat_type_O
                (sttfa.arrow nat nat)
                times_body
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                 sttfa.forall
                   nat
                   (m:(sttfa.etap (sttfa.p nat)) =>
                    logic.eq nat (plus O (times_body O m)) (y (S m))))
                (sym_eq_times_body_O
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                    sttfa.forall
                      nat
                      (m:(sttfa.etap (sttfa.p nat)) =>
                       logic.eq nat (plus O (times_body O m)) (y (S m))))
                   (sym_eq_times_body_O
                      (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                       sttfa.forall
                         nat
                         (m:(sttfa.etap (sttfa.p nat)) => logic.eq nat (plus O (y m)) O))
                      (sym_eq_plus
                         O
                         (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                          sttfa.forall
                            nat
                            (m:(sttfa.etap (sttfa.p nat)) => logic.eq nat (y O) O))
                         (sym_eq_filter_nat_type_O
                            (sttfa.arrow nat nat)
                            plus_body
                            (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                             sttfa.forall
                               nat
                               (m:(sttfa.etap (sttfa.p nat)) => logic.eq nat (y O) O))
                            (sym_eq_plus_body_O
                               (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                                sttfa.forall
                                  nat
                                  (m:(sttfa.etap (sttfa.p nat)) => logic.eq nat (y O) O))
                               (_m:(sttfa.etap (sttfa.p nat)) => logic.refl nat O))))))))))
    (x_366:(sttfa.etap (sttfa.p nat)) =>
     _x_368:(sttfa.eps
               (sttfa.forall
                  nat
                  (m:(sttfa.etap (sttfa.p nat)) =>
                   logic.eq nat (plus x_366 (times x_366 m)) (times x_366 (S m))))) =>
     m:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_times
       (S x_366)
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
        logic.eq nat (plus (S x_366) (times (S x_366) m)) (y (S m)))
       (sym_eq_times
          (S x_366)
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           logic.eq
             nat
             (plus (S x_366) (y m))
             (filter_nat_type (sttfa.arrow nat nat) times_body (S x_366) (S m)))
          (sym_eq_filter_nat_type_S
             (sttfa.arrow nat nat)
             times_body
             x_366
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              logic.eq
                nat
                (plus (S x_366) (y m))
                (filter_nat_type (sttfa.arrow nat nat) times_body (S x_366) (S m)))
             (sym_eq_filter_nat_type_S
                (sttfa.arrow nat nat)
                times_body
                x_366
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                 logic.eq nat (plus (S x_366) (times_body (S x_366) m)) (y (S m)))
                (sym_eq_times_body_S
                   x_366
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                    logic.eq nat (plus (S x_366) (times_body (S x_366) m)) (y (S m)))
                   (sym_eq_times_body_S
                      x_366
                      (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                       logic.eq nat (plus (S x_366) (y m)) (plus (S m) (times x_366 (S m))))
                      (sym_eq_plus
                         (S x_366)
                         (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                          logic.eq
                            nat
                            (y (plus m (times x_366 m)))
                            (plus (S m) (times x_366 (S m))))
                         (sym_eq_filter_nat_type_S
                            (sttfa.arrow nat nat)
                            plus_body
                            x_366
                            (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                             logic.eq
                               nat
                               (y (plus m (times x_366 m)))
                               (plus (S m) (times x_366 (S m))))
                            (sym_eq_plus_body_S
                               x_366
                               (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                                logic.eq
                                  nat
                                  (y (plus m (times x_366 m)))
                                  (plus (S m) (times x_366 (S m))))
                               (sym_eq_plus
                                  (S m)
                                  (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                                   logic.eq
                                     nat
                                     (S (plus x_366 (plus m (times x_366 m))))
                                     (y (times x_366 (S m))))
                                  (sym_eq_filter_nat_type_S
                                     (sttfa.arrow nat nat)
                                     plus_body
                                     m
                                     (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                                      logic.eq
                                        nat
                                        (S (plus x_366 (plus m (times x_366 m))))
                                        (y (times x_366 (S m))))
                                     (sym_eq_plus_body_S
                                        m
                                        (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                                         logic.eq
                                           nat
                                           (S (plus x_366 (plus m (times x_366 m))))
                                           (y (times x_366 (S m))))
                                        (logic.rewrite_r
                                           nat
                                           (plus x_366 (S (plus m (times x_366 m))))
                                           (__:(sttfa.etap (sttfa.p nat)) =>
                                            logic.eq
                                              nat
                                              __
                                              (S (plus m (times x_366 (S m)))))
                                           (logic.rewrite_r
                                              nat
                                              (plus m (S (times x_366 m)))
                                              (__:(sttfa.etap (sttfa.p nat)) =>
                                               logic.eq
                                                 nat
                                                 (plus x_366 __)
                                                 (S (plus m (times x_366 (S m)))))
                                              (logic.rewrite_l
                                                 nat
                                                 (plus x_366 (times x_366 m))
                                                 (__:(sttfa.etap (sttfa.p nat)) =>
                                                  logic.eq
                                                    nat
                                                    (plus
                                                       x_366
                                                       (plus m (S (times x_366 m))))
                                                    (S (plus m __)))
                                                 (logic.rewrite_r
                                                    nat
                                                    (plus
                                                       x_366
                                                       (plus m (times x_366 m)))
                                                    (__:(sttfa.etap (sttfa.p nat)) =>
                                                     logic.eq
                                                       nat
                                                       (plus
                                                          x_366
                                                          (plus
                                                             m
                                                             (S (times x_366 m))))
                                                       (S __))
                                                    (logic.rewrite_r
                                                       nat
                                                       (plus
                                                          x_366
                                                          (S
                                                             (plus
                                                                m
                                                                (times x_366 m))))
                                                       (__:(sttfa.etap
                                                              (sttfa.p nat)) =>
                                                        logic.eq
                                                          nat
                                                          (plus
                                                             x_366
                                                             (plus
                                                                m
                                                                (S
                                                                   (times
                                                                    x_366
                                                                    m))))
                                                          __)
                                                       (logic.rewrite_r
                                                          nat
                                                          (plus
                                                             m
                                                             (S (times x_366 m)))
                                                          (__:(sttfa.etap
                                                                 (sttfa.p nat)) =>
                                                           logic.eq
                                                             nat
                                                             (plus
                                                                x_366
                                                                (plus
                                                                   m
                                                                   (S
                                                                    (times
                                                                    x_366
                                                                    m))))
                                                             (plus x_366 __))
                                                          (logic.refl
                                                             nat
                                                             (plus
                                                                x_366
                                                                (plus
                                                                   m
                                                                   (S
                                                                    (times
                                                                    x_366
                                                                    m)))))
                                                          (S
                                                             (plus
                                                                m
                                                                (times x_366 m)))
                                                          (plus_n_Sm
                                                             m
                                                             (times x_366 m)))
                                                       (S
                                                          (plus
                                                             x_366
                                                             (plus
                                                                m
                                                                (times x_366 m))))
                                                       (plus_n_Sm
                                                          x_366
                                                          (plus m (times x_366 m))))
                                                    (plus
                                                       m
                                                       (plus x_366 (times x_366 m)))
                                                    (logic.rewrite_l
                                                       nat
                                                       (plus
                                                          (plus x_366 m)
                                                          (times x_366 m))
                                                       (__:(sttfa.etap
                                                              (sttfa.p nat)) =>
                                                        logic.eq
                                                          nat
                                                          (plus
                                                             m
                                                             (plus
                                                                x_366
                                                                (times x_366 m)))
                                                          __)
                                                       (assoc_plus1
                                                          (times x_366 m)
                                                          x_366
                                                          m)
                                                       (plus
                                                          x_366
                                                          (plus m (times x_366 m)))
                                                       (associative_plus
                                                          x_366
                                                          m
                                                          (times x_366 m))))
                                                 (times x_366 (S m))
                                                 (_x_368 m))
                                              (S (plus m (times x_366 m)))
                                              (plus_n_Sm m (times x_366 m)))
                                           (S (plus x_366 (plus m (times x_366 m))))
                                           (plus_n_Sm x_366 (plus m (times x_366 m))))))))))))))))
    n.

def commutative_times :
  sttfa.eps (relations.commutative nat times)
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat)) =>
     sttfa.forall
       nat
       (y:(sttfa.etap (sttfa.p nat)) => logic.eq nat (times _x_365 y) (times y _x_365)))
    (sym_eq_times
       O
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
        sttfa.forall nat (z:(sttfa.etap (sttfa.p nat)) => logic.eq nat (y z) (times z O)))
       (sym_eq_filter_nat_type_O
          (sttfa.arrow nat nat)
          times_body
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           sttfa.forall nat (z:(sttfa.etap (sttfa.p nat)) => logic.eq nat (y z) (times z O)))
          (sym_eq_times_body_O
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              sttfa.forall nat (z:(sttfa.etap (sttfa.p nat)) => logic.eq nat (y z) (times z O)))
             (y:(sttfa.etap (sttfa.p nat)) =>
              logic.rewrite_l
                nat
                O
                (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat O __)
                (logic.refl nat O)
                (times y O)
                (times_n_O y)))))
    (x_366:(sttfa.etap (sttfa.p nat)) =>
     _x_368:(sttfa.eps
               (sttfa.forall
                  nat
                  (y:(sttfa.etap (sttfa.p nat)) => logic.eq nat (times x_366 y) (times y x_366)))) =>
     y:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_times
       (S x_366)
       (z:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat (z y) (times y (S x_366)))
       (sym_eq_filter_nat_type_S
          (sttfa.arrow nat nat)
          times_body
          x_366
          (z:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat (z y) (times y (S x_366)))
          (sym_eq_times_body_S
             x_366
             (z:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              logic.eq nat (z y) (times y (S x_366)))
             (logic.rewrite_l
                nat
                (plus y (times y x_366))
                (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat (plus y (times x_366 y)) __)
                (logic.rewrite_l
                   nat
                   (times x_366 y)
                   (__:(sttfa.etap (sttfa.p nat)) =>
                    logic.eq nat (plus y (times x_366 y)) (plus y __))
                   (logic.refl nat (plus y (times x_366 y)))
                   (times y x_366)
                   (_x_368 y))
                (times y (S x_366))
                (times_n_Sm y x_366)))))
    n.

def distributive_times_plus :
  sttfa.eps (relations.distributive nat times plus)
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat)) =>
     sttfa.forall
       nat
       (y:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (z:(sttfa.etap (sttfa.p nat)) =>
           logic.eq nat (times _x_365 (plus y z)) (plus (times _x_365 y) (times _x_365 z)))))
    (sym_eq_times
       O
       (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
        sttfa.forall
          nat
          (y:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (z:(sttfa.etap (sttfa.p nat)) =>
              logic.eq nat (times O (plus y z)) (plus (times O y) (x z)))))
       (sym_eq_times
          O
          (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           sttfa.forall
             nat
             (y:(sttfa.etap (sttfa.p nat)) =>
              sttfa.forall
                nat
                (z:(sttfa.etap (sttfa.p nat)) =>
                 logic.eq
                   nat
                   (times O (plus y z))
                   (plus (x y) (filter_nat_type (sttfa.arrow nat nat) times_body O z)))))
          (sym_eq_times
             O
             (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              sttfa.forall
                nat
                (y:(sttfa.etap (sttfa.p nat)) =>
                 sttfa.forall
                   nat
                   (z:(sttfa.etap (sttfa.p nat)) =>
                    logic.eq
                      nat
                      (x (plus y z))
                      (plus
                         (filter_nat_type (sttfa.arrow nat nat) times_body O y)
                         (filter_nat_type (sttfa.arrow nat nat) times_body O z)))))
             (sym_eq_filter_nat_type_O
                (sttfa.arrow nat nat)
                times_body
                (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                 sttfa.forall
                   nat
                   (y:(sttfa.etap (sttfa.p nat)) =>
                    sttfa.forall
                      nat
                      (z:(sttfa.etap (sttfa.p nat)) =>
                       logic.eq
                         nat
                         (x (plus y z))
                         (plus
                            (filter_nat_type (sttfa.arrow nat nat) times_body O y)
                            (filter_nat_type (sttfa.arrow nat nat) times_body O z)))))
                (sym_eq_filter_nat_type_O
                   (sttfa.arrow nat nat)
                   times_body
                   (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                    sttfa.forall
                      nat
                      (y:(sttfa.etap (sttfa.p nat)) =>
                       sttfa.forall
                         nat
                         (z:(sttfa.etap (sttfa.p nat)) =>
                          logic.eq
                            nat
                            (times_body O (plus y z))
                            (plus
                               (x y)
                               (filter_nat_type (sttfa.arrow nat nat) times_body O z)))))
                   (sym_eq_filter_nat_type_O
                      (sttfa.arrow nat nat)
                      times_body
                      (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                       sttfa.forall
                         nat
                         (y:(sttfa.etap (sttfa.p nat)) =>
                          sttfa.forall
                            nat
                            (z:(sttfa.etap (sttfa.p nat)) =>
                             logic.eq
                               nat
                               (times_body O (plus y z))
                               (plus (times_body O y) (x z)))))
                      (sym_eq_times_body_O
                         (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                          sttfa.forall
                            nat
                            (y:(sttfa.etap (sttfa.p nat)) =>
                             sttfa.forall
                               nat
                               (z:(sttfa.etap (sttfa.p nat)) =>
                                logic.eq
                                  nat
                                  (times_body O (plus y z))
                                  (plus (times_body O y) (x z)))))
                         (sym_eq_times_body_O
                            (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                             sttfa.forall
                               nat
                               (y:(sttfa.etap (sttfa.p nat)) =>
                                sttfa.forall
                                  nat
                                  (z:(sttfa.etap (sttfa.p nat)) =>
                                   logic.eq nat (times_body O (plus y z)) (plus (x y) O))))
                            (sym_eq_times_body_O
                               (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                                sttfa.forall
                                  nat
                                  (y:(sttfa.etap (sttfa.p nat)) =>
                                   sttfa.forall
                                     nat
                                     (z:(sttfa.etap (sttfa.p nat)) =>
                                      logic.eq nat (x (plus y z)) (plus O O))))
                               (sym_eq_plus
                                  O
                                  (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                                   sttfa.forall
                                     nat
                                     (y:(sttfa.etap (sttfa.p nat)) =>
                                      sttfa.forall
                                        nat
                                        (z:(sttfa.etap (sttfa.p nat)) =>
                                         logic.eq nat O (x O))))
                                  (sym_eq_filter_nat_type_O
                                     (sttfa.arrow nat nat)
                                     plus_body
                                     (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                                      sttfa.forall
                                        nat
                                        (y:(sttfa.etap (sttfa.p nat)) =>
                                         sttfa.forall
                                           nat
                                           (z:(sttfa.etap (sttfa.p nat)) =>
                                            logic.eq nat O (x O))))
                                     (sym_eq_plus_body_O
                                        (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                                         sttfa.forall
                                           nat
                                           (y:(sttfa.etap (sttfa.p nat)) =>
                                            sttfa.forall
                                              nat
                                              (z:(sttfa.etap (sttfa.p nat)) =>
                                               logic.eq nat O (x O))))
                                        (_y:(sttfa.etap (sttfa.p nat)) =>
                                         _z:(sttfa.etap (sttfa.p nat)) =>
                                         logic.refl nat O)))))))))))))
    (x_366:(sttfa.etap (sttfa.p nat)) =>
     _x_368:(sttfa.eps
               (sttfa.forall
                  nat
                  (y:(sttfa.etap (sttfa.p nat)) =>
                   sttfa.forall
                     nat
                     (z:(sttfa.etap (sttfa.p nat)) =>
                      logic.eq
                        nat
                        (times x_366 (plus y z))
                        (plus (times x_366 y) (times x_366 z)))))) =>
     y:(sttfa.etap (sttfa.p nat)) =>
     z:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_times
       (S x_366)
       (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
        logic.eq nat (times (S x_366) (plus y z)) (plus (times (S x_366) y) (x z)))
       (sym_eq_times
          (S x_366)
          (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           logic.eq
             nat
             (times (S x_366) (plus y z))
             (plus (x y) (filter_nat_type (sttfa.arrow nat nat) times_body (S x_366) z)))
          (sym_eq_times
             (S x_366)
             (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              logic.eq
                nat
                (x (plus y z))
                (plus
                   (filter_nat_type (sttfa.arrow nat nat) times_body (S x_366) y)
                   (filter_nat_type (sttfa.arrow nat nat) times_body (S x_366) z)))
             (sym_eq_filter_nat_type_S
                (sttfa.arrow nat nat)
                times_body
                x_366
                (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                 logic.eq
                   nat
                   (x (plus y z))
                   (plus
                      (filter_nat_type (sttfa.arrow nat nat) times_body (S x_366) y)
                      (filter_nat_type (sttfa.arrow nat nat) times_body (S x_366) z)))
                (sym_eq_filter_nat_type_S
                   (sttfa.arrow nat nat)
                   times_body
                   x_366
                   (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                    logic.eq
                      nat
                      (times_body (S x_366) (plus y z))
                      (plus
                         (x y)
                         (filter_nat_type (sttfa.arrow nat nat) times_body (S x_366) z)))
                   (sym_eq_filter_nat_type_S
                      (sttfa.arrow nat nat)
                      times_body
                      x_366
                      (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                       logic.eq
                         nat
                         (times_body (S x_366) (plus y z))
                         (plus (times_body (S x_366) y) (x z)))
                      (sym_eq_times_body_S
                         x_366
                         (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                          logic.eq
                            nat
                            (times_body (S x_366) (plus y z))
                            (plus (times_body (S x_366) y) (x z)))
                         (sym_eq_times_body_S
                            x_366
                            (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                             logic.eq
                               nat
                               (times_body (S x_366) (plus y z))
                               (plus (x y) (plus z (times x_366 z))))
                            (sym_eq_times_body_S
                               x_366
                               (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                                logic.eq
                                  nat
                                  (x (plus y z))
                                  (plus (plus y (times x_366 y)) (plus z (times x_366 z))))
                               (logic.rewrite_r
                                  nat
                                  (plus y (plus z (times x_366 (plus y z))))
                                  (__:(sttfa.etap (sttfa.p nat)) =>
                                   logic.eq
                                     nat
                                     __
                                     (plus
                                        (plus y (times x_366 y))
                                        (plus z (times x_366 z))))
                                  (logic.rewrite_r
                                     nat
                                     (plus
                                        y
                                        (plus (times x_366 y) (plus z (times x_366 z))))
                                     (__:(sttfa.etap (sttfa.p nat)) =>
                                      logic.eq
                                        nat
                                        (plus y (plus z (times x_366 (plus y z))))
                                        __)
                                     (logic.rewrite_r
                                        nat
                                        (plus z (plus (times x_366 y) (times x_366 z)))
                                        (__:(sttfa.etap (sttfa.p nat)) =>
                                         logic.eq
                                           nat
                                           (plus y (plus z (times x_366 (plus y z))))
                                           (plus y __))
                                        (logic.rewrite_l
                                           nat
                                           (times x_366 (plus y z))
                                           (__:(sttfa.etap (sttfa.p nat)) =>
                                            logic.eq
                                              nat
                                              (plus y (plus z (times x_366 (plus y z))))
                                              (plus y (plus z __)))
                                           (logic.refl
                                              nat
                                              (plus y (plus z (times x_366 (plus y z)))))
                                           (plus (times x_366 y) (times x_366 z))
                                           (_x_368 y z))
                                        (plus (times x_366 y) (plus z (times x_366 z)))
                                        (logic.rewrite_l
                                           nat
                                           (plus
                                              (plus z (times x_366 y))
                                              (times x_366 z))
                                           (__:(sttfa.etap (sttfa.p nat)) =>
                                            logic.eq
                                              nat
                                              (plus
                                                 (times x_366 y)
                                                 (plus z (times x_366 z)))
                                              __)
                                           (assoc_plus1
                                              (times x_366 z)
                                              z
                                              (times x_366 y))
                                           (plus
                                              z
                                              (plus (times x_366 y) (times x_366 z)))
                                           (associative_plus
                                              z
                                              (times x_366 y)
                                              (times x_366 z))))
                                     (plus
                                        (plus y (times x_366 y))
                                        (plus z (times x_366 z)))
                                     (associative_plus
                                        y
                                        (times x_366 y)
                                        (plus z (times x_366 z))))
                                  (plus (plus y z) (times x_366 (plus y z)))
                                  (associative_plus y z (times x_366 (plus y z)))))))))))))
    n.

def distributive_times_plus_r :
  sttfa.eps
    (sttfa.forall
       nat
       (a:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (b:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (c:(sttfa.etap (sttfa.p nat)) =>
              logic.eq nat (times (plus b c) a) (plus (times b a) (times c a))))))
  :=
  a:(sttfa.etap (sttfa.p nat)) =>
  b:(sttfa.etap (sttfa.p nat)) =>
  c:(sttfa.etap (sttfa.p nat)) =>
  logic.rewrite_r
    nat
    (times a (plus b c))
    (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat __ (plus (times b a) (times c a)))
    (logic.rewrite_r
       nat
       (times a b)
       (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat (times a (plus b c)) (plus __ (times c a)))
       (logic.rewrite_r
          nat
          (times a c)
          (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat (times a (plus b c)) (plus (times a b) __))
          (logic.rewrite_l
             nat
             (times a (plus b c))
             (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat (times a (plus b c)) __)
             (logic.refl nat (times a (plus b c)))
             (plus (times a b) (times a c))
             (distributive_times_plus a b c))
          (times c a)
          (commutative_times c a))
       (times b a)
       (commutative_times b a))
    (times (plus b c) a)
    (commutative_times (plus b c) a).

def associative_times :
  sttfa.eps (relations.associative nat times)
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat)) =>
     sttfa.forall
       nat
       (y:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (z:(sttfa.etap (sttfa.p nat)) =>
           logic.eq nat (times (times _x_365 y) z) (times _x_365 (times y z)))))
    (sym_eq_times
       O
       (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
        sttfa.forall
          nat
          (y:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (z:(sttfa.etap (sttfa.p nat)) => logic.eq nat (times (times O y) z) (x (times y z)))))
       (sym_eq_times
          O
          (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           sttfa.forall
             nat
             (y:(sttfa.etap (sttfa.p nat)) =>
              sttfa.forall
                nat
                (z:(sttfa.etap (sttfa.p nat)) =>
                 logic.eq
                   nat
                   (times (x y) z)
                   (filter_nat_type (sttfa.arrow nat nat) times_body O (times y z)))))
          (sym_eq_filter_nat_type_O
             (sttfa.arrow nat nat)
             times_body
             (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              sttfa.forall
                nat
                (y:(sttfa.etap (sttfa.p nat)) =>
                 sttfa.forall
                   nat
                   (z:(sttfa.etap (sttfa.p nat)) =>
                    logic.eq
                      nat
                      (times (x y) z)
                      (filter_nat_type (sttfa.arrow nat nat) times_body O (times y z)))))
             (sym_eq_filter_nat_type_O
                (sttfa.arrow nat nat)
                times_body
                (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                 sttfa.forall
                   nat
                   (y:(sttfa.etap (sttfa.p nat)) =>
                    sttfa.forall
                      nat
                      (z:(sttfa.etap (sttfa.p nat)) =>
                       logic.eq nat (times (times_body O y) z) (x (times y z)))))
                (sym_eq_times_body_O
                   (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                    sttfa.forall
                      nat
                      (y:(sttfa.etap (sttfa.p nat)) =>
                       sttfa.forall
                         nat
                         (z:(sttfa.etap (sttfa.p nat)) =>
                          logic.eq nat (times (times_body O y) z) (x (times y z)))))
                   (sym_eq_times_body_O
                      (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                       sttfa.forall
                         nat
                         (y:(sttfa.etap (sttfa.p nat)) =>
                          sttfa.forall
                            nat
                            (z:(sttfa.etap (sttfa.p nat)) => logic.eq nat (times (x y) z) O)))
                      (sym_eq_times
                         O
                         (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                          sttfa.forall
                            nat
                            (y:(sttfa.etap (sttfa.p nat)) =>
                             sttfa.forall
                               nat
                               (z:(sttfa.etap (sttfa.p nat)) => logic.eq nat (x z) O)))
                         (sym_eq_filter_nat_type_O
                            (sttfa.arrow nat nat)
                            times_body
                            (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                             sttfa.forall
                               nat
                               (y:(sttfa.etap (sttfa.p nat)) =>
                                sttfa.forall
                                  nat
                                  (z:(sttfa.etap (sttfa.p nat)) => logic.eq nat (x z) O)))
                            (sym_eq_times_body_O
                               (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                                sttfa.forall
                                  nat
                                  (y:(sttfa.etap (sttfa.p nat)) =>
                                   sttfa.forall
                                     nat
                                     (z:(sttfa.etap (sttfa.p nat)) => logic.eq nat (x z) O)))
                               (_y:(sttfa.etap (sttfa.p nat)) =>
                                _z:(sttfa.etap (sttfa.p nat)) => logic.refl nat O))))))))))
    (x_366:(sttfa.etap (sttfa.p nat)) =>
     _x_368:(sttfa.eps
               (sttfa.forall
                  nat
                  (y:(sttfa.etap (sttfa.p nat)) =>
                   sttfa.forall
                     nat
                     (z:(sttfa.etap (sttfa.p nat)) =>
                      logic.eq nat (times (times x_366 y) z) (times x_366 (times y z)))))) =>
     y:(sttfa.etap (sttfa.p nat)) =>
     z:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_times
       (S x_366)
       (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
        logic.eq nat (times (times (S x_366) y) z) (x (times y z)))
       (sym_eq_times
          (S x_366)
          (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           logic.eq
             nat
             (times (x y) z)
             (filter_nat_type (sttfa.arrow nat nat) times_body (S x_366) (times y z)))
          (sym_eq_filter_nat_type_S
             (sttfa.arrow nat nat)
             times_body
             x_366
             (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              logic.eq
                nat
                (times (x y) z)
                (filter_nat_type (sttfa.arrow nat nat) times_body (S x_366) (times y z)))
             (sym_eq_filter_nat_type_S
                (sttfa.arrow nat nat)
                times_body
                x_366
                (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                 logic.eq nat (times (times_body (S x_366) y) z) (x (times y z)))
                (sym_eq_times_body_S
                   x_366
                   (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                    logic.eq nat (times (times_body (S x_366) y) z) (x (times y z)))
                   (sym_eq_times_body_S
                      x_366
                      (x:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                       logic.eq
                         nat
                         (times (x y) z)
                         (plus (times y z) (times x_366 (times y z))))
                      (logic.rewrite_r
                         nat
                         (plus (times y z) (times x_366 (times y z)))
                         (__:(sttfa.etap (sttfa.p nat)) =>
                          logic.eq nat __ (plus (times y z) (times x_366 (times y z))))
                         (logic.refl nat (plus (times y z) (times x_366 (times y z))))
                         (times (plus y (times x_366 y)) z)
                         (logic.rewrite_l
                            nat
                            (times (times x_366 y) z)
                            (__:(sttfa.etap (sttfa.p nat)) =>
                             logic.eq
                               nat
                               (times (plus y (times x_366 y)) z)
                               (plus (times y z) __))
                            (distributive_times_plus_r z y (times x_366 y))
                            (times x_366 (times y z))
                            (_x_368 y z)))))))))
    n.

def times_times :
  sttfa.eps
    (sttfa.forall
       nat
       (x:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (y:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (z:(sttfa.etap (sttfa.p nat)) =>
              logic.eq nat (times x (times y z)) (times y (times x z))))))
  :=
  x:(sttfa.etap (sttfa.p nat)) =>
  y:(sttfa.etap (sttfa.p nat)) =>
  z:(sttfa.etap (sttfa.p nat)) =>
  logic.rewrite_r
    nat
    (times y (times x z))
    (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat __ (times y (times x z)))
    (logic.refl nat (times y (times x z)))
    (times x (times y z))
    (logic.rewrite_l
       nat
       (times (times x y) z)
       (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat __ (times y (times x z)))
       (logic.rewrite_l
          nat
          (times y x)
          (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat (times __ z) (times y (times x z)))
          (associative_times y x z)
          (times x y)
          (commutative_times y x))
       (times x (times y z))
       (associative_times x y z)).

def times_n_1 :
  sttfa.eps (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => logic.eq nat n (times n (S O))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  logic.rewrite_l
    nat
    (plus n (times n O))
    (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat n __)
    (logic.rewrite_l
       nat
       O
       (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat n (plus n __))
       (logic.rewrite_l
          nat
          n
          (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat n __)
          (logic.refl nat n)
          (plus n O)
          (plus_n_O n))
       (times n O)
       (times_n_O n))
    (times n (S O))
    (times_n_Sm n O).

def minus_S_S :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) => logic.eq nat (minus (S n) (S m)) (minus n m))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  eq_match_nat_type_S
    nat
    (S n)
    (q:(sttfa.etap (sttfa.p nat)) => minus n q)
    m
    (y:(sttfa.etap (sttfa.p nat)) => logic.eq nat (minus (S n) (S m)) y)
    (eq_minus_body_S
       n
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat (minus (S n) (S m)) (y (S m)))
       (eq_filter_nat_type_S
          (sttfa.arrow nat nat)
          minus_body
          n
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           logic.eq nat (minus (S n) (S m)) (y (S m)))
          (eq_minus
             (S n)
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              logic.eq nat (minus (S n) (S m)) (y (S m)))
             (logic.refl nat (minus (S n) (S m)))))).

def minus_O_n :
  sttfa.eps (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => logic.eq nat O (minus O n)))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  match_nat_prop
    (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat O (minus O __))
    (sym_eq_minus
       O
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat O (y O))
       (sym_eq_filter_nat_type_O
          (sttfa.arrow nat nat)
          minus_body
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat O (y O))
          (sym_eq_minus_body_O
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat O (y O))
             (logic.refl nat O))))
    (sym_eq_minus
       O
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
        sttfa.forall nat (n0:(sttfa.etap (sttfa.p nat)) => logic.eq nat O (y (S n0))))
       (sym_eq_filter_nat_type_O
          (sttfa.arrow nat nat)
          minus_body
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           sttfa.forall nat (n0:(sttfa.etap (sttfa.p nat)) => logic.eq nat O (y (S n0))))
          (sym_eq_minus_body_O
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              sttfa.forall nat (n0:(sttfa.etap (sttfa.p nat)) => logic.eq nat O (y (S n0))))
             (auto:(sttfa.etap (sttfa.p nat)) => logic.refl nat O))))
    n.

def minus_n_O :
  sttfa.eps (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => logic.eq nat n (minus n O)))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  match_nat_prop
    (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat __ (minus __ O))
    (logic.rewrite_l
       nat
       O
       (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat O __)
       (logic.refl nat O)
       (minus O O)
       (minus_O_n O))
    (auto:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_minus
       (S auto)
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat (S auto) (y O))
       (sym_eq_filter_nat_type_S
          (sttfa.arrow nat nat)
          minus_body
          auto
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat (S auto) (y O))
          (sym_eq_minus_body_S
             auto
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => logic.eq nat (S auto) (y O))
             (sym_eq_match_nat_type_O
                nat
                (S auto)
                (q:(sttfa.etap (sttfa.p nat)) => minus auto q)
                (y:(sttfa.etap (sttfa.p nat)) => logic.eq nat (S auto) y)
                (logic.refl nat (S auto))))))
    n.

def minus_n_n :
  sttfa.eps (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => logic.eq nat O (minus n n)))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat)) => logic.eq nat O (minus _x_365 _x_365))
    (logic.rewrite_l
       nat
       O
       (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat O __)
       (logic.refl nat O)
       (minus O O)
       (minus_O_n O))
    (x_366:(sttfa.etap (sttfa.p nat)) =>
     _x_368:(sttfa.eps (logic.eq nat O (minus x_366 x_366))) =>
     logic.rewrite_r
       nat
       (minus x_366 x_366)
       (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat O __)
       (logic.rewrite_l
          nat
          O
          (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat O __)
          (logic.refl nat O)
          (minus x_366 x_366)
          _x_368)
       (minus (S x_366) (S x_366))
       (minus_S_S x_366 x_366))
    n.

def eq_minus_S_pred :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) => logic.eq nat (minus n (S m)) (pred (minus n m)))))
  :=
  nat_elim2
    (__:(sttfa.etap (sttfa.p nat)) =>
     _0:(sttfa.etap (sttfa.p nat)) => logic.eq nat (minus __ (S _0)) (pred (minus __ _0)))
    (_n:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_minus
       O
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
        logic.eq nat (minus O (S _n)) (pred (y _n)))
       (sym_eq_minus
          O
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           logic.eq nat (y (S _n)) (pred (filter_nat_type (sttfa.arrow nat nat) minus_body O _n)))
          (sym_eq_filter_nat_type_O
             (sttfa.arrow nat nat)
             minus_body
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              logic.eq
                nat
                (y (S _n))
                (pred (filter_nat_type (sttfa.arrow nat nat) minus_body O _n)))
             (sym_eq_filter_nat_type_O
                (sttfa.arrow nat nat)
                minus_body
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                 logic.eq nat (minus_body O (S _n)) (pred (y _n)))
                (sym_eq_minus_body_O
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                    logic.eq nat (minus_body O (S _n)) (pred (y _n)))
                   (sym_eq_minus_body_O
                      (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                       logic.eq
                         nat
                         (y (S _n))
                         (match_nat_type nat O (p:(sttfa.etap (sttfa.p nat)) => p) O))
                      (sym_eq_match_nat_type_O
                         nat
                         O
                         (p:(sttfa.etap (sttfa.p nat)) => p)
                         (y:(sttfa.etap (sttfa.p nat)) => logic.eq nat O y)
                         (logic.refl nat O))))))))
    (n:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_minus
       (S n)
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
        logic.eq nat (minus (S n) (S O)) (pred (y O)))
       (sym_eq_minus
          (S n)
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           logic.eq nat (y (S O)) (pred (filter_nat_type (sttfa.arrow nat nat) minus_body (S n) O)))
          (sym_eq_filter_nat_type_S
             (sttfa.arrow nat nat)
             minus_body
             n
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              logic.eq
                nat
                (y (S O))
                (pred (filter_nat_type (sttfa.arrow nat nat) minus_body (S n) O)))
             (sym_eq_filter_nat_type_S
                (sttfa.arrow nat nat)
                minus_body
                n
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                 logic.eq nat (minus_body (S n) (S O)) (pred (y O)))
                (sym_eq_minus_body_S
                   n
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                    logic.eq nat (minus_body (S n) (S O)) (pred (y O)))
                   (sym_eq_minus_body_S
                      n
                      (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                       logic.eq
                         nat
                         (y (S O))
                         (pred
                            (match_nat_type
                               nat
                               (S n)
                               (q:(sttfa.etap (sttfa.p nat)) => minus n q)
                               O)))
                      (sym_eq_match_nat_type_S
                         nat
                         (S n)
                         (q:(sttfa.etap (sttfa.p nat)) => minus n q)
                         O
                         (y:(sttfa.etap (sttfa.p nat)) =>
                          logic.eq
                            nat
                            y
                            (match_nat_type
                               nat
                               O
                               (p:(sttfa.etap (sttfa.p nat)) => p)
                               (match_nat_type
                                  nat
                                  (S n)
                                  (q:(sttfa.etap (sttfa.p nat)) => minus n q)
                                  O)))
                         (sym_eq_match_nat_type_O
                            nat
                            (S n)
                            (q:(sttfa.etap (sttfa.p nat)) => minus n q)
                            (y:(sttfa.etap (sttfa.p nat)) =>
                             logic.eq
                               nat
                               (minus n O)
                               (match_nat_type nat O (p:(sttfa.etap (sttfa.p nat)) => p) y))
                            (sym_eq_match_nat_type_S
                               nat
                               O
                               (q:(sttfa.etap (sttfa.p nat)) => q)
                               n
                               (y:(sttfa.etap (sttfa.p nat)) => logic.eq nat (minus n O) y)
                               (logic.rewrite_l
                                  nat
                                  n
                                  (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat __ n)
                                  (logic.refl nat n)
                                  (minus n O)
                                  (minus_n_O n)))))))))))
    (n:(sttfa.etap (sttfa.p nat)) =>
     m:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_minus
       (S n)
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
        sttfa.impl
          (logic.eq nat (minus n (S m)) (pred (minus n m)))
          (logic.eq nat (minus (S n) (S (S m))) (pred (y (S m)))))
       (sym_eq_minus
          (S n)
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           sttfa.impl
             (logic.eq nat (minus n (S m)) (pred (minus n m)))
             (logic.eq
                nat
                (y (S (S m)))
                (pred (filter_nat_type (sttfa.arrow nat nat) minus_body (S n) (S m)))))
          (sym_eq_filter_nat_type_S
             (sttfa.arrow nat nat)
             minus_body
             n
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              sttfa.impl
                (logic.eq nat (minus n (S m)) (pred (minus n m)))
                (logic.eq
                   nat
                   (y (S (S m)))
                   (pred (filter_nat_type (sttfa.arrow nat nat) minus_body (S n) (S m)))))
             (sym_eq_filter_nat_type_S
                (sttfa.arrow nat nat)
                minus_body
                n
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                 sttfa.impl
                   (logic.eq nat (minus n (S m)) (pred (minus n m)))
                   (logic.eq nat (minus_body (S n) (S (S m))) (pred (y (S m)))))
                (sym_eq_minus_body_S
                   n
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                    sttfa.impl
                      (logic.eq nat (minus n (S m)) (pred (minus n m)))
                      (logic.eq nat (minus_body (S n) (S (S m))) (pred (y (S m)))))
                   (sym_eq_minus_body_S
                      n
                      (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                       sttfa.impl
                         (logic.eq nat (minus n (S m)) (pred (minus n m)))
                         (logic.eq
                            nat
                            (y (S (S m)))
                            (pred
                               (match_nat_type
                                  nat
                                  (S n)
                                  (q:(sttfa.etap (sttfa.p nat)) => minus n q)
                                  (S m)))))
                      (sym_eq_match_nat_type_S
                         nat
                         (S n)
                         (q:(sttfa.etap (sttfa.p nat)) => minus n q)
                         (S m)
                         (y:(sttfa.etap (sttfa.p nat)) =>
                          sttfa.impl
                            (logic.eq nat (minus n (S m)) (pred (minus n m)))
                            (logic.eq
                               nat
                               y
                               (match_nat_type
                                  nat
                                  O
                                  (p:(sttfa.etap (sttfa.p nat)) => p)
                                  (match_nat_type
                                     nat
                                     (S n)
                                     (q:(sttfa.etap (sttfa.p nat)) => minus n q)
                                     (S m)))))
                         (sym_eq_match_nat_type_S
                            nat
                            (S n)
                            (q:(sttfa.etap (sttfa.p nat)) => minus n q)
                            m
                            (y:(sttfa.etap (sttfa.p nat)) =>
                             sttfa.impl
                               (logic.eq nat (minus n (S m)) (pred (minus n m)))
                               (logic.eq
                                  nat
                                  (minus n (S m))
                                  (match_nat_type
                                     nat
                                     O
                                     (p:(sttfa.etap (sttfa.p nat)) => p)
                                     y)))
                            (auto:(sttfa.eps
                                     (logic.eq
                                        nat
                                        (minus n (S m))
                                        (match_nat_type
                                           nat
                                           O
                                           (p:(sttfa.etap (sttfa.p nat)) => p)
                                           (minus n m)))) =>
                             logic.rewrite_r
                               nat
                               (match_nat_type
                                  nat
                                  O
                                  (p:(sttfa.etap (sttfa.p nat)) => p)
                                  (minus n m))
                               (__:(sttfa.etap (sttfa.p nat)) =>
                                logic.eq
                                  nat
                                  __
                                  (match_nat_type
                                     nat
                                     O
                                     (p:(sttfa.etap (sttfa.p nat)) => p)
                                     (minus n m)))
                               (logic.refl
                                  nat
                                  (match_nat_type
                                     nat
                                     O
                                     (p:(sttfa.etap (sttfa.p nat)) => p)
                                     (minus n m)))
                               (minus n (S m))
                               auto))))))))).

def not_eq_S :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.impl
             (connectives.Not (logic.eq nat n m))
             (connectives.Not (logic.eq nat (S n) (S m))))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  auto:(sttfa.eps (connectives.Not (logic.eq nat n m))) =>
  logic.not_to_not
    (logic.eq nat (S n) (S m))
    (logic.eq nat n m)
    (auto':(sttfa.eps (logic.eq nat (S n) (S m))) =>
     logic.rewrite_l
       nat
       m
       (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat __ m)
       (logic.refl nat m)
       n
       (logic.rewrite_r
          nat
          (pred (S n))
          (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat m __)
          (logic.rewrite_r
             nat
             (S m)
             (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat m (pred __))
             (pred_Sn m)
             (S n)
             auto')
          n
          (pred_Sn n)))
    auto.

def not_eq_O_S :
  sttfa.eps
    (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => connectives.Not (logic.eq nat O (S n))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  connectives.nmk
    (logic.eq nat O (S n))
    (eqOS:(sttfa.eps (logic.eq nat O (S n))) =>
     eq_match_nat_type_O
       sttfa.bool
       connectives.False
       (p:(sttfa.etap (sttfa.p nat)) => connectives.True)
       (y:(sttfa.etap (sttfa.p sttfa.bool)) => y)
       (logic.eq_ind_r
          nat
          (S n)
          (x:(sttfa.etap (sttfa.p nat)) => not_zero x)
          (sym_eq_match_nat_type_S
             sttfa.bool
             connectives.False
             (p:(sttfa.etap (sttfa.p nat)) => connectives.True)
             n
             (y:(sttfa.etap (sttfa.p sttfa.bool)) => y)
             connectives.I)
          O
          eqOS)).

def lt_to_not_zero :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (lt n m) (not_zero m))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  Hlt:(sttfa.eps (lt n m)) =>
  le_ind
    (S n)
    (x_417:(sttfa.etap (sttfa.p nat)) => not_zero x_417)
    (sym_eq_match_nat_type_S
       sttfa.bool
       connectives.False
       (p:(sttfa.etap (sttfa.p nat)) => connectives.True)
       n
       (y:(sttfa.etap (sttfa.p sttfa.bool)) => y)
       connectives.I)
    (m0:(sttfa.etap (sttfa.p nat)) =>
     _x_419:(sttfa.eps (le (S n) m0)) =>
     _x_421:(sttfa.eps (not_zero m0)) =>
     sym_eq_match_nat_type_S
       sttfa.bool
       connectives.False
       (p:(sttfa.etap (sttfa.p nat)) => connectives.True)
       m0
       (y:(sttfa.etap (sttfa.p sttfa.bool)) => y)
       connectives.I)
    m
    Hlt.

def le_S_S :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (le n m) (le (S n) (S m)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  lenm:(sttfa.eps (le n m)) =>
  le_ind
    n
    (x_417:(sttfa.etap (sttfa.p nat)) => le (S n) (S x_417))
    (le_n (S n))
    (m0:(sttfa.etap (sttfa.p nat)) =>
     _x_419:(sttfa.eps (le n m0)) => _x_421:(sttfa.eps (le (S n) (S m0))) => le_S (S n) (S m0) _x_421)
    m
    lenm.

def le_O_n :
  sttfa.eps (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => le O n))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  nat_ind
    (le O)
    (le_n O)
    (x_366:(sttfa.etap (sttfa.p nat)) => _x_368:(sttfa.eps (le O x_366)) => le_S O x_366 _x_368)
    n.

def le_n_Sn :
  sttfa.eps (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => le n (S n)))
  :=
  n:(sttfa.etap (sttfa.p nat)) => le_S n n (le_n n).

def transitive_le :
  sttfa.eps (relations.transitive nat le)
  :=
  a:(sttfa.etap (sttfa.p nat)) =>
  b:(sttfa.etap (sttfa.p nat)) =>
  c:(sttfa.etap (sttfa.p nat)) =>
  leab:(sttfa.eps (le a b)) =>
  lebc:(sttfa.eps (le b c)) =>
  le_ind
    b
    (x_417:(sttfa.etap (sttfa.p nat)) => le a x_417)
    leab
    (m:(sttfa.etap (sttfa.p nat)) =>
     _x_419:(sttfa.eps (le b m)) => _x_421:(sttfa.eps (le a m)) => le_S a m _x_421)
    c
    lebc.

def le_pred_n :
  sttfa.eps (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => le (pred n) n))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat)) => le (pred _x_365) _x_365)
    (eq_match_nat_type_O
       nat
       O
       (p:(sttfa.etap (sttfa.p nat)) => p)
       (y:(sttfa.etap (sttfa.p nat)) =>
        le (match_nat_type nat O (p:(sttfa.etap (sttfa.p nat)) => p) O) y)
       (le_n (pred O)))
    (x_366:(sttfa.etap (sttfa.p nat)) =>
     _x_368:(sttfa.eps (le (pred x_366) x_366)) =>
     eq_match_nat_type_S
       nat
       O
       (p:(sttfa.etap (sttfa.p nat)) => p)
       x_366
       (y:(sttfa.etap (sttfa.p nat)) => le (pred (S x_366)) (S y))
       (le_n_Sn (pred (S x_366))))
    n.

def monotonic_pred :
  sttfa.eps (relations.monotonic nat le pred)
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  lenm:(sttfa.eps (le n m)) =>
  le_ind
    n
    (x_417:(sttfa.etap (sttfa.p nat)) => le (pred n) (pred x_417))
    (le_n (pred n))
    (m0:(sttfa.etap (sttfa.p nat)) =>
     _x_419:(sttfa.eps (le n m0)) =>
     _x_421:(sttfa.eps (le (pred n) (pred m0))) =>
     transitive_le
       (pred n)
       n
       (pred (S m0))
       (le_pred_n n)
       (sym_eq_match_nat_type_S
          nat
          O
          (p:(sttfa.etap (sttfa.p nat)) => p)
          m0
          (y:(sttfa.etap (sttfa.p nat)) => le n y)
          _x_419))
    m
    lenm.

def le_S_S_to_le :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (le (S n) (S m)) (le n m))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  auto:(sttfa.eps (le (S n) (S m))) =>
  eq_match_nat_type_S
    nat
    O
    (p:(sttfa.etap (sttfa.p nat)) => p)
    m
    (y:(sttfa.etap (sttfa.p nat)) => le n y)
    (eq_match_nat_type_S
       nat
       O
       (p:(sttfa.etap (sttfa.p nat)) => p)
       n
       (y:(sttfa.etap (sttfa.p nat)) =>
        le y (match_nat_type nat O (p:(sttfa.etap (sttfa.p nat)) => p) (S m)))
       (monotonic_pred (S n) (S m) auto)).

def monotonic_le_plus_r :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        relations.monotonic nat le (m:(sttfa.etap (sttfa.p nat)) => plus n m)))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  a:(sttfa.etap (sttfa.p nat)) =>
  b:(sttfa.etap (sttfa.p nat)) =>
  nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat)) => sttfa.impl (le a b) (le (plus _x_365 a) (plus _x_365 b)))
    (sym_eq_plus
       O
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => sttfa.impl (le a b) (le (plus O a) (y b)))
       (sym_eq_plus
          O
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           sttfa.impl (le a b) (le (y a) (filter_nat_type (sttfa.arrow nat nat) plus_body O b)))
          (sym_eq_filter_nat_type_O
             (sttfa.arrow nat nat)
             plus_body
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              sttfa.impl (le a b) (le (y a) (filter_nat_type (sttfa.arrow nat nat) plus_body O b)))
             (sym_eq_filter_nat_type_O
                (sttfa.arrow nat nat)
                plus_body
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                 sttfa.impl (le a b) (le (plus_body O a) (y b)))
                (sym_eq_plus_body_O
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                    sttfa.impl (le a b) (le (plus_body O a) (y b)))
                   (sym_eq_plus_body_O
                      (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                       sttfa.impl (le a b) (le (y a) b))
                      (auto:(sttfa.eps (le a b)) => auto)))))))
    (m:(sttfa.etap (sttfa.p nat)) =>
     H:(sttfa.eps (sttfa.impl (le a b) (le (plus m a) (plus m b)))) =>
     leab:(sttfa.eps (le a b)) =>
     sym_eq_plus
       (S m)
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => le (plus (S m) a) (y b))
       (sym_eq_plus
          (S m)
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           le (y a) (filter_nat_type (sttfa.arrow nat nat) plus_body (S m) b))
          (sym_eq_filter_nat_type_S
             (sttfa.arrow nat nat)
             plus_body
             m
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              le (y a) (filter_nat_type (sttfa.arrow nat nat) plus_body (S m) b))
             (sym_eq_filter_nat_type_S
                (sttfa.arrow nat nat)
                plus_body
                m
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => le (plus_body (S m) a) (y b))
                (sym_eq_plus_body_S
                   m
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                    le (plus_body (S m) a) (y b))
                   (sym_eq_plus_body_S
                      m
                      (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                       le (y a) (S (plus m b)))
                      (le_S_S (plus m a) (plus m b) (H leab))))))))
    n.

def monotonic_le_plus_l :
  sttfa.eps
    (sttfa.forall
       nat
       (m:(sttfa.etap (sttfa.p nat)) =>
        relations.monotonic nat le (n:(sttfa.etap (sttfa.p nat)) => plus n m)))
  :=
  m:(sttfa.etap (sttfa.p nat)) =>
  x:(sttfa.etap (sttfa.p nat)) =>
  y:(sttfa.etap (sttfa.p nat)) =>
  auto:(sttfa.eps (le x y)) =>
  logic.eq_coerc
    (le (plus m x) (plus m y))
    (le (plus x m) (plus y m))
    (monotonic_le_plus_r m x y auto)
    (logic.rewrite_r
       nat
       (plus m x)
       (__:(sttfa.etap (sttfa.p nat)) =>
        logic.eq sttfa.bool (le (plus m x) (plus m y)) (le __ (plus y m)))
       (logic.rewrite_r
          nat
          (plus m y)
          (__:(sttfa.etap (sttfa.p nat)) =>
           logic.eq sttfa.bool (le (plus m x) (plus m y)) (le (plus m x) __))
          (logic.refl sttfa.bool (le (plus m x) (plus m y)))
          (plus y m)
          (commutative_plus y m))
       (plus x m)
       (commutative_plus x m)).

def le_plus :
  sttfa.eps
    (sttfa.forall
       nat
       (n1:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (n2:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (m1:(sttfa.etap (sttfa.p nat)) =>
              sttfa.forall
                nat
                (m2:(sttfa.etap (sttfa.p nat)) =>
                 sttfa.impl (le n1 n2) (sttfa.impl (le m1 m2) (le (plus n1 m1) (plus n2 m2))))))))
  :=
  n1:(sttfa.etap (sttfa.p nat)) =>
  n2:(sttfa.etap (sttfa.p nat)) =>
  m1:(sttfa.etap (sttfa.p nat)) =>
  m2:(sttfa.etap (sttfa.p nat)) =>
  len:(sttfa.eps (le n1 n2)) =>
  lem:(sttfa.eps (le m1 m2)) =>
  transitive_le
    (plus n1 m1)
    (plus n1 m2)
    (plus n2 m2)
    (monotonic_le_plus_r n1 m1 m2 lem)
    (monotonic_le_plus_l m2 n1 n2 len).

def le_plus_n :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => le m (plus n m))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  logic.eq_coerc
    (le (plus O m) (plus n m))
    (le m (plus n m))
    (monotonic_le_plus_l m O n (le_O_n n))
    (logic.rewrite_l
       nat
       m
       (__:(sttfa.etap (sttfa.p nat)) => logic.eq sttfa.bool (le __ (plus n m)) (le m (plus n m)))
       (logic.refl sttfa.bool (le m (plus n m)))
       (plus O m)
       (plus_O_n m)).

def le_plus_b :
  sttfa.eps
    (sttfa.forall
       nat
       (b:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (n:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (le (plus n b) m) (le n m)))))
  :=
  b:(sttfa.etap (sttfa.p nat)) =>
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  auto:(sttfa.eps (le (plus n b) m)) =>
  transitive_le
    n
    (plus n b)
    m
    (logic.eq_coerc
       (le n (plus b n))
       (le n (plus n b))
       (le_plus_n b n)
       (logic.rewrite_r
          nat
          (plus b n)
          (__:(sttfa.etap (sttfa.p nat)) => logic.eq sttfa.bool (le n (plus b n)) (le n __))
          (logic.refl sttfa.bool (le n (plus b n)))
          (plus n b)
          (commutative_plus n b)))
    auto.

def le_plus_n_r :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => le m (plus m n))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  logic.eq_coerc
    (le m (plus n m))
    (le m (plus m n))
    (le_plus_n n m)
    (logic.rewrite_r
       nat
       (plus n m)
       (__:(sttfa.etap (sttfa.p nat)) => logic.eq sttfa.bool (le m (plus n m)) (le m __))
       (logic.refl sttfa.bool (le m (plus n m)))
       (plus m n)
       (commutative_plus m n)).

def le_plus_to_le :
  sttfa.eps
    (sttfa.forall
       nat
       (a:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (n:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (le (plus a n) (plus a m)) (le n m)))))
  :=
  a:(sttfa.etap (sttfa.p nat)) =>
  nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat)) =>
     sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (le (plus _x_365 n) (plus _x_365 m)) (le n m))))
    (n:(sttfa.etap (sttfa.p nat)) =>
     m:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_plus
       O
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => sttfa.impl (le (plus O n) (y m)) (le n m))
       (sym_eq_plus
          O
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           sttfa.impl (le (y n) (filter_nat_type (sttfa.arrow nat nat) plus_body O m)) (le n m))
          (sym_eq_filter_nat_type_O
             (sttfa.arrow nat nat)
             plus_body
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              sttfa.impl (le (y n) (filter_nat_type (sttfa.arrow nat nat) plus_body O m)) (le n m))
             (sym_eq_filter_nat_type_O
                (sttfa.arrow nat nat)
                plus_body
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                 sttfa.impl (le (plus_body O n) (y m)) (le n m))
                (sym_eq_plus_body_O
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                    sttfa.impl (le (plus_body O n) (y m)) (le n m))
                   (sym_eq_plus_body_O
                      (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                       sttfa.impl (le (y n) m) (le n m))
                      (auto:(sttfa.eps (le n m)) => auto)))))))
    (x_366:(sttfa.etap (sttfa.p nat)) =>
     _x_368:(sttfa.eps
               (sttfa.forall
                  nat
                  (n:(sttfa.etap (sttfa.p nat)) =>
                   sttfa.forall
                     nat
                     (m:(sttfa.etap (sttfa.p nat)) =>
                      sttfa.impl (le (plus x_366 n) (plus x_366 m)) (le n m))))) =>
     n:(sttfa.etap (sttfa.p nat)) =>
     m:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_plus
       (S x_366)
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
        sttfa.impl (le (plus (S x_366) n) (y m)) (le n m))
       (sym_eq_plus
          (S x_366)
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           sttfa.impl
             (le (y n) (filter_nat_type (sttfa.arrow nat nat) plus_body (S x_366) m))
             (le n m))
          (sym_eq_filter_nat_type_S
             (sttfa.arrow nat nat)
             plus_body
             x_366
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              sttfa.impl
                (le (y n) (filter_nat_type (sttfa.arrow nat nat) plus_body (S x_366) m))
                (le n m))
             (sym_eq_filter_nat_type_S
                (sttfa.arrow nat nat)
                plus_body
                x_366
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                 sttfa.impl (le (plus_body (S x_366) n) (y m)) (le n m))
                (sym_eq_plus_body_S
                   x_366
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                    sttfa.impl (le (plus_body (S x_366) n) (y m)) (le n m))
                   (sym_eq_plus_body_S
                      x_366
                      (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                       sttfa.impl (le (y n) (S (plus x_366 m))) (le n m))
                      (auto:(sttfa.eps (le (S (plus x_366 n)) (S (plus x_366 m)))) =>
                       logic.eq_coerc
                         (le (pred (S n)) (pred (S m)))
                         (le n m)
                         (monotonic_pred
                            (S n)
                            (S m)
                            (_x_368
                               (S n)
                               (S m)
                               (logic.eq_coerc
                                  (le (S (plus x_366 n)) (S (plus x_366 m)))
                                  (le (plus x_366 (S n)) (plus x_366 (S m)))
                                  auto
                                  (logic.rewrite_r
                                     nat
                                     (plus x_366 (S n))
                                     (__:(sttfa.etap (sttfa.p nat)) =>
                                      logic.eq
                                        sttfa.bool
                                        (le __ (S (plus x_366 m)))
                                        (le (plus x_366 (S n)) (plus x_366 (S m))))
                                     (logic.rewrite_r
                                        nat
                                        (plus x_366 (S m))
                                        (__:(sttfa.etap (sttfa.p nat)) =>
                                         logic.eq
                                           sttfa.bool
                                           (le (plus x_366 (S n)) __)
                                           (le (plus x_366 (S n)) (plus x_366 (S m))))
                                        (logic.refl
                                           sttfa.bool
                                           (le (plus x_366 (S n)) (plus x_366 (S m))))
                                        (S (plus x_366 m))
                                        (plus_n_Sm x_366 m))
                                     (S (plus x_366 n))
                                     (plus_n_Sm x_366 n)))))
                         (logic.rewrite_l
                            nat
                            n
                            (__:(sttfa.etap (sttfa.p nat)) =>
                             logic.eq sttfa.bool (le __ (pred (S m))) (le n m))
                            (logic.rewrite_l
                               nat
                               m
                               (__:(sttfa.etap (sttfa.p nat)) =>
                                logic.eq sttfa.bool (le n __) (le n m))
                               (logic.refl sttfa.bool (le n m))
                               (pred (S m))
                               (pred_Sn m))
                            (pred (S n))
                            (pred_Sn n)))))))))
    a.

def le_plus_to_le_r :
  sttfa.eps
    (sttfa.forall
       nat
       (a:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (n:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (le (plus n a) (plus m a)) (le n m)))))
  :=
  a:(sttfa.etap (sttfa.p nat)) =>
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  auto:(sttfa.eps (le (plus n a) (plus m a))) =>
  le_plus_to_le
    a
    n
    m
    (logic.eq_coerc
       (le (plus n a) (plus m a))
       (le (plus a n) (plus a m))
       auto
       (logic.rewrite_r
          nat
          (plus a n)
          (__:(sttfa.etap (sttfa.p nat)) =>
           logic.eq sttfa.bool (le __ (plus m a)) (le (plus a n) (plus a m)))
          (logic.rewrite_r
             nat
             (plus a m)
             (__:(sttfa.etap (sttfa.p nat)) =>
              logic.eq sttfa.bool (le (plus a n) __) (le (plus a n) (plus a m)))
             (logic.refl sttfa.bool (le (plus a n) (plus a m)))
             (plus m a)
             (commutative_plus m a))
          (plus n a)
          (commutative_plus n a))).

def monotonic_le_times_r :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        relations.monotonic nat le (m:(sttfa.etap (sttfa.p nat)) => times n m)))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  x:(sttfa.etap (sttfa.p nat)) =>
  y:(sttfa.etap (sttfa.p nat)) =>
  lexy:(sttfa.eps (le x y)) =>
  nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat)) => le (times _x_365 x) (times _x_365 y))
    (sym_eq_times
       O
       (z:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => le (times O x) (z y))
       (sym_eq_times
          O
          (z:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           le (z x) (filter_nat_type (sttfa.arrow nat nat) times_body O y))
          (sym_eq_filter_nat_type_O
             (sttfa.arrow nat nat)
             times_body
             (z:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              le (z x) (filter_nat_type (sttfa.arrow nat nat) times_body O y))
             (sym_eq_filter_nat_type_O
                (sttfa.arrow nat nat)
                times_body
                (z:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => le (times_body O x) (z y))
                (sym_eq_times_body_O
                   (z:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => le (times_body O x) (z y))
                   (sym_eq_times_body_O
                      (z:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => le (z x) O)
                      (le_O_n O)))))))
    (a:(sttfa.etap (sttfa.p nat)) =>
     lea:(sttfa.eps (le (times a x) (times a y))) =>
     sym_eq_times
       (S a)
       (z:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => le (times (S a) x) (z y))
       (sym_eq_times
          (S a)
          (z:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           le (z x) (filter_nat_type (sttfa.arrow nat nat) times_body (S a) y))
          (sym_eq_filter_nat_type_S
             (sttfa.arrow nat nat)
             times_body
             a
             (z:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              le (z x) (filter_nat_type (sttfa.arrow nat nat) times_body (S a) y))
             (sym_eq_filter_nat_type_S
                (sttfa.arrow nat nat)
                times_body
                a
                (z:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => le (times_body (S a) x) (z y))
                (sym_eq_times_body_S
                   a
                   (z:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                    le (times_body (S a) x) (z y))
                   (sym_eq_times_body_S
                      a
                      (z:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                       le (z x) (plus y (times a y)))
                      (le_plus x y (times a x) (times a y) lexy lea)))))))
    n.

def le_times :
  sttfa.eps
    (sttfa.forall
       nat
       (n1:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (n2:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (m1:(sttfa.etap (sttfa.p nat)) =>
              sttfa.forall
                nat
                (m2:(sttfa.etap (sttfa.p nat)) =>
                 sttfa.impl (le n1 n2) (sttfa.impl (le m1 m2) (le (times n1 m1) (times n2 m2))))))))
  :=
  n1:(sttfa.etap (sttfa.p nat)) =>
  n2:(sttfa.etap (sttfa.p nat)) =>
  m1:(sttfa.etap (sttfa.p nat)) =>
  m2:(sttfa.etap (sttfa.p nat)) =>
  len:(sttfa.eps (le n1 n2)) =>
  lem:(sttfa.eps (le m1 m2)) =>
  transitive_le
    (times n1 m1)
    (times n1 m2)
    (times n2 m2)
    (monotonic_le_times_r n1 m1 m2 lem)
    (logic.eq_coerc
       (le (times m2 n1) (times m2 n2))
       (le (times n1 m2) (times n2 m2))
       (monotonic_le_times_r m2 n1 n2 len)
       (logic.rewrite_r
          nat
          (times n1 m2)
          (__:(sttfa.etap (sttfa.p nat)) =>
           logic.eq sttfa.bool (le __ (times m2 n2)) (le (times n1 m2) (times n2 m2)))
          (logic.rewrite_r
             nat
             (times n2 m2)
             (__:(sttfa.etap (sttfa.p nat)) =>
              logic.eq sttfa.bool (le (times n1 m2) __) (le (times n1 m2) (times n2 m2)))
             (logic.refl sttfa.bool (le (times n1 m2) (times n2 m2)))
             (times m2 n2)
             (commutative_times m2 n2))
          (times m2 n1)
          (commutative_times m2 n1))).

def le_plus_minus_m_m :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => le n (plus (minus n m) m))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat)) =>
     sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => le _x_365 (plus (minus _x_365 m) m)))
    (sym_eq_minus
       O
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
        sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => le O (plus (y m) m)))
       (sym_eq_filter_nat_type_O
          (sttfa.arrow nat nat)
          minus_body
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => le O (plus (y m) m)))
          (sym_eq_minus_body_O
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => le O (plus (y m) m)))
             (m:(sttfa.etap (sttfa.p nat)) => le_plus_n_r m O))))
    (a:(sttfa.etap (sttfa.p nat)) =>
     Hind:(sttfa.eps
             (sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => le a (plus (minus a m) m)))) =>
     m:(sttfa.etap (sttfa.p nat)) =>
     match_nat_prop
       (__:(sttfa.etap (sttfa.p nat)) => le (S a) (plus (minus (S a) __) __))
       (sym_eq_minus
          (S a)
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => le (S a) (plus (y O) O))
          (sym_eq_filter_nat_type_S
             (sttfa.arrow nat nat)
             minus_body
             a
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => le (S a) (plus (y O) O))
             (sym_eq_minus_body_S
                a
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => le (S a) (plus (y O) O))
                (sym_eq_match_nat_type_O
                   nat
                   (S a)
                   (q:(sttfa.etap (sttfa.p nat)) => minus a q)
                   (y:(sttfa.etap (sttfa.p nat)) => le (S a) (plus y O))
                   (le_plus_n_r O (S a))))))
       (n0:(sttfa.etap (sttfa.p nat)) =>
        sym_eq_minus
          (S a)
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => le (S a) (plus (y (S n0)) (S n0)))
          (sym_eq_filter_nat_type_S
             (sttfa.arrow nat nat)
             minus_body
             a
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => le (S a) (plus (y (S n0)) (S n0)))
             (sym_eq_minus_body_S
                a
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                 le (S a) (plus (y (S n0)) (S n0)))
                (sym_eq_match_nat_type_S
                   nat
                   (S a)
                   (q:(sttfa.etap (sttfa.p nat)) => minus a q)
                   n0
                   (y:(sttfa.etap (sttfa.p nat)) => le (S a) (plus y (S n0)))
                   (logic.eq_coerc
                      (le (S a) (S (plus (minus a n0) n0)))
                      (le (S a) (plus (minus a n0) (S n0)))
                      (le_S_S a (plus (minus a n0) n0) (Hind n0))
                      (logic.rewrite_r
                         nat
                         (plus (minus a n0) (S n0))
                         (__:(sttfa.etap (sttfa.p nat)) =>
                          logic.eq
                            sttfa.bool
                            (le (S a) __)
                            (le (S a) (plus (minus a n0) (S n0))))
                         (logic.refl sttfa.bool (le (S a) (plus (minus a n0) (S n0))))
                         (S (plus (minus a n0) n0))
                         (plus_n_Sm (minus a n0) n0)))))))
       m)
    n.

def le_plus_to_minus_r :
  sttfa.eps
    (sttfa.forall
       nat
       (a:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (b:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (c:(sttfa.etap (sttfa.p nat)) => sttfa.impl (le (plus a b) c) (le a (minus c b))))))
  :=
  a:(sttfa.etap (sttfa.p nat)) =>
  b:(sttfa.etap (sttfa.p nat)) =>
  c:(sttfa.etap (sttfa.p nat)) =>
  H:(sttfa.eps (le (plus a b) c)) =>
  le_plus_to_le_r
    b
    a
    (minus c b)
    (transitive_le (plus a b) c (plus (minus c b) b) H (le_plus_minus_m_m c b)).

def lt_to_le :
  sttfa.eps
    (sttfa.forall
       nat
       (x:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall nat (y:(sttfa.etap (sttfa.p nat)) => sttfa.impl (lt x y) (le x y))))
  :=
  x:(sttfa.etap (sttfa.p nat)) =>
  y:(sttfa.etap (sttfa.p nat)) =>
  auto:(sttfa.eps (lt x y)) =>
  le_plus_b
    (S O)
    x
    y
    (logic.eq_coerc
       (le (S x) y)
       (le (plus x (S O)) y)
       auto
       (logic.rewrite_r
          nat
          (plus x (S O))
          (__:(sttfa.etap (sttfa.p nat)) => logic.eq sttfa.bool (le __ y) (le (plus x (S O)) y))
          (logic.refl sttfa.bool (le (plus x (S O)) y))
          (S x)
          (logic.rewrite_r
             nat
             (plus x O)
             (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat (S __) (plus x (S O)))
             (plus_n_Sm x O)
             x
             (plus_n_O x)))).

def transitive_lt :
  sttfa.eps (relations.transitive nat lt)
  :=
  a:(sttfa.etap (sttfa.p nat)) =>
  b:(sttfa.etap (sttfa.p nat)) =>
  c:(sttfa.etap (sttfa.p nat)) =>
  ltab:(sttfa.eps (lt a b)) =>
  ltbc:(sttfa.eps (lt b c)) =>
  le_ind
    (S b)
    (x_417:(sttfa.etap (sttfa.p nat)) => lt a x_417)
    (le_S (S a) b ltab)
    (m:(sttfa.etap (sttfa.p nat)) =>
     _x_419:(sttfa.eps (le (S b) m)) => _x_421:(sttfa.eps (lt a m)) => le_S (S a) m _x_421)
    c
    ltbc.

def lt_to_le_to_lt :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (p:(sttfa.etap (sttfa.p nat)) => sttfa.impl (lt n m) (sttfa.impl (le m p) (lt n p))))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  p:(sttfa.etap (sttfa.p nat)) =>
  H:(sttfa.eps (lt n m)) =>
  H1:(sttfa.eps (le m p)) =>
  le_ind
    m
    (x_417:(sttfa.etap (sttfa.p nat)) => lt n x_417)
    H
    (m0:(sttfa.etap (sttfa.p nat)) =>
     _x_419:(sttfa.eps (le m m0)) =>
     _x_421:(sttfa.eps (lt n m0)) =>
     transitive_lt
       n
       m0
       (S m0)
       _x_421
       (logic.eq_coerc
          (le (S m0) (plus O (S m0)))
          (le (S m0) (S m0))
          (le_plus_n O (S m0))
          (logic.rewrite_l
             nat
             (S m0)
             (__:(sttfa.etap (sttfa.p nat)) =>
              logic.eq sttfa.bool (le (S m0) __) (le (S m0) (S m0)))
             (logic.refl sttfa.bool (le (S m0) (S m0)))
             (plus O (S m0))
             (plus_O_n (S m0)))))
    p
    H1.

def le_to_lt_to_lt :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (p:(sttfa.etap (sttfa.p nat)) => sttfa.impl (le n m) (sttfa.impl (lt m p) (lt n p))))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  p:(sttfa.etap (sttfa.p nat)) =>
  H:(sttfa.eps (le n m)) =>
  le_ind
    n
    (x_417:(sttfa.etap (sttfa.p nat)) => sttfa.impl (lt x_417 p) (lt n p))
    (auto:(sttfa.eps (lt n p)) => auto)
    (m0:(sttfa.etap (sttfa.p nat)) =>
     _x_419:(sttfa.eps (le n m0)) =>
     _x_421:(sttfa.eps (sttfa.impl (lt m0 p) (lt n p))) =>
     auto:(sttfa.eps (lt (S m0) p)) =>
     _x_421
       (transitive_lt
          m0
          (S m0)
          p
          (logic.eq_coerc
             (le (S m0) (plus O (S m0)))
             (le (S m0) (S m0))
             (le_plus_n O (S m0))
             (logic.rewrite_l
                nat
                (S m0)
                (__:(sttfa.etap (sttfa.p nat)) =>
                 logic.eq sttfa.bool (le (S m0) __) (le (S m0) (S m0)))
                (logic.refl sttfa.bool (le (S m0) (S m0)))
                (plus O (S m0))
                (plus_O_n (S m0))))
          auto))
    m
    H.

def lt_S_to_lt :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (lt (S n) m) (lt n m))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  auto:(sttfa.eps (lt (S n) m)) =>
  transitive_lt
    n
    (S n)
    m
    (logic.eq_coerc
       (le (S n) (plus O (S n)))
       (le (S n) (S n))
       (le_plus_n O (S n))
       (logic.rewrite_l
          nat
          (S n)
          (__:(sttfa.etap (sttfa.p nat)) => logic.eq sttfa.bool (le (S n) __) (le (S n) (S n)))
          (logic.refl sttfa.bool (le (S n) (S n)))
          (plus O (S n))
          (plus_O_n (S n))))
    auto.

def ltn_to_ltO :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (lt n m) (lt O m))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  auto:(sttfa.eps (lt n m)) =>
  lt_to_le_to_lt
    O
    (S n)
    m
    (logic.eq_coerc
       (le (S O) (plus n (S O)))
       (le (S O) (S n))
       (le_plus_n n (S O))
       (logic.rewrite_l
          nat
          (S n)
          (__:(sttfa.etap (sttfa.p nat)) => logic.eq sttfa.bool (le (S O) __) (le (S O) (S n)))
          (logic.refl sttfa.bool (le (S O) (S n)))
          (plus n (S O))
          (logic.rewrite_r
             nat
             (plus n O)
             (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat (S __) (plus n (S O)))
             (plus_n_Sm n O)
             n
             (plus_n_O n))))
    auto.

def lt_O_S :
  sttfa.eps (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => lt O (S n)))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  ltn_to_ltO
    n
    (S n)
    (logic.eq_coerc
       (le (S n) (plus O (S n)))
       (le (S n) (S n))
       (le_plus_n O (S n))
       (logic.rewrite_l
          nat
          (S n)
          (__:(sttfa.etap (sttfa.p nat)) => logic.eq sttfa.bool (le (S n) __) (le (S n) (S n)))
          (logic.refl sttfa.bool (le (S n) (S n)))
          (plus O (S n))
          (plus_O_n (S n)))).

def monotonic_lt_plus_r :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        relations.monotonic nat lt (m:(sttfa.etap (sttfa.p nat)) => plus n m)))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  x:(sttfa.etap (sttfa.p nat)) =>
  y:(sttfa.etap (sttfa.p nat)) =>
  auto:(sttfa.eps (lt x y)) =>
  logic.eq_coerc
    (le (plus n (S x)) (plus n y))
    (le (S (plus n x)) (plus n y))
    (monotonic_le_plus_r n (S x) y auto)
    (logic.rewrite_r
       nat
       (plus n (S x))
       (__:(sttfa.etap (sttfa.p nat)) =>
        logic.eq sttfa.bool (le (plus n (S x)) (plus n y)) (le __ (plus n y)))
       (logic.refl sttfa.bool (le (plus n (S x)) (plus n y)))
       (S (plus n x))
       (plus_n_Sm n x)).

def monotonic_lt_plus_l :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        relations.monotonic nat lt (m:(sttfa.etap (sttfa.p nat)) => plus m n)))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  x:(sttfa.etap (sttfa.p nat)) =>
  y:(sttfa.etap (sttfa.p nat)) =>
  auto:(sttfa.eps (lt x y)) =>
  logic.eq_coerc
    (le (plus n (S x)) (plus n y))
    (le (S (plus x n)) (plus y n))
    (monotonic_le_plus_r n (S x) y auto)
    (logic.rewrite_r
       nat
       (plus n x)
       (__:(sttfa.etap (sttfa.p nat)) =>
        logic.eq sttfa.bool (le (plus n (S x)) (plus n y)) (le (S __) (plus y n)))
       (logic.rewrite_r
          nat
          (plus n (S x))
          (__:(sttfa.etap (sttfa.p nat)) =>
           logic.eq sttfa.bool (le (plus n (S x)) (plus n y)) (le __ (plus y n)))
          (logic.rewrite_r
             nat
             (plus n y)
             (__:(sttfa.etap (sttfa.p nat)) =>
              logic.eq sttfa.bool (le (plus n (S x)) (plus n y)) (le (plus n (S x)) __))
             (logic.refl sttfa.bool (le (plus n (S x)) (plus n y)))
             (plus y n)
             (commutative_plus y n))
          (S (plus n x))
          (plus_n_Sm n x))
       (plus x n)
       (commutative_plus x n)).

def monotonic_lt_times_r :
  sttfa.eps
    (sttfa.forall
       nat
       (c:(sttfa.etap (sttfa.p nat)) =>
        sttfa.impl (lt O c) (relations.monotonic nat lt (t:(sttfa.etap (sttfa.p nat)) => times c t))))
  :=
  c:(sttfa.etap (sttfa.p nat)) =>
  posc:(sttfa.eps (lt O c)) =>
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  ltnm:(sttfa.eps (lt n m)) =>
  le_ind
    (S n)
    (x_417:(sttfa.etap (sttfa.p nat)) => lt (times c n) (times c x_417))
    (logic.eq_coerc
       (le (S (plus O (times c n))) (plus c (times c n)))
       (le (S (times c n)) (times c (S n)))
       (monotonic_lt_plus_l (times c n) O c posc)
       (logic.rewrite_r
          nat
          (plus O (S (times c n)))
          (__:(sttfa.etap (sttfa.p nat)) =>
           logic.eq sttfa.bool (le __ (plus c (times c n))) (le (S (times c n)) (times c (S n))))
          (logic.rewrite_l
             nat
             (plus c (times c n))
             (__:(sttfa.etap (sttfa.p nat)) =>
              logic.eq
                sttfa.bool
                (le (plus O (S (times c n))) (plus c (times c n)))
                (le (S (times c n)) __))
             (logic.rewrite_l
                nat
                (S (times c n))
                (__:(sttfa.etap (sttfa.p nat)) =>
                 logic.eq
                   sttfa.bool
                   (le __ (plus c (times c n)))
                   (le (S (times c n)) (plus c (times c n))))
                (logic.refl sttfa.bool (le (S (times c n)) (plus c (times c n))))
                (plus O (S (times c n)))
                (plus_O_n (S (times c n))))
             (times c (S n))
             (times_n_Sm c n))
          (S (plus O (times c n)))
          (plus_n_Sm O (times c n))))
    (a:(sttfa.etap (sttfa.p nat)) =>
     __:(sttfa.eps (le (S n) a)) =>
     lt1:(sttfa.eps (le (S (times c n)) (times c a))) =>
     transitive_le
       (S (times c n))
       (times c a)
       (times c (S a))
       lt1
       (logic.eq_coerc
          (le (times c a) (plus (times c a) c))
          (le (times c a) (times c (S a)))
          (le_plus_n_r c (times c a))
          (logic.rewrite_l
             nat
             (plus c (times c a))
             (__1:(sttfa.etap (sttfa.p nat)) =>
              logic.eq sttfa.bool (le (times c a) (plus (times c a) c)) (le (times c a) __1))
             (logic.rewrite_r
                nat
                (plus c (times c a))
                (__1:(sttfa.etap (sttfa.p nat)) =>
                 logic.eq sttfa.bool (le (times c a) __1) (le (times c a) (plus c (times c a))))
                (logic.refl sttfa.bool (le (times c a) (plus c (times c a))))
                (plus (times c a) c)
                (commutative_plus (times c a) c))
             (times c (S a))
             (times_n_Sm c a))))
    m
    ltnm.

def monotonic_lt_times_l :
  sttfa.eps
    (sttfa.forall
       nat
       (c:(sttfa.etap (sttfa.p nat)) =>
        sttfa.impl (lt O c) (relations.monotonic nat lt (t:(sttfa.etap (sttfa.p nat)) => times t c))))
  :=
  c:(sttfa.etap (sttfa.p nat)) =>
  auto:(sttfa.eps (lt O c)) =>
  x:(sttfa.etap (sttfa.p nat)) =>
  y:(sttfa.etap (sttfa.p nat)) =>
  auto':(sttfa.eps (lt x y)) =>
  logic.eq_coerc
    (le (S (times c x)) (times c y))
    (le (S (times x c)) (times y c))
    (monotonic_lt_times_r c auto x y auto')
    (logic.rewrite_r
       nat
       (times c x)
       (__:(sttfa.etap (sttfa.p nat)) =>
        logic.eq sttfa.bool (le (S (times c x)) (times c y)) (le (S __) (times y c)))
       (logic.rewrite_r
          nat
          (times c y)
          (__:(sttfa.etap (sttfa.p nat)) =>
           logic.eq sttfa.bool (le (S (times c x)) (times c y)) (le (S (times c x)) __))
          (logic.refl sttfa.bool (le (S (times c x)) (times c y)))
          (times y c)
          (commutative_times y c))
       (times x c)
       (commutative_times x c)).

def lt_to_le_to_lt_times :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (p:(sttfa.etap (sttfa.p nat)) =>
              sttfa.forall
                nat
                (q:(sttfa.etap (sttfa.p nat)) =>
                 sttfa.impl
                   (lt n m)
                   (sttfa.impl (le p q) (sttfa.impl (lt O q) (lt (times n p) (times m q)))))))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  p:(sttfa.etap (sttfa.p nat)) =>
  q:(sttfa.etap (sttfa.p nat)) =>
  ltnm:(sttfa.eps (lt n m)) =>
  lepq:(sttfa.eps (le p q)) =>
  posq:(sttfa.eps (lt O q)) =>
  le_to_lt_to_lt
    (times n p)
    (times n q)
    (times m q)
    (monotonic_le_times_r n p q lepq)
    (monotonic_lt_times_l q posq n m ltnm).

def lt_times :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (p:(sttfa.etap (sttfa.p nat)) =>
              sttfa.forall
                nat
                (q:(sttfa.etap (sttfa.p nat)) =>
                 sttfa.impl (lt n m) (sttfa.impl (lt p q) (lt (times n p) (times m q))))))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  p:(sttfa.etap (sttfa.p nat)) =>
  q:(sttfa.etap (sttfa.p nat)) =>
  ltnm:(sttfa.eps (lt n m)) =>
  ltpq:(sttfa.eps (lt p q)) =>
  lt_to_le_to_lt_times n m p q ltnm (lt_to_le p q ltpq) (ltn_to_ltO p q ltpq).

def lt_plus_to_minus_r :
  sttfa.eps
    (sttfa.forall
       nat
       (a:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (b:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (c:(sttfa.etap (sttfa.p nat)) => sttfa.impl (lt (plus a b) c) (lt a (minus c b))))))
  :=
  a:(sttfa.etap (sttfa.p nat)) =>
  b:(sttfa.etap (sttfa.p nat)) =>
  c:(sttfa.etap (sttfa.p nat)) =>
  H:(sttfa.eps (lt (plus a b) c)) =>
  le_plus_to_minus_r
    (S a)
    b
    c
    (sym_eq_plus
       (S a)
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => le (y b) c)
       (sym_eq_filter_nat_type_S
          (sttfa.arrow nat nat)
          plus_body
          a
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => le (y b) c)
          (sym_eq_plus_body_S a (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) => le (y b) c) H))).

def lt_plus_Sn_r :
  sttfa.eps
    (sttfa.forall
       nat
       (a:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (x:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => lt a (plus (plus a x) (S n))))))
  :=
  a:(sttfa.etap (sttfa.p nat)) =>
  x:(sttfa.etap (sttfa.p nat)) =>
  n:(sttfa.etap (sttfa.p nat)) =>
  logic.eq_coerc
    (le (S a) (S (plus (plus a x) n)))
    (le (S a) (plus (plus a x) (S n)))
    (le_S_S
       a
       (plus (plus a x) n)
       (logic.eq_coerc
          (le a (plus a (plus x n)))
          (le a (plus (plus a x) n))
          (le_plus_n_r (plus x n) a)
          (logic.rewrite_r
             nat
             (plus n (plus a x))
             (__:(sttfa.etap (sttfa.p nat)) =>
              logic.eq sttfa.bool (le a (plus a (plus x n))) (le a __))
             (logic.rewrite_r
                nat
                (plus a (plus n x))
                (__:(sttfa.etap (sttfa.p nat)) =>
                 logic.eq sttfa.bool (le a (plus a (plus x n))) (le a __))
                (logic.rewrite_r
                   nat
                   (plus x n)
                   (__:(sttfa.etap (sttfa.p nat)) =>
                    logic.eq sttfa.bool (le a (plus a (plus x n))) (le a (plus a __)))
                   (logic.refl sttfa.bool (le a (plus a (plus x n))))
                   (plus n x)
                   (commutative_plus n x))
                (plus n (plus a x))
                (logic.rewrite_l
                   nat
                   (plus (plus a n) x)
                   (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat (plus n (plus a x)) __)
                   (assoc_plus1 x a n)
                   (plus a (plus n x))
                   (associative_plus a n x)))
             (plus (plus a x) n)
             (commutative_plus (plus a x) n))))
    (logic.rewrite_r
       nat
       (plus a (plus x (S n)))
       (__:(sttfa.etap (sttfa.p nat)) =>
        logic.eq sttfa.bool (le (S a) (S (plus (plus a x) n))) (le (S a) __))
       (logic.rewrite_r
          nat
          (plus (plus a x) (S n))
          (__:(sttfa.etap (sttfa.p nat)) =>
           logic.eq sttfa.bool (le (S a) __) (le (S a) (plus a (plus x (S n)))))
          (logic.rewrite_r
             nat
             (plus a (plus x (S n)))
             (__:(sttfa.etap (sttfa.p nat)) =>
              logic.eq sttfa.bool (le (S a) __) (le (S a) (plus a (plus x (S n)))))
             (logic.refl sttfa.bool (le (S a) (plus a (plus x (S n)))))
             (plus (plus a x) (S n))
             (associative_plus a x (S n)))
          (S (plus (plus a x) n))
          (plus_n_Sm (plus a x) n))
       (plus (plus a x) (S n))
       (associative_plus a x (S n))).

def not_le_Sn_O :
  sttfa.eps (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => connectives.Not (le (S n) O)))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  connectives.nmk
    (le (S n) O)
    (Hlen0:(sttfa.eps (le (S n) O)) =>
     eq_match_nat_type_O
       sttfa.bool
       connectives.False
       (p:(sttfa.etap (sttfa.p nat)) => connectives.True)
       (y:(sttfa.etap (sttfa.p sttfa.bool)) => y)
       (lt_to_not_zero n O Hlen0)).

def not_le_to_not_le_S_S :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.impl (connectives.Not (le n m)) (connectives.Not (le (S n) (S m))))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  auto:(sttfa.eps (connectives.Not (le n m))) =>
  logic.not_to_not
    (le (S n) (S m))
    (le n m)
    (auto':(sttfa.eps (le (S n) (S m))) =>
     logic.eq_coerc
       (le (pred (S n)) (pred (S m)))
       (le n m)
       (monotonic_pred (S n) (S m) auto')
       (logic.rewrite_l
          nat
          n
          (__:(sttfa.etap (sttfa.p nat)) => logic.eq sttfa.bool (le __ (pred (S m))) (le n m))
          (logic.rewrite_l
             nat
             m
             (__:(sttfa.etap (sttfa.p nat)) => logic.eq sttfa.bool (le n __) (le n m))
             (logic.refl sttfa.bool (le n m))
             (pred (S m))
             (pred_Sn m))
          (pred (S n))
          (pred_Sn n)))
    auto.

def not_le_S_S_to_not_le :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.impl (connectives.Not (le (S n) (S m))) (connectives.Not (le n m)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  auto:(sttfa.eps (connectives.Not (le (S n) (S m)))) =>
  logic.not_to_not (le n m) (le (S n) (S m)) (auto':(sttfa.eps (le n m)) => le_S_S n m auto') auto.

def not_le_Sn_n :
  sttfa.eps (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => connectives.Not (le (S n) n)))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat)) => connectives.Not (le (S _x_365) _x_365))
    (not_le_Sn_O O)
    (x_366:(sttfa.etap (sttfa.p nat)) =>
     _x_368:(sttfa.eps (connectives.Not (le (S x_366) x_366))) =>
     not_le_to_not_le_S_S (S x_366) x_366 _x_368)
    n.

def lt_to_not_le :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (lt n m) (connectives.Not (le m n)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  Hltnm:(sttfa.eps (lt n m)) =>
  le_ind
    (S n)
    (x_417:(sttfa.etap (sttfa.p nat)) => connectives.Not (le x_417 n))
    (not_le_Sn_n n)
    (m0:(sttfa.etap (sttfa.p nat)) =>
     _x_419:(sttfa.eps (le (S n) m0)) =>
     _x_421:(sttfa.eps (connectives.Not (le m0 n))) =>
     logic.not_to_not
       (le (S m0) n)
       (le m0 n)
       (auto:(sttfa.eps (le (S m0) n)) => lt_to_le m0 n auto)
       _x_421)
    m
    Hltnm.

def not_le_to_lt :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (connectives.Not (le n m)) (lt m n))))
  :=
  nat_elim2
    (__:(sttfa.etap (sttfa.p nat)) =>
     _0:(sttfa.etap (sttfa.p nat)) => sttfa.impl (connectives.Not (le __ _0)) (lt _0 __))
    (n:(sttfa.etap (sttfa.p nat)) =>
     abs:(sttfa.eps (connectives.Not (le O n))) =>
     connectives.falsity
       (lt n O)
       (logic.absurd
          (le O n)
          (logic.eq_coerc
             (le O (plus n O))
             (le O n)
             (le_plus_n n O)
             (logic.rewrite_l
                nat
                n
                (__:(sttfa.etap (sttfa.p nat)) => logic.eq sttfa.bool (le O __) (le O n))
                (logic.refl sttfa.bool (le O n))
                (plus n O)
                (plus_n_O n)))
          abs))
    (n:(sttfa.etap (sttfa.p nat)) => auto:(sttfa.eps (connectives.Not (le (S n) O))) => lt_O_S n)
    (n:(sttfa.etap (sttfa.p nat)) =>
     m:(sttfa.etap (sttfa.p nat)) =>
     Hind:(sttfa.eps (sttfa.impl (connectives.Not (le n m)) (lt m n))) =>
     HnotleSS:(sttfa.eps (connectives.Not (le (S n) (S m)))) =>
     le_S_S (S m) n (Hind (not_le_S_S_to_not_le n m HnotleSS))).

def not_lt_to_le :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (connectives.Not (lt n m)) (le m n))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  H:(sttfa.eps (connectives.Not (lt n m))) =>
  le_S_S_to_le
    m
    n
    (not_le_to_lt
       (S n)
       m
       (logic.not_to_not (le (S n) m) (lt n m) (auto:(sttfa.eps (le (S n) m)) => auto) H)).

def le_to_not_lt :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (le n m) (connectives.Not (lt m n)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  H:(sttfa.eps (le n m)) =>
  lt_to_not_le
    n
    (S m)
    (le_to_lt_to_lt
       n
       m
       (S m)
       H
       (logic.eq_coerc
          (le (S m) (plus O (S m)))
          (le (S m) (S m))
          (le_plus_n O (S m))
          (logic.rewrite_l
             nat
             (S m)
             (__:(sttfa.etap (sttfa.p nat)) => logic.eq sttfa.bool (le (S m) __) (le (S m) (S m)))
             (logic.refl sttfa.bool (le (S m) (S m)))
             (plus O (S m))
             (plus_O_n (S m))))).

def decidable_le :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => logic.decidable (le n m))))
  :=
  nat_elim2
    (__:(sttfa.etap (sttfa.p nat)) => _0:(sttfa.etap (sttfa.p nat)) => logic.decidable (le __ _0))
    (n:(sttfa.etap (sttfa.p nat)) =>
     connectives.or_introl (le O n) (connectives.Not (le O n)) (le_O_n n))
    (n:(sttfa.etap (sttfa.p nat)) =>
     connectives.or_intror (le (S n) O) (connectives.Not (le (S n) O)) (not_le_Sn_O n))
    (n:(sttfa.etap (sttfa.p nat)) =>
     m:(sttfa.etap (sttfa.p nat)) =>
     _clearme:(sttfa.eps (logic.decidable (le n m))) =>
     connectives.match_Or_prop
       (le n m)
       (connectives.Not (le n m))
       (logic.decidable (le (S n) (S m)))
       (auto:(sttfa.eps (le n m)) =>
        connectives.or_introl (le (S n) (S m)) (connectives.Not (le (S n) (S m))) (le_S_S n m auto))
       (auto:(sttfa.eps (connectives.Not (le n m))) =>
        connectives.or_intror
          (le (S n) (S m))
          (connectives.Not (le (S n) (S m)))
          (not_le_to_not_le_S_S n m auto))
       _clearme).

def decidable_lt :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => logic.decidable (lt n m))))
  :=
  n:(sttfa.etap (sttfa.p nat)) => m:(sttfa.etap (sttfa.p nat)) => decidable_le (S n) m.

def le_to_or_lt_eq :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.impl (le n m) (connectives.Or (lt n m) (logic.eq nat n m)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  lenm:(sttfa.eps (le n m)) =>
  le_ind
    n
    (x_417:(sttfa.etap (sttfa.p nat)) => connectives.Or (lt n x_417) (logic.eq nat n x_417))
    (relations.RC_reflexive nat lt n)
    (m0:(sttfa.etap (sttfa.p nat)) =>
     _x_419:(sttfa.eps (le n m0)) =>
     _x_421:(sttfa.eps (connectives.Or (lt n m0) (logic.eq nat n m0))) =>
     connectives.or_introl
       (lt n (S m0))
       (logic.eq nat n (S m0))
       (le_to_lt_to_lt
          n
          m0
          (S m0)
          _x_419
          (logic.eq_coerc
             (le (S m0) (plus O (S m0)))
             (le (S m0) (S m0))
             (le_plus_n O (S m0))
             (logic.rewrite_l
                nat
                (S m0)
                (__:(sttfa.etap (sttfa.p nat)) =>
                 logic.eq sttfa.bool (le (S m0) __) (le (S m0) (S m0)))
                (logic.refl sttfa.bool (le (S m0) (S m0)))
                (plus O (S m0))
                (plus_O_n (S m0))))))
    m
    lenm.

def lt_O_n_elim :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.impl
          (lt O n)
          (sttfa.forall
             (sttfa.arrow nat sttfa.bool)
             (P:(sttfa.etap (sttfa.p (sttfa.arrow nat sttfa.bool))) =>
              sttfa.impl (sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => P (S m))) (P n)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat)) =>
     sttfa.impl
       (lt O _x_365)
       (sttfa.forall
          (sttfa.arrow nat sttfa.bool)
          (P:(sttfa.etap (sttfa.p (sttfa.arrow nat sttfa.bool))) =>
           sttfa.impl (sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => P (S m))) (P _x_365))))
    (abs:(sttfa.eps (lt O O)) =>
     connectives.falsity
       (sttfa.forall
          (sttfa.arrow nat sttfa.bool)
          (P:(sttfa.etap (sttfa.p (sttfa.arrow nat sttfa.bool))) =>
           sttfa.impl (sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => P (S m))) (P O)))
       (logic.absurd (le (S O) O) abs (not_le_Sn_O O)))
    (x_366:(sttfa.etap (sttfa.p nat)) =>
     _x_368:(sttfa.eps
               (sttfa.impl
                  (lt O x_366)
                  (sttfa.forall
                     (sttfa.arrow nat sttfa.bool)
                     (P:(sttfa.etap (sttfa.p (sttfa.arrow nat sttfa.bool))) =>
                      sttfa.impl
                        (sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => P (S m)))
                        (P x_366))))) =>
     auto:(sttfa.eps (lt O (S x_366))) =>
     P:(sttfa.etap (sttfa.p (sttfa.arrow nat sttfa.bool))) =>
     auto':(sttfa.eps (sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => P (S m)))) => auto' x_366)
    n.

def le_n_O_elim :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.impl
          (le n O)
          (sttfa.forall
             (sttfa.arrow nat sttfa.bool)
             (P:(sttfa.etap (sttfa.p (sttfa.arrow nat sttfa.bool))) => sttfa.impl (P O) (P n)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  match_nat_prop
    (__:(sttfa.etap (sttfa.p nat)) =>
     sttfa.impl
       (le __ O)
       (sttfa.forall
          (sttfa.arrow nat sttfa.bool)
          (P:(sttfa.etap (sttfa.p (sttfa.arrow nat sttfa.bool))) => sttfa.impl (P O) (P __))))
    (auto:(sttfa.eps (le O O)) =>
     P:(sttfa.etap (sttfa.p (sttfa.arrow nat sttfa.bool))) => auto':(sttfa.eps (P O)) => auto')
    (a:(sttfa.etap (sttfa.p nat)) =>
     abs:(sttfa.eps (le (S a) O)) =>
     connectives.falsity
       (sttfa.forall
          (sttfa.arrow nat sttfa.bool)
          (P:(sttfa.etap (sttfa.p (sttfa.arrow nat sttfa.bool))) => sttfa.impl (P O) (P (S a))))
       (logic.absurd (le (S a) O) abs (not_le_Sn_O a)))
    n.

def lt_to_not_eq :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (lt n m) (connectives.Not (logic.eq nat n m)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  H:(sttfa.eps (lt n m)) =>
  logic.not_to_not
    (logic.eq nat n m)
    connectives.False
    (auto:(sttfa.eps (logic.eq nat n m)) =>
     logic.absurd
       (le (S n) n)
       (logic.eq_coerc
          (le (S n) m)
          (le (S n) n)
          H
          (logic.rewrite_l
             nat
             n
             (__:(sttfa.etap (sttfa.p nat)) => logic.eq sttfa.bool (le (S n) __) (le (S n) n))
             (logic.refl sttfa.bool (le (S n) n))
             m
             auto))
       (not_le_Sn_n n))
    (connectives.nmk connectives.False (auto:(sttfa.eps connectives.False) => auto)).

def le_n_O_to_eq :
  sttfa.eps
    (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => sttfa.impl (le n O) (logic.eq nat O n)))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  match_nat_prop
    (__:(sttfa.etap (sttfa.p nat)) => sttfa.impl (le __ O) (logic.eq nat O __))
    (auto:(sttfa.eps (le O O)) => logic.refl nat O)
    (a:(sttfa.etap (sttfa.p nat)) =>
     abs:(sttfa.eps (le (S a) O)) =>
     connectives.falsity (logic.eq nat O (S a)) (logic.absurd (le (S a) O) abs (not_le_Sn_O a)))
    n.

def le_to_le_to_eq :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.impl (le n m) (sttfa.impl (le m n) (logic.eq nat n m)))))
  :=
  nat_elim2
    (__:(sttfa.etap (sttfa.p nat)) =>
     _0:(sttfa.etap (sttfa.p nat)) =>
     sttfa.impl (le __ _0) (sttfa.impl (le _0 __) (logic.eq nat __ _0)))
    (n:(sttfa.etap (sttfa.p nat)) =>
     auto:(sttfa.eps (le O n)) =>
     auto':(sttfa.eps (le n O)) =>
     logic.sym_eq
       nat
       n
       O
       (logic.sym_eq
          nat
          O
          n
          (logic.eq_coerc
             (logic.eq nat O n)
             (logic.eq nat O n)
             (le_n_O_to_eq n auto')
             (logic.refl sttfa.bool (logic.eq nat O n)))))
    (n:(sttfa.etap (sttfa.p nat)) =>
     auto:(sttfa.eps (le (S n) O)) =>
     auto':(sttfa.eps (le O (S n))) => logic.sym_eq nat O (S n) (le_n_O_to_eq (S n) auto))
    (n:(sttfa.etap (sttfa.p nat)) =>
     m:(sttfa.etap (sttfa.p nat)) =>
     auto:(sttfa.eps (sttfa.impl (le n m) (sttfa.impl (le m n) (logic.eq nat n m)))) =>
     auto':(sttfa.eps (le (S n) (S m))) =>
     auto'':(sttfa.eps (le (S m) (S n))) =>
     logic.eq_f
       nat
       nat
       S
       n
       m
       (auto
          (logic.eq_coerc
             (le (pred (S n)) (pred (S m)))
             (le n m)
             (monotonic_pred (S n) (S m) auto')
             (logic.rewrite_l
                nat
                n
                (__:(sttfa.etap (sttfa.p nat)) =>
                 logic.eq sttfa.bool (le __ (pred (S m))) (le n m))
                (logic.rewrite_l
                   nat
                   m
                   (__:(sttfa.etap (sttfa.p nat)) => logic.eq sttfa.bool (le n __) (le n m))
                   (logic.refl sttfa.bool (le n m))
                   (pred (S m))
                   (pred_Sn m))
                (pred (S n))
                (pred_Sn n)))
          (logic.eq_coerc
             (le (pred (S m)) (pred (S n)))
             (le m n)
             (monotonic_pred (S m) (S n) auto'')
             (logic.rewrite_l
                nat
                m
                (__:(sttfa.etap (sttfa.p nat)) =>
                 logic.eq sttfa.bool (le __ (pred (S n))) (le m n))
                (logic.rewrite_l
                   nat
                   n
                   (__:(sttfa.etap (sttfa.p nat)) => logic.eq sttfa.bool (le m __) (le m n))
                   (logic.refl sttfa.bool (le m n))
                   (pred (S n))
                   (pred_Sn n))
                (pred (S m))
                (pred_Sn m))))).

def plus_minus :
  sttfa.eps
    (sttfa.forall
       nat
       (m:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (n:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (p:(sttfa.etap (sttfa.p nat)) =>
              sttfa.impl (le m n) (logic.eq nat (plus (minus n m) p) (minus (plus n p) m))))))
  :=
  nat_elim2
    (__:(sttfa.etap (sttfa.p nat)) =>
     _0:(sttfa.etap (sttfa.p nat)) =>
     sttfa.forall
       nat
       (p:(sttfa.etap (sttfa.p nat)) =>
        sttfa.impl (le __ _0) (logic.eq nat (plus (minus _0 __) p) (minus (plus _0 p) __))))
    (n:(sttfa.etap (sttfa.p nat)) =>
     p:(sttfa.etap (sttfa.p nat)) =>
     auto:(sttfa.eps (le O n)) =>
     logic.rewrite_l
       nat
       n
       (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat (plus __ p) (minus (plus n p) O))
       (logic.rewrite_l
          nat
          (plus n p)
          (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat (plus n p) __)
          (logic.refl nat (plus n p))
          (minus (plus n p) O)
          (minus_n_O (plus n p)))
       (minus n O)
       (minus_n_O n))
    (n:(sttfa.etap (sttfa.p nat)) =>
     p:(sttfa.etap (sttfa.p nat)) =>
     abs:(sttfa.eps (le (S n) O)) =>
     connectives.falsity
       (logic.eq nat (plus (minus O (S n)) p) (minus (plus O p) (S n)))
       (logic.absurd (le (S n) O) abs (not_le_Sn_O n)))
    (n:(sttfa.etap (sttfa.p nat)) =>
     m:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_minus
       (S m)
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
        sttfa.impl
          (sttfa.forall
             nat
             (p:(sttfa.etap (sttfa.p nat)) =>
              sttfa.impl (le n m) (logic.eq nat (plus (minus m n) p) (minus (plus m p) n))))
          (sttfa.forall
             nat
             (p:(sttfa.etap (sttfa.p nat)) =>
              sttfa.impl
                (le (S n) (S m))
                (logic.eq nat (plus (y (S n)) p) (minus (plus (S m) p) (S n))))))
       (sym_eq_filter_nat_type_S
          (sttfa.arrow nat nat)
          minus_body
          m
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           sttfa.impl
             (sttfa.forall
                nat
                (p:(sttfa.etap (sttfa.p nat)) =>
                 sttfa.impl (le n m) (logic.eq nat (plus (minus m n) p) (minus (plus m p) n))))
             (sttfa.forall
                nat
                (p:(sttfa.etap (sttfa.p nat)) =>
                 sttfa.impl
                   (le (S n) (S m))
                   (logic.eq nat (plus (y (S n)) p) (minus (plus (S m) p) (S n))))))
          (sym_eq_minus_body_S
             m
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              sttfa.impl
                (sttfa.forall
                   nat
                   (p:(sttfa.etap (sttfa.p nat)) =>
                    sttfa.impl (le n m) (logic.eq nat (plus (minus m n) p) (minus (plus m p) n))))
                (sttfa.forall
                   nat
                   (p:(sttfa.etap (sttfa.p nat)) =>
                    sttfa.impl
                      (le (S n) (S m))
                      (logic.eq nat (plus (y (S n)) p) (minus (plus (S m) p) (S n))))))
             (auto:(sttfa.eps
                      (sttfa.forall
                         nat
                         (p:(sttfa.etap (sttfa.p nat)) =>
                          sttfa.impl
                            (le n m)
                            (logic.eq nat (plus (minus m n) p) (minus (plus m p) n))))) =>
              p:(sttfa.etap (sttfa.p nat)) =>
              sym_eq_match_nat_type_S
                nat
                (S m)
                (q:(sttfa.etap (sttfa.p nat)) => minus m q)
                n
                (y:(sttfa.etap (sttfa.p nat)) =>
                 sttfa.impl
                   (le (S n) (S m))
                   (logic.eq nat (plus y p) (minus (plus (S m) p) (S n))))
                (sym_eq_minus
                   (plus (S m) p)
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                    sttfa.impl (le (S n) (S m)) (logic.eq nat (plus (minus m n) p) (y (S n))))
                   (sym_eq_plus
                      (S m)
                      (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                       sttfa.impl
                         (le (S n) (S m))
                         (logic.eq
                            nat
                            (plus (minus m n) p)
                            (filter_nat_type (sttfa.arrow nat nat) minus_body (y p) (S n))))
                      (sym_eq_filter_nat_type_S
                         (sttfa.arrow nat nat)
                         plus_body
                         m
                         (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                          sttfa.impl
                            (le (S n) (S m))
                            (logic.eq
                               nat
                               (plus (minus m n) p)
                               (filter_nat_type (sttfa.arrow nat nat) minus_body (y p) (S n))))
                         (sym_eq_plus_body_S
                            m
                            (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                             sttfa.impl
                               (le (S n) (S m))
                               (logic.eq
                                  nat
                                  (plus (minus m n) p)
                                  (filter_nat_type
                                     (sttfa.arrow nat nat)
                                     minus_body
                                     (y p)
                                     (S n))))
                            (sym_eq_filter_nat_type_S
                               (sttfa.arrow nat nat)
                               minus_body
                               (plus m p)
                               (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                                sttfa.impl
                                  (le (S n) (S m))
                                  (logic.eq nat (plus (minus m n) p) (y (S n))))
                               (eq_plus_body_S
                                  m
                                  (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                                   sttfa.impl
                                     (le (S n) (S m))
                                     (logic.eq
                                        nat
                                        (plus (minus m n) p)
                                        (minus_body (y p) (S n))))
                                  (eq_filter_nat_type_S
                                     (sttfa.arrow nat nat)
                                     plus_body
                                     m
                                     (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                                      sttfa.impl
                                        (le (S n) (S m))
                                        (logic.eq
                                           nat
                                           (plus (minus m n) p)
                                           (minus_body (y p) (S n))))
                                     (eq_plus
                                        (S m)
                                        (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                                         sttfa.impl
                                           (le (S n) (S m))
                                           (logic.eq
                                              nat
                                              (plus (minus m n) p)
                                              (minus_body (y p) (S n))))
                                        (sym_eq_plus
                                           (S m)
                                           (y:(sttfa.etap
                                                 (sttfa.p (sttfa.arrow nat nat))) =>
                                            sttfa.impl
                                              (le (S n) (S m))
                                              (logic.eq
                                                 nat
                                                 (plus (minus m n) p)
                                                 (minus_body (y p) (S n))))
                                           (sym_eq_filter_nat_type_S
                                              (sttfa.arrow nat nat)
                                              plus_body
                                              m
                                              (y:(sttfa.etap
                                                    (sttfa.p (sttfa.arrow nat nat))) =>
                                               sttfa.impl
                                                 (le (S n) (S m))
                                                 (logic.eq
                                                    nat
                                                    (plus (minus m n) p)
                                                    (minus_body (y p) (S n))))
                                              (sym_eq_plus_body_S
                                                 m
                                                 (y:(sttfa.etap
                                                       (sttfa.p
                                                          (sttfa.arrow nat nat))) =>
                                                  sttfa.impl
                                                    (le (S n) (S m))
                                                    (logic.eq
                                                       nat
                                                       (plus (minus m n) p)
                                                       (minus_body (y p) (S n))))
                                                 (sym_eq_minus_body_S
                                                    (plus m p)
                                                    (y:(sttfa.etap
                                                          (sttfa.p
                                                             (sttfa.arrow
                                                                nat
                                                                nat))) =>
                                                     sttfa.impl
                                                       (le (S n) (S m))
                                                       (logic.eq
                                                          nat
                                                          (plus (minus m n) p)
                                                          (y (S n))))
                                                    (sym_eq_match_nat_type_S
                                                       nat
                                                       (S (plus m p))
                                                       (q:(sttfa.etap
                                                             (sttfa.p nat)) =>
                                                        minus (plus m p) q)
                                                       n
                                                       (y:(sttfa.etap
                                                             (sttfa.p nat)) =>
                                                        sttfa.impl
                                                          (le (S n) (S m))
                                                          (logic.eq
                                                             nat
                                                             (plus (minus m n) p)
                                                             y))
                                                       (auto':(sttfa.eps
                                                                 (le (S n) (S m))) =>
                                                        auto
                                                          p
                                                          (logic.eq_coerc
                                                             (le
                                                                (pred (S n))
                                                                (pred (S m)))
                                                             (le n m)
                                                             (monotonic_pred
                                                                (S n)
                                                                (S m)
                                                                auto')
                                                             (logic.rewrite_l
                                                                nat
                                                                n
                                                                (__:(
                                                                 sttfa.etap
                                                                   (sttfa.p
                                                                    nat)) =>
                                                                 logic.eq
                                                                   sttfa.bool
                                                                   (le
                                                                    __
                                                                    (pred
                                                                    (S m)))
                                                                   (le n m))
                                                                (logic.rewrite_l
                                                                   nat
                                                                   m
                                                                   (__:(
                                                                    sttfa.etap
                                                                    (sttfa.p
                                                                    nat)) =>
                                                                    logic.eq
                                                                    sttfa.bool
                                                                    (le n __)
                                                                    (le n m))
                                                                   (logic.refl
                                                                    sttfa.bool
                                                                    (le n m))
                                                                   (pred (S m))
                                                                   (pred_Sn m))
                                                                (pred (S n))
                                                                (pred_Sn n))))))))))))))))))))).

def minus_plus_m_m :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall nat (m:(sttfa.etap (sttfa.p nat)) => logic.eq nat n (minus (plus n m) m))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  logic.eq_coerc
    (logic.eq nat (plus (minus m m) n) (minus (plus m n) m))
    (logic.eq nat n (minus (plus n m) m))
    (plus_minus m m n (le_n m))
    (logic.rewrite_l
       nat
       O
       (__:(sttfa.etap (sttfa.p nat)) =>
        logic.eq
          sttfa.bool
          (logic.eq nat (plus __ n) (minus (plus m n) m))
          (logic.eq nat n (minus (plus n m) m)))
       (logic.rewrite_l
          nat
          n
          (__:(sttfa.etap (sttfa.p nat)) =>
           logic.eq
             sttfa.bool
             (logic.eq nat __ (minus (plus m n) m))
             (logic.eq nat n (minus (plus n m) m)))
          (logic.rewrite_r
             nat
             (plus n m)
             (__:(sttfa.etap (sttfa.p nat)) =>
              logic.eq
                sttfa.bool
                (logic.eq nat n (minus __ m))
                (logic.eq nat n (minus (plus n m) m)))
             (logic.refl sttfa.bool (logic.eq nat n (minus (plus n m) m)))
             (plus m n)
             (commutative_plus m n))
          (plus O n)
          (plus_O_n n))
       (minus m m)
       (minus_n_n m)).

def plus_minus_m_m :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.impl (le m n) (logic.eq nat n (plus (minus n m) m)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  lemn:(sttfa.eps (le m n)) =>
  logic.sym_eq
    nat
    (plus (minus n m) m)
    n
    (logic.eq_coerc
       (logic.eq nat (plus (minus n m) m) (minus (plus n m) m))
       (logic.eq nat (plus (minus n m) m) n)
       (plus_minus m n m lemn)
       (logic.rewrite_r
          nat
          (plus m (minus n m))
          (__:(sttfa.etap (sttfa.p nat)) =>
           logic.eq
             sttfa.bool
             (logic.eq nat (plus (minus n m) m) (minus (plus n m) m))
             (logic.eq nat __ n))
          (logic.rewrite_r
             nat
             (plus m (minus n m))
             (__:(sttfa.etap (sttfa.p nat)) =>
              logic.eq
                sttfa.bool
                (logic.eq nat __ (minus (plus n m) m))
                (logic.eq nat (plus m (minus n m)) n))
             (logic.rewrite_l
                nat
                n
                (__:(sttfa.etap (sttfa.p nat)) =>
                 logic.eq
                   sttfa.bool
                   (logic.eq nat (plus m (minus n m)) __)
                   (logic.eq nat (plus m (minus n m)) n))
                (logic.refl sttfa.bool (logic.eq nat (plus m (minus n m)) n))
                (minus (plus n m) m)
                (minus_plus_m_m n m))
             (plus (minus n m) m)
             (commutative_plus (minus n m) m))
          (plus (minus n m) m)
          (commutative_plus (minus n m) m))).

def minus_to_plus :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (p:(sttfa.etap (sttfa.p nat)) =>
              sttfa.impl
                (le m n)
                (sttfa.impl (logic.eq nat (minus n m) p) (logic.eq nat n (plus m p)))))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  p:(sttfa.etap (sttfa.p nat)) =>
  lemn:(sttfa.eps (le m n)) =>
  eqp:(sttfa.eps (logic.eq nat (minus n m) p)) =>
  logic.eq_coerc
    (logic.eq nat n (plus (minus n m) m))
    (logic.eq nat n (plus m p))
    (plus_minus_m_m n m lemn)
    (logic.rewrite_r
       nat
       (plus m (minus n m))
       (__:(sttfa.etap (sttfa.p nat)) =>
        logic.eq sttfa.bool (logic.eq nat n __) (logic.eq nat n (plus m p)))
       (logic.rewrite_r
          nat
          p
          (__:(sttfa.etap (sttfa.p nat)) =>
           logic.eq sttfa.bool (logic.eq nat n (plus m __)) (logic.eq nat n (plus m p)))
          (logic.refl sttfa.bool (logic.eq nat n (plus m p)))
          (minus n m)
          eqp)
       (plus (minus n m) m)
       (commutative_plus (minus n m) m)).

def plus_to_minus :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (p:(sttfa.etap (sttfa.p nat)) =>
              sttfa.impl (logic.eq nat n (plus m p)) (logic.eq nat (minus n m) p)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  p:(sttfa.etap (sttfa.p nat)) =>
  eqp:(sttfa.eps (logic.eq nat n (plus m p))) =>
  logic.sym_eq
    nat
    p
    (minus n m)
    (logic.eq_coerc
       (logic.eq nat p (minus (plus p m) m))
       (logic.eq nat p (minus n m))
       (minus_plus_m_m p m)
       (logic.rewrite_r
          nat
          (plus m p)
          (__:(sttfa.etap (sttfa.p nat)) =>
           logic.eq sttfa.bool (logic.eq nat p (minus __ m)) (logic.eq nat p (minus n m)))
          (logic.rewrite_l
             nat
             n
             (__:(sttfa.etap (sttfa.p nat)) =>
              logic.eq sttfa.bool (logic.eq nat p (minus __ m)) (logic.eq nat p (minus n m)))
             (logic.refl sttfa.bool (logic.eq nat p (minus n m)))
             (plus m p)
             eqp)
          (plus p m)
          (commutative_plus p m))).

def monotonic_le_minus_l :
  sttfa.eps
    (sttfa.forall
       nat
       (p:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (q:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (n:(sttfa.etap (sttfa.p nat)) => sttfa.impl (le q p) (le (minus q n) (minus p n))))))
  :=
  nat_elim2
    (__:(sttfa.etap (sttfa.p nat)) =>
     _0:(sttfa.etap (sttfa.p nat)) =>
     sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) => sttfa.impl (le _0 __) (le (minus _0 n) (minus __ n))))
    (p:(sttfa.etap (sttfa.p nat)) =>
     q:(sttfa.etap (sttfa.p nat)) =>
     lePO:(sttfa.eps (le p O)) =>
     le_n_O_elim
       p
       lePO
       (__:(sttfa.etap (sttfa.p nat)) => le (minus __ q) (minus O q))
       (le_n (minus O q)))
    (p:(sttfa.etap (sttfa.p nat)) =>
     q:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_minus
       (S p)
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
        sttfa.impl (le O (S p)) (le (minus O q) (y q)))
       (sym_eq_filter_nat_type_S
          (sttfa.arrow nat nat)
          minus_body
          p
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           sttfa.impl (le O (S p)) (le (minus O q) (y q)))
          (sym_eq_minus_body_S
             p
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              sttfa.impl (le O (S p)) (le (minus O q) (y q)))
             (eq_plus_body_O
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                 sttfa.impl
                   (le O (S p))
                   (le
                      (minus O q)
                      (y
                         (match_nat_type
                            nat
                            (S p)
                            (q0:(sttfa.etap (sttfa.p nat)) => minus p q0)
                            q))))
                (eq_filter_nat_type_O
                   (sttfa.arrow nat nat)
                   plus_body
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                    sttfa.impl
                      (le O (S p))
                      (le
                         (minus O q)
                         (y
                            (match_nat_type
                               nat
                               (S p)
                               (q0:(sttfa.etap (sttfa.p nat)) => minus p q0)
                               q))))
                   (eq_plus
                      O
                      (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                       sttfa.impl
                         (le O (S p))
                         (le
                            (minus O q)
                            (y
                               (match_nat_type
                                  nat
                                  (S p)
                                  (q0:(sttfa.etap (sttfa.p nat)) => minus p q0)
                                  q))))
                      (eq_minus_body_O
                         (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                          sttfa.impl
                            (le O (S p))
                            (le
                               (minus O q)
                               (plus
                                  (y
                                     (match_nat_type
                                        nat
                                        (S p)
                                        (q0:(sttfa.etap (sttfa.p nat)) => minus p q0)
                                        q))
                                  (match_nat_type
                                     nat
                                     (S p)
                                     (q0:(sttfa.etap (sttfa.p nat)) => minus p q0)
                                     q))))
                         (eq_filter_nat_type_O
                            (sttfa.arrow nat nat)
                            minus_body
                            (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                             sttfa.impl
                               (le O (S p))
                               (le
                                  (minus O q)
                                  (plus
                                     (y
                                        (match_nat_type
                                           nat
                                           (S p)
                                           (q0:(sttfa.etap (sttfa.p nat)) => minus p q0)
                                           q))
                                     (match_nat_type
                                        nat
                                        (S p)
                                        (q0:(sttfa.etap (sttfa.p nat)) => minus p q0)
                                        q))))
                            (eq_minus
                               O
                               (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                                sttfa.impl
                                  (le O (S p))
                                  (le
                                     (minus O q)
                                     (plus
                                        (y
                                           (match_nat_type
                                              nat
                                              (S p)
                                              (q0:(sttfa.etap (sttfa.p nat)) =>
                                               minus p q0)
                                              q))
                                        (match_nat_type
                                           nat
                                           (S p)
                                           (q0:(sttfa.etap (sttfa.p nat)) => minus p q0)
                                           q))))
                               (eq_minus_body_O
                                  (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                                   sttfa.impl
                                     (le O (S p))
                                     (le
                                        (minus O q)
                                        (plus
                                           (minus
                                              (y q)
                                              (match_nat_type
                                                 nat
                                                 (S p)
                                                 (q0:(sttfa.etap (sttfa.p nat)) =>
                                                  minus p q0)
                                                 q))
                                           (match_nat_type
                                              nat
                                              (S p)
                                              (q0:(sttfa.etap (sttfa.p nat)) =>
                                               minus p q0)
                                              q))))
                                  (eq_filter_nat_type_O
                                     (sttfa.arrow nat nat)
                                     minus_body
                                     (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                                      sttfa.impl
                                        (le O (S p))
                                        (le
                                           (minus O q)
                                           (plus
                                              (minus
                                                 (y q)
                                                 (match_nat_type
                                                    nat
                                                    (S p)
                                                    (q0:(sttfa.etap (sttfa.p nat)) =>
                                                     minus p q0)
                                                    q))
                                              (match_nat_type
                                                 nat
                                                 (S p)
                                                 (q0:(sttfa.etap (sttfa.p nat)) =>
                                                  minus p q0)
                                                 q))))
                                     (eq_minus
                                        O
                                        (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                                         sttfa.impl
                                           (le O (S p))
                                           (le
                                              (minus O q)
                                              (plus
                                                 (minus
                                                    (y q)
                                                    (match_nat_type
                                                       nat
                                                       (S p)
                                                       (q0:(sttfa.etap
                                                              (sttfa.p nat)) =>
                                                        minus p q0)
                                                       q))
                                                 (match_nat_type
                                                    nat
                                                    (S p)
                                                    (q0:(sttfa.etap (sttfa.p nat)) =>
                                                     minus p q0)
                                                    q))))
                                        (auto:(sttfa.eps (le O (S p))) =>
                                         le_plus_minus_m_m
                                           (minus O q)
                                           (match_nat_type
                                              nat
                                              (S p)
                                              (q0:(sttfa.etap (sttfa.p nat)) =>
                                               minus p q0)
                                              q))))))))))))))
    (p:(sttfa.etap (sttfa.p nat)) =>
     q:(sttfa.etap (sttfa.p nat)) =>
     Hind:(sttfa.eps
             (sttfa.forall
                nat
                (n0:(sttfa.etap (sttfa.p nat)) =>
                 sttfa.impl (le q p) (le (minus q n0) (minus p n0))))) =>
     n:(sttfa.etap (sttfa.p nat)) =>
     match_nat_prop
       (__:(sttfa.etap (sttfa.p nat)) =>
        sttfa.impl (le (S q) (S p)) (le (minus (S q) __) (minus (S p) __)))
       (sym_eq_minus
          (S q)
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           sttfa.impl (le (S q) (S p)) (le (y O) (minus (S p) O)))
          (sym_eq_filter_nat_type_S
             (sttfa.arrow nat nat)
             minus_body
             q
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              sttfa.impl (le (S q) (S p)) (le (y O) (minus (S p) O)))
             (sym_eq_minus_body_S
                q
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                 sttfa.impl (le (S q) (S p)) (le (y O) (minus (S p) O)))
                (sym_eq_match_nat_type_O
                   nat
                   (S q)
                   (z:(sttfa.etap (sttfa.p nat)) => minus q z)
                   (y:(sttfa.etap (sttfa.p nat)) =>
                    sttfa.impl (le (S q) (S p)) (le y (minus (S p) O)))
                   (sym_eq_minus
                      (S p)
                      (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                       sttfa.impl (le (S q) (S p)) (le (S q) (y O)))
                      (sym_eq_filter_nat_type_S
                         (sttfa.arrow nat nat)
                         minus_body
                         p
                         (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                          sttfa.impl (le (S q) (S p)) (le (S q) (y O)))
                         (sym_eq_minus_body_S
                            p
                            (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                             sttfa.impl (le (S q) (S p)) (le (S q) (y O)))
                            (sym_eq_match_nat_type_O
                               nat
                               (S p)
                               (q0:(sttfa.etap (sttfa.p nat)) => minus p q0)
                               (y:(sttfa.etap (sttfa.p nat)) =>
                                sttfa.impl (le (S q) (S p)) (le (S q) y))
                               (auto:(sttfa.eps (le (S q) (S p))) => auto)))))))))
       (sym_eq_minus
          (S q)
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
           sttfa.forall
             nat
             (a:(sttfa.etap (sttfa.p nat)) =>
              sttfa.impl (le (S q) (S p)) (le (y (S a)) (minus (S p) (S a)))))
          (sym_eq_filter_nat_type_S
             (sttfa.arrow nat nat)
             minus_body
             q
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
              sttfa.forall
                nat
                (a:(sttfa.etap (sttfa.p nat)) =>
                 sttfa.impl (le (S q) (S p)) (le (y (S a)) (minus (S p) (S a)))))
             (sym_eq_minus_body_S
                q
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                 sttfa.forall
                   nat
                   (a:(sttfa.etap (sttfa.p nat)) =>
                    sttfa.impl (le (S q) (S p)) (le (y (S a)) (minus (S p) (S a)))))
                (a:(sttfa.etap (sttfa.p nat)) =>
                 sym_eq_match_nat_type_S
                   nat
                   (S q)
                   (z:(sttfa.etap (sttfa.p nat)) => minus q z)
                   a
                   (y:(sttfa.etap (sttfa.p nat)) =>
                    sttfa.impl (le (S q) (S p)) (le y (minus (S p) (S a))))
                   (sym_eq_minus
                      (S p)
                      (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                       sttfa.impl (le (S q) (S p)) (le (minus q a) (y (S a))))
                      (sym_eq_filter_nat_type_S
                         (sttfa.arrow nat nat)
                         minus_body
                         p
                         (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                          sttfa.impl (le (S q) (S p)) (le (minus q a) (y (S a))))
                         (sym_eq_minus_body_S
                            p
                            (y:(sttfa.etap (sttfa.p (sttfa.arrow nat nat))) =>
                             sttfa.impl (le (S q) (S p)) (le (minus q a) (y (S a))))
                            (sym_eq_match_nat_type_S
                               nat
                               (S p)
                               (q0:(sttfa.etap (sttfa.p nat)) => minus p q0)
                               a
                               (y:(sttfa.etap (sttfa.p nat)) =>
                                sttfa.impl (le (S q) (S p)) (le (minus q a) y))
                               (leSS:(sttfa.eps (le (S q) (S p))) =>
                                Hind
                                  a
                                  (logic.eq_coerc
                                     (le (pred (S q)) (pred (S p)))
                                     (le q p)
                                     (monotonic_pred (S q) (S p) leSS)
                                     (logic.rewrite_l
                                        nat
                                        q
                                        (__:(sttfa.etap (sttfa.p nat)) =>
                                         logic.eq
                                           sttfa.bool
                                           (le __ (pred (S p)))
                                           (le q p))
                                        (logic.rewrite_l
                                           nat
                                           p
                                           (__:(sttfa.etap (sttfa.p nat)) =>
                                            logic.eq sttfa.bool (le q __) (le q p))
                                           (logic.refl sttfa.bool (le q p))
                                           (pred (S p))
                                           (pred_Sn p))
                                        (pred (S q))
                                        (pred_Sn q))))))))))))
       n).

def le_plus_to_minus :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (p:(sttfa.etap (sttfa.p nat)) => sttfa.impl (le n (plus p m)) (le (minus n m) p)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  p:(sttfa.etap (sttfa.p nat)) =>
  lep:(sttfa.eps (le n (plus p m))) =>
  logic.eq_coerc
    (le (minus n m) (minus (plus p m) m))
    (le (minus n m) p)
    (monotonic_le_minus_l (plus p m) n m lep)
    (logic.rewrite_l
       nat
       p
       (__:(sttfa.etap (sttfa.p nat)) => logic.eq sttfa.bool (le (minus n m) __) (le (minus n m) p))
       (logic.refl sttfa.bool (le (minus n m) p))
       (minus (plus p m) m)
       (minus_plus_m_m p m)).

def monotonic_le_minus_r :
  sttfa.eps
    (sttfa.forall
       nat
       (p:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (q:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (n:(sttfa.etap (sttfa.p nat)) => sttfa.impl (le q p) (le (minus n p) (minus n q))))))
  :=
  p:(sttfa.etap (sttfa.p nat)) =>
  q:(sttfa.etap (sttfa.p nat)) =>
  n:(sttfa.etap (sttfa.p nat)) =>
  lepq:(sttfa.eps (le q p)) =>
  le_plus_to_minus
    n
    p
    (minus n q)
    (transitive_le
       n
       (plus (minus n q) q)
       (plus (minus n q) p)
       (le_plus_minus_m_m n q)
       (monotonic_le_plus_r (minus n q) q p lepq)).

def minus_le :
  sttfa.eps
    (sttfa.forall
       nat
       (x:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall nat (y:(sttfa.etap (sttfa.p nat)) => le (minus x y) x)))
  :=
  x:(sttfa.etap (sttfa.p nat)) =>
  y:(sttfa.etap (sttfa.p nat)) =>
  logic.eq_coerc
    (le (minus x y) (minus (plus x y) y))
    (le (minus x y) x)
    (monotonic_le_minus_l (plus x y) x y (le_plus_n_r y x))
    (logic.rewrite_l
       nat
       x
       (__:(sttfa.etap (sttfa.p nat)) => logic.eq sttfa.bool (le (minus x y) __) (le (minus x y) x))
       (logic.refl sttfa.bool (le (minus x y) x))
       (minus (plus x y) y)
       (minus_plus_m_m x y)).

def not_eq_to_le_to_lt :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.impl (connectives.Not (logic.eq nat n m)) (sttfa.impl (le n m) (lt n m)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  Hneq:(sttfa.eps (connectives.Not (logic.eq nat n m))) =>
  Hle:(sttfa.eps (le n m)) =>
  connectives.match_Or_prop
    (lt n m)
    (logic.eq nat n m)
    (lt n m)
    (auto:(sttfa.eps (lt n m)) => auto)
    (Heq:(sttfa.eps (logic.eq nat n m)) =>
     not_le_to_lt
       m
       n
       (logic.not_to_not
          (le m n)
          (logic.eq nat n m)
          (auto:(sttfa.eps (le m n)) =>
           logic.rewrite_l
             nat
             n
             (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat n __)
             (logic.refl nat n)
             m
             Heq)
          Hneq))
    (le_to_or_lt_eq n m Hle).

def eq_minus_O :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) => sttfa.impl (le n m) (logic.eq nat (minus n m) O))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  lenm:(sttfa.eps (le n m)) =>
  le_n_O_elim
    (minus n m)
    (logic.eq_coerc
       (le (minus n m) (minus n n))
       (le (minus n m) O)
       (monotonic_le_minus_r m n n lenm)
       (logic.rewrite_l
          nat
          O
          (__:(sttfa.etap (sttfa.p nat)) =>
           logic.eq sttfa.bool (le (minus n m) __) (le (minus n m) O))
          (logic.refl sttfa.bool (le (minus n m) O))
          (minus n n)
          (minus_n_n n)))
    (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat __ O)
    (logic.refl nat O).

def distributive_times_minus :
  sttfa.eps (relations.distributive nat times minus)
  :=
  a:(sttfa.etap (sttfa.p nat)) =>
  b:(sttfa.etap (sttfa.p nat)) =>
  c:(sttfa.etap (sttfa.p nat)) =>
  connectives.match_Or_prop
    (lt b c)
    (connectives.Not (lt b c))
    (logic.eq nat (times a (minus b c)) (minus (times a b) (times a c)))
    (Hbc:(sttfa.eps (lt b c)) =>
     logic.eq_ind_r
       nat
       O
       (x:(sttfa.etap (sttfa.p nat)) => logic.eq nat (times a x) (minus (times a b) (times a c)))
       (logic.eq_ind_r
          nat
          O
          (x:(sttfa.etap (sttfa.p nat)) => logic.eq nat (times a O) x)
          (logic.rewrite_l
             nat
             O
             (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat __ O)
             (logic.refl nat O)
             (times a O)
             (times_n_O a))
          (minus (times a b) (times a c))
          (eq_minus_O (times a b) (times a c) (monotonic_le_times_r a b c (lt_to_le b c Hbc))))
       (minus b c)
       (eq_minus_O b c (lt_to_le b c Hbc)))
    (Hbc:(sttfa.eps (connectives.Not (lt b c))) =>
     logic.sym_eq
       nat
       (minus (times a b) (times a c))
       (times a (minus b c))
       (logic.eq_coerc
          (logic.eq nat (minus (times a b) (times a c)) (times a (minus b c)))
          (logic.eq nat (minus (times a b) (times a c)) (times a (minus b c)))
          (plus_to_minus
             (times a b)
             (times a c)
             (times a (minus b c))
             (logic.eq_ind
                nat
                (times a (plus c (minus b c)))
                (x_1:(sttfa.etap (sttfa.p nat)) => logic.eq nat (times a b) x_1)
                (logic.eq_f
                   nat
                   nat
                   (times a)
                   b
                   (plus c (minus b c))
                   (logic.eq_coerc
                      (logic.eq nat b (plus (minus b c) c))
                      (logic.eq nat b (plus c (minus b c)))
                      (plus_minus_m_m b c (not_lt_to_le b c Hbc))
                      (logic.rewrite_r
                         nat
                         (plus c (minus b c))
                         (__:(sttfa.etap (sttfa.p nat)) =>
                          logic.eq
                            sttfa.bool
                            (logic.eq nat b __)
                            (logic.eq nat b (plus c (minus b c))))
                         (logic.refl sttfa.bool (logic.eq nat b (plus c (minus b c))))
                         (plus (minus b c) c)
                         (commutative_plus (minus b c) c))))
                (plus (times a c) (times a (minus b c)))
                (distributive_times_plus a c (minus b c))))
          (logic.refl
             sttfa.bool
             (logic.eq nat (minus (times a b) (times a c)) (times a (minus b c))))))
    (decidable_lt b c).

def minus_plus :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (p:(sttfa.etap (sttfa.p nat)) =>
              logic.eq nat (minus (minus n m) p) (minus n (plus m p))))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  p:(sttfa.etap (sttfa.p nat)) =>
  connectives.match_Or_prop
    (le (plus m p) n)
    (connectives.Not (le (plus m p) n))
    (logic.eq nat (minus (minus n m) p) (minus n (plus m p)))
    (Hlt:(sttfa.eps (le (plus m p) n)) =>
     plus_to_minus
       (minus n m)
       p
       (minus n (plus m p))
       (plus_to_minus
          n
          m
          (plus p (minus n (plus m p)))
          (logic.eq_ind
             nat
             (plus (plus m p) (minus n (plus m p)))
             (x_1:(sttfa.etap (sttfa.p nat)) => logic.eq nat n x_1)
             (minus_to_plus
                n
                (plus m p)
                (minus n (plus m p))
                Hlt
                (logic.refl nat (minus n (plus m p))))
             (plus m (plus p (minus n (plus m p))))
             (associative_plus m p (minus n (plus m p))))))
    (Hlt:(sttfa.eps (connectives.Not (le (plus m p) n))) =>
     logic.eq_ind_r
       nat
       O
       (x:(sttfa.etap (sttfa.p nat)) => logic.eq nat x (minus n (plus m p)))
       (logic.sym_eq
          nat
          (minus n (plus m p))
          O
          (logic.eq_coerc
             (logic.eq nat (minus n (plus m p)) O)
             (logic.eq nat (minus n (plus m p)) O)
             (eq_minus_O
                n
                (plus m p)
                (transitive_le n (S n) (plus m p) (le_n_Sn n) (not_le_to_lt (plus m p) n Hlt)))
             (logic.refl sttfa.bool (logic.eq nat (minus n (plus m p)) O))))
       (minus (minus n m) p)
       (eq_minus_O
          (minus n m)
          p
          (logic.eq_coerc
             (le (minus n m) (minus (plus p m) m))
             (le (minus n m) p)
             (monotonic_le_minus_l
                (plus p m)
                n
                m
                (logic.eq_coerc
                   (le n (plus m p))
                   (le n (plus p m))
                   (transitive_le n (S n) (plus m p) (le_n_Sn n) (not_le_to_lt (plus m p) n Hlt))
                   (logic.rewrite_r
                      nat
                      (plus m p)
                      (__:(sttfa.etap (sttfa.p nat)) =>
                       logic.eq sttfa.bool (le n (plus m p)) (le n __))
                      (logic.refl sttfa.bool (le n (plus m p)))
                      (plus p m)
                      (commutative_plus p m))))
             (logic.rewrite_l
                nat
                p
                (__:(sttfa.etap (sttfa.p nat)) =>
                 logic.eq sttfa.bool (le (minus n m) __) (le (minus n m) p))
                (logic.refl sttfa.bool (le (minus n m) p))
                (minus (plus p m) m)
                (minus_plus_m_m p m)))))
    (decidable_le (plus m p) n).

def minus_minus :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (p:(sttfa.etap (sttfa.p nat)) =>
              sttfa.impl
                (le p m)
                (sttfa.impl (le m n) (logic.eq nat (plus p (minus n m)) (minus n (minus m p))))))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  p:(sttfa.etap (sttfa.p nat)) =>
  lepm:(sttfa.eps (le p m)) =>
  lemn:(sttfa.eps (le m n)) =>
  logic.sym_eq
    nat
    (minus n (minus m p))
    (plus p (minus n m))
    (plus_to_minus
       n
       (minus m p)
       (plus p (minus n m))
       (logic.eq_ind
          nat
          (plus (plus (minus m p) p) (minus n m))
          (x_1:(sttfa.etap (sttfa.p nat)) => logic.eq nat n x_1)
          (logic.eq_ind
             nat
             m
             (x_1:(sttfa.etap (sttfa.p nat)) => logic.eq nat n (plus x_1 (minus n m)))
             (logic.eq_ind
                nat
                (plus (minus n m) m)
                (x_1:(sttfa.etap (sttfa.p nat)) => logic.eq nat n x_1)
                (logic.eq_ind
                   nat
                   n
                   (x_1:(sttfa.etap (sttfa.p nat)) => logic.eq nat n x_1)
                   (logic.refl nat n)
                   (plus (minus n m) m)
                   (plus_minus_m_m n m lemn))
                (plus m (minus n m))
                (commutative_plus (minus n m) m))
             (plus (minus m p) p)
             (plus_minus_m_m m p lepm))
          (plus (minus m p) (plus p (minus n m)))
          (associative_plus (minus m p) p (minus n m)))).

def minus_minus_comm :
  sttfa.eps
    (sttfa.forall
       nat
       (a:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (b:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (c:(sttfa.etap (sttfa.p nat)) =>
              logic.eq nat (minus (minus a b) c) (minus (minus a c) b)))))
  :=
  a:(sttfa.etap (sttfa.p nat)) =>
  b:(sttfa.etap (sttfa.p nat)) =>
  c:(sttfa.etap (sttfa.p nat)) =>
  le_to_le_to_eq
    (minus (minus a b) c)
    (minus (minus a c) b)
    (logic.eq_coerc
       (le (minus (minus a b) c) (minus (plus (minus (minus a c) b) c) c))
       (le (minus (minus a b) c) (minus (minus a c) b))
       (monotonic_le_minus_l
          (plus (minus (minus a c) b) c)
          (minus a b)
          c
          (logic.eq_coerc
             (le (minus a b) (plus (minus (minus a b) c) c))
             (le (minus a b) (plus (minus (minus a c) b) c))
             (le_plus_minus_m_m (minus a b) c)
             (logic.rewrite_r
                nat
                (minus a (plus b c))
                (__:(sttfa.etap (sttfa.p nat)) =>
                 logic.eq
                   sttfa.bool
                   (le (minus a b) (plus __ c))
                   (le (minus a b) (plus (minus (minus a c) b) c)))
                (logic.rewrite_r
                   nat
                   (plus c (minus a (plus b c)))
                   (__:(sttfa.etap (sttfa.p nat)) =>
                    logic.eq
                      sttfa.bool
                      (le (minus a b) __)
                      (le (minus a b) (plus (minus (minus a c) b) c)))
                   (logic.rewrite_r
                      nat
                      (plus c (minus (minus a c) b))
                      (__:(sttfa.etap (sttfa.p nat)) =>
                       logic.eq
                         sttfa.bool
                         (le (minus a b) (plus c (minus a (plus b c))))
                         (le (minus a b) __))
                      (logic.rewrite_l
                         nat
                         (minus (minus a c) b)
                         (__:(sttfa.etap (sttfa.p nat)) =>
                          logic.eq
                            sttfa.bool
                            (le (minus a b) (plus c __))
                            (le (minus a b) (plus c (minus (minus a c) b))))
                         (logic.refl
                            sttfa.bool
                            (le (minus a b) (plus c (minus (minus a c) b))))
                         (minus a (plus b c))
                         (logic.rewrite_l
                            nat
                            (plus c b)
                            (__:(sttfa.etap (sttfa.p nat)) =>
                             logic.eq nat (minus (minus a c) b) (minus a __))
                            (minus_plus a c b)
                            (plus b c)
                            (commutative_plus c b)))
                      (plus (minus (minus a c) b) c)
                      (commutative_plus (minus (minus a c) b) c))
                   (plus (minus a (plus b c)) c)
                   (commutative_plus (minus a (plus b c)) c))
                (minus (minus a b) c)
                (minus_plus a b c))))
       (logic.rewrite_l
          nat
          (minus (minus a c) b)
          (__:(sttfa.etap (sttfa.p nat)) =>
           logic.eq
             sttfa.bool
             (le (minus (minus a b) c) __)
             (le (minus (minus a b) c) (minus (minus a c) b)))
          (logic.refl sttfa.bool (le (minus (minus a b) c) (minus (minus a c) b)))
          (minus (plus (minus (minus a c) b) c) c)
          (minus_plus_m_m (minus (minus a c) b) c)))
    (logic.eq_coerc
       (le (minus (minus a c) b) (minus (plus (minus (minus a b) c) b) b))
       (le (minus (minus a c) b) (minus (minus a b) c))
       (monotonic_le_minus_l
          (plus (minus (minus a b) c) b)
          (minus a c)
          b
          (logic.eq_coerc
             (le (minus a c) (plus (minus (minus a c) b) b))
             (le (minus a c) (plus (minus (minus a b) c) b))
             (le_plus_minus_m_m (minus a c) b)
             (logic.rewrite_r
                nat
                (minus a (plus c b))
                (__:(sttfa.etap (sttfa.p nat)) =>
                 logic.eq
                   sttfa.bool
                   (le (minus a c) (plus __ b))
                   (le (minus a c) (plus (minus (minus a b) c) b)))
                (logic.rewrite_r
                   nat
                   (plus b (minus a (plus c b)))
                   (__:(sttfa.etap (sttfa.p nat)) =>
                    logic.eq
                      sttfa.bool
                      (le (minus a c) __)
                      (le (minus a c) (plus (minus (minus a b) c) b)))
                   (logic.rewrite_r
                      nat
                      (plus b (minus (minus a b) c))
                      (__:(sttfa.etap (sttfa.p nat)) =>
                       logic.eq
                         sttfa.bool
                         (le (minus a c) (plus b (minus a (plus c b))))
                         (le (minus a c) __))
                      (logic.rewrite_l
                         nat
                         (minus (minus a b) c)
                         (__:(sttfa.etap (sttfa.p nat)) =>
                          logic.eq
                            sttfa.bool
                            (le (minus a c) (plus b __))
                            (le (minus a c) (plus b (minus (minus a b) c))))
                         (logic.refl
                            sttfa.bool
                            (le (minus a c) (plus b (minus (minus a b) c))))
                         (minus a (plus c b))
                         (logic.rewrite_l
                            nat
                            (plus b c)
                            (__:(sttfa.etap (sttfa.p nat)) =>
                             logic.eq nat (minus (minus a b) c) (minus a __))
                            (minus_plus a b c)
                            (plus c b)
                            (commutative_plus b c)))
                      (plus (minus (minus a b) c) b)
                      (commutative_plus (minus (minus a b) c) b))
                   (plus (minus a (plus c b)) b)
                   (commutative_plus (minus a (plus c b)) b))
                (minus (minus a c) b)
                (minus_plus a c b))))
       (logic.rewrite_l
          nat
          (minus (minus a b) c)
          (__:(sttfa.etap (sttfa.p nat)) =>
           logic.eq
             sttfa.bool
             (le (minus (minus a c) b) __)
             (le (minus (minus a c) b) (minus (minus a b) c)))
          (logic.refl sttfa.bool (le (minus (minus a c) b) (minus (minus a b) c)))
          (minus (plus (minus (minus a b) c) b) b)
          (minus_plus_m_m (minus (minus a b) c) b))).

def minus_le_minus_minus_comm :
  sttfa.eps
    (sttfa.forall
       nat
       (b:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (c:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (a:(sttfa.etap (sttfa.p nat)) =>
              sttfa.impl (le c b) (logic.eq nat (minus a (minus b c)) (minus (plus a c) b))))))
  :=
  b:(sttfa.etap (sttfa.p nat)) =>
  c:(sttfa.etap (sttfa.p nat)) =>
  a:(sttfa.etap (sttfa.p nat)) =>
  H:(sttfa.eps (le c b)) =>
  logic.eq_ind_r
    nat
    (plus (minus b c) c)
    (x:(sttfa.etap (sttfa.p nat)) => logic.eq nat (minus a (minus b c)) (minus (plus a c) x))
    (logic.rewrite_r
       nat
       (plus c a)
       (__:(sttfa.etap (sttfa.p nat)) =>
        logic.eq nat (minus a (minus b c)) (minus __ (plus (minus b c) c)))
       (logic.rewrite_r
          nat
          (plus c (minus b c))
          (__:(sttfa.etap (sttfa.p nat)) =>
           logic.eq nat (minus a (minus b c)) (minus (plus c a) __))
          (logic.rewrite_l
             nat
             (minus (minus (plus c a) c) (minus b c))
             (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat (minus a (minus b c)) __)
             (logic.rewrite_r
                nat
                (minus (plus c a) c)
                (__:(sttfa.etap (sttfa.p nat)) =>
                 logic.eq nat (minus __ (minus b c)) (minus (minus (plus c a) c) (minus b c)))
                (logic.refl nat (minus (minus (plus c a) c) (minus b c)))
                a
                (logic.rewrite_l
                   nat
                   (plus a c)
                   (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat a (minus __ c))
                   (minus_plus_m_m a c)
                   (plus c a)
                   (commutative_plus a c)))
             (minus (plus c a) (plus c (minus b c)))
             (minus_plus (plus c a) c (minus b c)))
          (plus (minus b c) c)
          (commutative_plus (minus b c) c))
       (plus a c)
       (commutative_plus a c))
    b
    (plus_minus_m_m b c H).

def minus_plus_plus_l :
  sttfa.eps
    (sttfa.forall
       nat
       (x:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (y:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             nat
             (h:(sttfa.etap (sttfa.p nat)) =>
              logic.eq nat (minus (plus x h) (plus y h)) (minus x y)))))
  :=
  x:(sttfa.etap (sttfa.p nat)) =>
  y:(sttfa.etap (sttfa.p nat)) =>
  h:(sttfa.etap (sttfa.p nat)) =>
  logic.rewrite_l
    nat
    (minus (minus (plus x h) y) h)
    (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat __ (minus x y))
    (logic.rewrite_r
       nat
       (minus x y)
       (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat __ (minus x y))
       (logic.refl nat (minus x y))
       (minus (minus (plus x h) y) h)
       (logic.rewrite_r
          nat
          (minus (plus x h) h)
          (__:(sttfa.etap (sttfa.p nat)) =>
           logic.eq nat (minus (minus (plus x h) y) h) (minus __ y))
          (minus_minus_comm (plus x h) y h)
          x
          (minus_plus_m_m x h)))
    (minus (plus x h) (plus y h))
    (minus_plus (plus x h) y h).

eqb : sttfa.etap (sttfa.p (sttfa.arrow nat (sttfa.arrow nat bool.bool))).

eqb_body :
  sttfa.etap (sttfa.p (sttfa.arrow nat (sttfa.arrow nat bool.bool))).

axiom_eqb :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        connectives.equal
          (sttfa.arrow nat bool.bool)
          (eqb n)
          (filter_nat_type (sttfa.arrow nat bool.bool) eqb_body n))).

def eq_eqb :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)
          (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)) =>
           sttfa.impl (P (eqb n)) (P (filter_nat_type (sttfa.arrow nat bool.bool) eqb_body n)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  connectives.equal_leibniz
    (sttfa.arrow nat bool.bool)
    (eqb n)
    (filter_nat_type (sttfa.arrow nat bool.bool) eqb_body n)
    (axiom_eqb n).

def sym_eq_eqb :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)
          (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)) =>
           sttfa.impl (P (filter_nat_type (sttfa.arrow nat bool.bool) eqb_body n)) (P (eqb n)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  leibniz.sym_leibniz
    (sttfa.arrow nat bool.bool)
    (eqb n)
    (filter_nat_type (sttfa.arrow nat bool.bool) eqb_body n)
    (eq_eqb n).

axiom_eqb_body_O :
  sttfa.eps
    (connectives.equal
       (sttfa.arrow nat bool.bool)
       (eqb_body O)
       (m:(sttfa.etap (sttfa.p nat)) =>
        match_nat_type bool.bool bool.true (q:(sttfa.etap (sttfa.p nat)) => bool.false) m)).

def eq_eqb_body_O :
  sttfa.eps
    (sttfa.forall
       (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)
       (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)) =>
        sttfa.impl
          (P (eqb_body O))
          (P
             (m:(sttfa.etap (sttfa.p nat)) =>
              match_nat_type bool.bool bool.true (q:(sttfa.etap (sttfa.p nat)) => bool.false) m))))
  :=
  connectives.equal_leibniz
    (sttfa.arrow nat bool.bool)
    (eqb_body O)
    (m:(sttfa.etap (sttfa.p nat)) =>
     match_nat_type bool.bool bool.true (q:(sttfa.etap (sttfa.p nat)) => bool.false) m)
    axiom_eqb_body_O.

def sym_eq_eqb_body_O :
  sttfa.eps
    (sttfa.forall
       (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)
       (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)) =>
        sttfa.impl
          (P
             (m:(sttfa.etap (sttfa.p nat)) =>
              match_nat_type bool.bool bool.true (q:(sttfa.etap (sttfa.p nat)) => bool.false) m))
          (P (eqb_body O))))
  :=
  leibniz.sym_leibniz
    (sttfa.arrow nat bool.bool)
    (eqb_body O)
    (m:(sttfa.etap (sttfa.p nat)) =>
     match_nat_type bool.bool bool.true (q:(sttfa.etap (sttfa.p nat)) => bool.false) m)
    eq_eqb_body_O.

axiom_eqb_body_S :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        connectives.equal
          (sttfa.arrow nat bool.bool)
          (eqb_body (S n))
          (m:(sttfa.etap (sttfa.p nat)) =>
           match_nat_type bool.bool bool.false (q:(sttfa.etap (sttfa.p nat)) => eqb n q) m))).

def eq_eqb_body_S :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)
          (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)) =>
           sttfa.impl
             (P (eqb_body (S n)))
             (P
                (m:(sttfa.etap (sttfa.p nat)) =>
                 match_nat_type bool.bool bool.false (q:(sttfa.etap (sttfa.p nat)) => eqb n q) m)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  connectives.equal_leibniz
    (sttfa.arrow nat bool.bool)
    (eqb_body (S n))
    (m:(sttfa.etap (sttfa.p nat)) =>
     match_nat_type bool.bool bool.false (q:(sttfa.etap (sttfa.p nat)) => eqb n q) m)
    (axiom_eqb_body_S n).

def sym_eq_eqb_body_S :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)
          (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)) =>
           sttfa.impl
             (P
                (m:(sttfa.etap (sttfa.p nat)) =>
                 match_nat_type bool.bool bool.false (q:(sttfa.etap (sttfa.p nat)) => eqb n q) m))
             (P (eqb_body (S n))))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  leibniz.sym_leibniz
    (sttfa.arrow nat bool.bool)
    (eqb_body (S n))
    (m:(sttfa.etap (sttfa.p nat)) =>
     match_nat_type bool.bool bool.false (q:(sttfa.etap (sttfa.p nat)) => eqb n q) m)
    (eq_eqb_body_S n).

def eqb_elim :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             (sttfa.arrow bool.bool sttfa.bool)
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              sttfa.impl
                (sttfa.impl (logic.eq nat n m) (P bool.true))
                (sttfa.impl
                   (sttfa.impl (connectives.Not (logic.eq nat n m)) (P bool.false))
                   (P (eqb n m)))))))
  :=
  nat_elim2
    (__:(sttfa.etap (sttfa.p nat)) =>
     _0:(sttfa.etap (sttfa.p nat)) =>
     sttfa.forall
       (sttfa.arrow bool.bool sttfa.bool)
       (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
        sttfa.impl
          (sttfa.impl (logic.eq nat __ _0) (P bool.true))
          (sttfa.impl
             (sttfa.impl (connectives.Not (logic.eq nat __ _0)) (P bool.false))
             (P (eqb __ _0)))))
    (n:(sttfa.etap (sttfa.p nat)) =>
     match_nat_prop
       (__:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow bool.bool sttfa.bool)
          (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
           sttfa.impl
             (sttfa.impl (logic.eq nat O __) (P bool.true))
             (sttfa.impl
                (sttfa.impl (connectives.Not (logic.eq nat O __)) (P bool.false))
                (P (eqb O __)))))
       (sym_eq_eqb
          O
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
           sttfa.forall
             (sttfa.arrow bool.bool sttfa.bool)
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              sttfa.impl
                (sttfa.impl (logic.eq nat O O) (P bool.true))
                (sttfa.impl
                   (sttfa.impl (connectives.Not (logic.eq nat O O)) (P bool.false))
                   (P (y O)))))
          (sym_eq_filter_nat_type_O
             (sttfa.arrow nat bool.bool)
             eqb_body
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
              sttfa.forall
                (sttfa.arrow bool.bool sttfa.bool)
                (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 sttfa.impl
                   (sttfa.impl (logic.eq nat O O) (P bool.true))
                   (sttfa.impl
                      (sttfa.impl (connectives.Not (logic.eq nat O O)) (P bool.false))
                      (P (y O)))))
             (sym_eq_eqb_body_O
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
                 sttfa.forall
                   (sttfa.arrow bool.bool sttfa.bool)
                   (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                    sttfa.impl
                      (sttfa.impl (logic.eq nat O O) (P bool.true))
                      (sttfa.impl
                         (sttfa.impl (connectives.Not (logic.eq nat O O)) (P bool.false))
                         (P (y O)))))
                (sym_eq_match_nat_type_O
                   bool.bool
                   bool.true
                   (q:(sttfa.etap (sttfa.p nat)) => bool.false)
                   (y:(sttfa.etap (sttfa.p bool.bool)) =>
                    sttfa.forall
                      (sttfa.arrow bool.bool sttfa.bool)
                      (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                       sttfa.impl
                         (sttfa.impl (logic.eq nat O O) (P bool.true))
                         (sttfa.impl
                            (sttfa.impl (connectives.Not (logic.eq nat O O)) (P bool.false))
                            (P y))))
                   (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                    auto:(sttfa.eps (sttfa.impl (logic.eq nat O O) (P bool.true))) =>
                    auto':(sttfa.eps
                             (sttfa.impl (connectives.Not (logic.eq nat O O)) (P bool.false))) =>
                    auto (logic.refl nat O))))))
       (auto:(sttfa.etap (sttfa.p nat)) =>
        sym_eq_eqb
          O
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
           sttfa.forall
             (sttfa.arrow bool.bool sttfa.bool)
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              sttfa.impl
                (sttfa.impl (logic.eq nat O (S auto)) (P bool.true))
                (sttfa.impl
                   (sttfa.impl (connectives.Not (logic.eq nat O (S auto))) (P bool.false))
                   (P (y (S auto))))))
          (sym_eq_filter_nat_type_O
             (sttfa.arrow nat bool.bool)
             eqb_body
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
              sttfa.forall
                (sttfa.arrow bool.bool sttfa.bool)
                (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 sttfa.impl
                   (sttfa.impl (logic.eq nat O (S auto)) (P bool.true))
                   (sttfa.impl
                      (sttfa.impl (connectives.Not (logic.eq nat O (S auto))) (P bool.false))
                      (P (y (S auto))))))
             (sym_eq_eqb_body_O
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
                 sttfa.forall
                   (sttfa.arrow bool.bool sttfa.bool)
                   (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                    sttfa.impl
                      (sttfa.impl (logic.eq nat O (S auto)) (P bool.true))
                      (sttfa.impl
                         (sttfa.impl
                            (connectives.Not (logic.eq nat O (S auto)))
                            (P bool.false))
                         (P (y (S auto))))))
                (sym_eq_match_nat_type_S
                   bool.bool
                   bool.true
                   (q:(sttfa.etap (sttfa.p nat)) => bool.false)
                   auto
                   (y:(sttfa.etap (sttfa.p bool.bool)) =>
                    sttfa.forall
                      (sttfa.arrow bool.bool sttfa.bool)
                      (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                       sttfa.impl
                         (sttfa.impl (logic.eq nat O (S auto)) (P bool.true))
                         (sttfa.impl
                            (sttfa.impl
                               (connectives.Not (logic.eq nat O (S auto)))
                               (P bool.false))
                            (P y))))
                   (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                    auto':(sttfa.eps (sttfa.impl (logic.eq nat O (S auto)) (P bool.true))) =>
                    auto'':(sttfa.eps
                              (sttfa.impl
                                 (connectives.Not (logic.eq nat O (S auto)))
                                 (P bool.false))) =>
                    auto'' (not_eq_O_S auto))))))
       n)
    (n:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_eqb
       (S n)
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
        sttfa.forall
          (sttfa.arrow bool.bool sttfa.bool)
          (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
           sttfa.impl
             (sttfa.impl (logic.eq nat (S n) O) (P bool.true))
             (sttfa.impl
                (sttfa.impl (connectives.Not (logic.eq nat (S n) O)) (P bool.false))
                (P (y O)))))
       (sym_eq_filter_nat_type_S
          (sttfa.arrow nat bool.bool)
          eqb_body
          n
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
           sttfa.forall
             (sttfa.arrow bool.bool sttfa.bool)
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              sttfa.impl
                (sttfa.impl (logic.eq nat (S n) O) (P bool.true))
                (sttfa.impl
                   (sttfa.impl (connectives.Not (logic.eq nat (S n) O)) (P bool.false))
                   (P (y O)))))
          (sym_eq_eqb_body_S
             n
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
              sttfa.forall
                (sttfa.arrow bool.bool sttfa.bool)
                (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 sttfa.impl
                   (sttfa.impl (logic.eq nat (S n) O) (P bool.true))
                   (sttfa.impl
                      (sttfa.impl (connectives.Not (logic.eq nat (S n) O)) (P bool.false))
                      (P (y O)))))
             (sym_eq_match_nat_type_O
                bool.bool
                bool.false
                (q:(sttfa.etap (sttfa.p nat)) => eqb n q)
                (y:(sttfa.etap (sttfa.p bool.bool)) =>
                 sttfa.forall
                   (sttfa.arrow bool.bool sttfa.bool)
                   (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                    sttfa.impl
                      (sttfa.impl (logic.eq nat (S n) O) (P bool.true))
                      (sttfa.impl
                         (sttfa.impl (connectives.Not (logic.eq nat (S n) O)) (P bool.false))
                         (P y))))
                (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 auto:(sttfa.eps (sttfa.impl (logic.eq nat (S n) O) (P bool.true))) =>
                 auto':(sttfa.eps
                          (sttfa.impl (connectives.Not (logic.eq nat (S n) O)) (P bool.false))) =>
                 auto' (logic.sym_not_eq nat O (S n) (not_eq_O_S n)))))))
    (n:(sttfa.etap (sttfa.p nat)) =>
     m:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_eqb
       (S n)
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
        sttfa.impl
          (sttfa.forall
             (sttfa.arrow bool.bool sttfa.bool)
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              sttfa.impl
                (sttfa.impl (logic.eq nat n m) (P bool.true))
                (sttfa.impl
                   (sttfa.impl (connectives.Not (logic.eq nat n m)) (P bool.false))
                   (P (eqb n m)))))
          (sttfa.forall
             (sttfa.arrow bool.bool sttfa.bool)
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              sttfa.impl
                (sttfa.impl (logic.eq nat (S n) (S m)) (P bool.true))
                (sttfa.impl
                   (sttfa.impl (connectives.Not (logic.eq nat (S n) (S m))) (P bool.false))
                   (P (y (S m)))))))
       (sym_eq_filter_nat_type_S
          (sttfa.arrow nat bool.bool)
          eqb_body
          n
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
           sttfa.impl
             (sttfa.forall
                (sttfa.arrow bool.bool sttfa.bool)
                (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 sttfa.impl
                   (sttfa.impl (logic.eq nat n m) (P bool.true))
                   (sttfa.impl
                      (sttfa.impl (connectives.Not (logic.eq nat n m)) (P bool.false))
                      (P (eqb n m)))))
             (sttfa.forall
                (sttfa.arrow bool.bool sttfa.bool)
                (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 sttfa.impl
                   (sttfa.impl (logic.eq nat (S n) (S m)) (P bool.true))
                   (sttfa.impl
                      (sttfa.impl (connectives.Not (logic.eq nat (S n) (S m))) (P bool.false))
                      (P (y (S m)))))))
          (sym_eq_eqb_body_S
             n
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
              sttfa.impl
                (sttfa.forall
                   (sttfa.arrow bool.bool sttfa.bool)
                   (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                    sttfa.impl
                      (sttfa.impl (logic.eq nat n m) (P bool.true))
                      (sttfa.impl
                         (sttfa.impl (connectives.Not (logic.eq nat n m)) (P bool.false))
                         (P (eqb n m)))))
                (sttfa.forall
                   (sttfa.arrow bool.bool sttfa.bool)
                   (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                    sttfa.impl
                      (sttfa.impl (logic.eq nat (S n) (S m)) (P bool.true))
                      (sttfa.impl
                         (sttfa.impl
                            (connectives.Not (logic.eq nat (S n) (S m)))
                            (P bool.false))
                         (P (y (S m)))))))
             (sym_eq_match_nat_type_S
                bool.bool
                bool.false
                (q:(sttfa.etap (sttfa.p nat)) => eqb n q)
                m
                (y:(sttfa.etap (sttfa.p bool.bool)) =>
                 sttfa.impl
                   (sttfa.forall
                      (sttfa.arrow bool.bool sttfa.bool)
                      (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                       sttfa.impl
                         (sttfa.impl (logic.eq nat n m) (P bool.true))
                         (sttfa.impl
                            (sttfa.impl (connectives.Not (logic.eq nat n m)) (P bool.false))
                            (P (eqb n m)))))
                   (sttfa.forall
                      (sttfa.arrow bool.bool sttfa.bool)
                      (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                       sttfa.impl
                         (sttfa.impl (logic.eq nat (S n) (S m)) (P bool.true))
                         (sttfa.impl
                            (sttfa.impl
                               (connectives.Not (logic.eq nat (S n) (S m)))
                               (P bool.false))
                            (P y)))))
                (auto:(sttfa.eps
                         (sttfa.forall
                            (sttfa.arrow bool.bool sttfa.bool)
                            (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                             sttfa.impl
                               (sttfa.impl (logic.eq nat n m) (P bool.true))
                               (sttfa.impl
                                  (sttfa.impl
                                     (connectives.Not (logic.eq nat n m))
                                     (P bool.false))
                                  (P (eqb n m)))))) =>
                 P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 auto':(sttfa.eps (sttfa.impl (logic.eq nat (S n) (S m)) (P bool.true))) =>
                 auto'':(sttfa.eps
                           (sttfa.impl
                              (connectives.Not (logic.eq nat (S n) (S m)))
                              (P bool.false))) =>
                 auto
                   P
                   (auto''':(sttfa.eps (logic.eq nat n m)) =>
                    auto'
                      (logic.rewrite_l
                         nat
                         n
                         (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat (S n) (S __))
                         (logic.refl nat (S n))
                         m
                         auto'''))
                   (auto''':(sttfa.eps (connectives.Not (logic.eq nat n m))) =>
                    auto'' (not_eq_S n m auto'''))))))).

def eqb_n_n :
  sttfa.eps
    (sttfa.forall nat (n:(sttfa.etap (sttfa.p nat)) => logic.eq bool.bool (eqb n n) bool.true))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat)) => logic.eq bool.bool (eqb _x_365 _x_365) bool.true)
    (sym_eq_eqb
       O
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) => logic.eq bool.bool (y O) bool.true)
       (sym_eq_filter_nat_type_O
          (sttfa.arrow nat bool.bool)
          eqb_body
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
           logic.eq bool.bool (y O) bool.true)
          (sym_eq_eqb_body_O
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
              logic.eq bool.bool (y O) bool.true)
             (sym_eq_match_nat_type_O
                bool.bool
                bool.true
                (q:(sttfa.etap (sttfa.p nat)) => bool.false)
                (y:(sttfa.etap (sttfa.p bool.bool)) => logic.eq bool.bool y bool.true)
                (logic.refl bool.bool bool.true)))))
    (x_366:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_eqb
       (S x_366)
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
        sttfa.impl
          (logic.eq bool.bool (eqb x_366 x_366) bool.true)
          (logic.eq bool.bool (y (S x_366)) bool.true))
       (sym_eq_filter_nat_type_S
          (sttfa.arrow nat bool.bool)
          eqb_body
          x_366
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
           sttfa.impl
             (logic.eq bool.bool (eqb x_366 x_366) bool.true)
             (logic.eq bool.bool (y (S x_366)) bool.true))
          (sym_eq_eqb_body_S
             x_366
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
              sttfa.impl
                (logic.eq bool.bool (eqb x_366 x_366) bool.true)
                (logic.eq bool.bool (y (S x_366)) bool.true))
             (sym_eq_match_nat_type_S
                bool.bool
                bool.false
                (q:(sttfa.etap (sttfa.p nat)) => eqb x_366 q)
                x_366
                (y:(sttfa.etap (sttfa.p bool.bool)) =>
                 sttfa.impl
                   (logic.eq bool.bool (eqb x_366 x_366) bool.true)
                   (logic.eq bool.bool y bool.true))
                (_x_368:(sttfa.eps (logic.eq bool.bool (eqb x_366 x_366) bool.true)) =>
                 logic.rewrite_r
                   bool.bool
                   bool.true
                   (__:(sttfa.etap (sttfa.p bool.bool)) => logic.eq bool.bool __ bool.true)
                   (logic.refl bool.bool bool.true)
                   (eqb x_366 x_366)
                   _x_368)))))
    n.

def eqb_true_to_eq :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.impl (logic.eq bool.bool (eqb n m) bool.true) (logic.eq nat n m))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  eqb_elim
    n
    m
    (__:(sttfa.etap (sttfa.p bool.bool)) =>
     sttfa.impl (logic.eq bool.bool __ bool.true) (logic.eq nat n m))
    (auto:(sttfa.eps (logic.eq nat n m)) =>
     auto':(sttfa.eps (logic.eq bool.bool bool.true bool.true)) =>
     logic.rewrite_l
       nat
       n
       (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat n __)
       (logic.refl nat n)
       m
       auto)
    (__:(sttfa.eps (connectives.Not (logic.eq nat n m))) =>
     abs:(sttfa.eps (logic.eq bool.bool bool.false bool.true)) =>
     connectives.falsity
       (logic.eq nat n m)
       (logic.absurd
          (logic.eq bool.bool bool.true bool.false)
          (logic.rewrite_r
             bool.bool
             bool.true
             (__1:(sttfa.etap (sttfa.p bool.bool)) => logic.eq bool.bool bool.true __1)
             (logic.refl bool.bool bool.true)
             bool.false
             abs)
          bool.not_eq_true_false)).

def eqb_false_to_not_eq :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.impl
             (logic.eq bool.bool (eqb n m) bool.false)
             (connectives.Not (logic.eq nat n m)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  eqb_elim
    n
    m
    (__:(sttfa.etap (sttfa.p bool.bool)) =>
     sttfa.impl (logic.eq bool.bool __ bool.false) (connectives.Not (logic.eq nat n m)))
    (auto:(sttfa.eps (logic.eq nat n m)) =>
     auto':(sttfa.eps (logic.eq bool.bool bool.true bool.false)) =>
     logic.not_to_not
       (logic.eq nat n m)
       (logic.eq bool.bool bool.true bool.false)
       (auto'':(sttfa.eps (logic.eq nat n m)) =>
        logic.rewrite_l
          bool.bool
          bool.true
          (__:(sttfa.etap (sttfa.p bool.bool)) => logic.eq bool.bool bool.true __)
          (logic.refl bool.bool bool.true)
          bool.false
          auto')
       bool.not_eq_true_false)
    (auto:(sttfa.eps (connectives.Not (logic.eq nat n m))) =>
     auto':(sttfa.eps (logic.eq bool.bool bool.false bool.false)) => auto).

def eq_to_eqb_true :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.impl (logic.eq nat n m) (logic.eq bool.bool (eqb n m) bool.true))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  auto:(sttfa.eps (logic.eq nat n m)) =>
  logic.rewrite_l
    nat
    n
    (__:(sttfa.etap (sttfa.p nat)) => logic.eq bool.bool (eqb n __) bool.true)
    (logic.rewrite_r
       bool.bool
       bool.true
       (__:(sttfa.etap (sttfa.p bool.bool)) => logic.eq bool.bool __ bool.true)
       (logic.refl bool.bool bool.true)
       (eqb n n)
       (eqb_n_n n))
    m
    auto.

def not_eq_to_eqb_false :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.impl
             (connectives.Not (logic.eq nat n m))
             (logic.eq bool.bool (eqb n m) bool.false))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  noteq:(sttfa.eps (connectives.Not (logic.eq nat n m))) =>
  eqb_elim
    n
    m
    (__:(sttfa.etap (sttfa.p bool.bool)) => logic.eq bool.bool __ bool.false)
    (Heq:(sttfa.eps (logic.eq nat n m)) =>
     connectives.falsity
       (logic.eq bool.bool bool.true bool.false)
       (logic.absurd
          (logic.eq nat n m)
          (logic.rewrite_l
             nat
             n
             (__:(sttfa.etap (sttfa.p nat)) => logic.eq nat n __)
             (logic.refl nat n)
             m
             Heq)
          noteq))
    (auto:(sttfa.eps (connectives.Not (logic.eq nat n m))) => logic.refl bool.bool bool.false).

leb : sttfa.etap (sttfa.p (sttfa.arrow nat (sttfa.arrow nat bool.bool))).

leb_body :
  sttfa.etap (sttfa.p (sttfa.arrow nat (sttfa.arrow nat bool.bool))).

axiom_leb :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        connectives.equal
          (sttfa.arrow nat bool.bool)
          (leb n)
          (filter_nat_type (sttfa.arrow nat bool.bool) leb_body n))).

def eq_leb :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)
          (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)) =>
           sttfa.impl (P (leb n)) (P (filter_nat_type (sttfa.arrow nat bool.bool) leb_body n)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  connectives.equal_leibniz
    (sttfa.arrow nat bool.bool)
    (leb n)
    (filter_nat_type (sttfa.arrow nat bool.bool) leb_body n)
    (axiom_leb n).

def sym_eq_leb :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)
          (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)) =>
           sttfa.impl (P (filter_nat_type (sttfa.arrow nat bool.bool) leb_body n)) (P (leb n)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  leibniz.sym_leibniz
    (sttfa.arrow nat bool.bool)
    (leb n)
    (filter_nat_type (sttfa.arrow nat bool.bool) leb_body n)
    (eq_leb n).

axiom_leb_body_O :
  sttfa.eps
    (connectives.equal
       (sttfa.arrow nat bool.bool)
       (leb_body O)
       (m:(sttfa.etap (sttfa.p nat)) => bool.true)).

def eq_leb_body_O :
  sttfa.eps
    (sttfa.forall
       (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)
       (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)) =>
        sttfa.impl (P (leb_body O)) (P (m:(sttfa.etap (sttfa.p nat)) => bool.true))))
  :=
  connectives.equal_leibniz
    (sttfa.arrow nat bool.bool)
    (leb_body O)
    (m:(sttfa.etap (sttfa.p nat)) => bool.true)
    axiom_leb_body_O.

def sym_eq_leb_body_O :
  sttfa.eps
    (sttfa.forall
       (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)
       (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)) =>
        sttfa.impl (P (m:(sttfa.etap (sttfa.p nat)) => bool.true)) (P (leb_body O))))
  :=
  leibniz.sym_leibniz
    (sttfa.arrow nat bool.bool)
    (leb_body O)
    (m:(sttfa.etap (sttfa.p nat)) => bool.true)
    eq_leb_body_O.

axiom_leb_body_S :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        connectives.equal
          (sttfa.arrow nat bool.bool)
          (leb_body (S n))
          (m:(sttfa.etap (sttfa.p nat)) =>
           match_nat_type bool.bool bool.false (q:(sttfa.etap (sttfa.p nat)) => leb n q) m))).

def eq_leb_body_S :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)
          (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)) =>
           sttfa.impl
             (P (leb_body (S n)))
             (P
                (m:(sttfa.etap (sttfa.p nat)) =>
                 match_nat_type bool.bool bool.false (q:(sttfa.etap (sttfa.p nat)) => leb n q) m)))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  connectives.equal_leibniz
    (sttfa.arrow nat bool.bool)
    (leb_body (S n))
    (m:(sttfa.etap (sttfa.p nat)) =>
     match_nat_type bool.bool bool.false (q:(sttfa.etap (sttfa.p nat)) => leb n q) m)
    (axiom_leb_body_S n).

def sym_eq_leb_body_S :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)
          (P:(sttfa.eta (sttfa.arrow (sttfa.arrow nat bool.bool) sttfa.bool)) =>
           sttfa.impl
             (P
                (m:(sttfa.etap (sttfa.p nat)) =>
                 match_nat_type bool.bool bool.false (q:(sttfa.etap (sttfa.p nat)) => leb n q) m))
             (P (leb_body (S n))))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  leibniz.sym_leibniz
    (sttfa.arrow nat bool.bool)
    (leb_body (S n))
    (m:(sttfa.etap (sttfa.p nat)) =>
     match_nat_type bool.bool bool.false (q:(sttfa.etap (sttfa.p nat)) => leb n q) m)
    (eq_leb_body_S n).

def leb_elim :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.forall
             (sttfa.arrow bool.bool sttfa.bool)
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              sttfa.impl
                (sttfa.impl (le n m) (P bool.true))
                (sttfa.impl (sttfa.impl (connectives.Not (le n m)) (P bool.false)) (P (leb n m)))))))
  :=
  nat_elim2
    (__:(sttfa.etap (sttfa.p nat)) =>
     _0:(sttfa.etap (sttfa.p nat)) =>
     sttfa.forall
       (sttfa.arrow bool.bool sttfa.bool)
       (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
        sttfa.impl
          (sttfa.impl (le __ _0) (P bool.true))
          (sttfa.impl (sttfa.impl (connectives.Not (le __ _0)) (P bool.false)) (P (leb __ _0)))))
    (n:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_leb
       O
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
        sttfa.forall
          (sttfa.arrow bool.bool sttfa.bool)
          (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
           sttfa.impl
             (sttfa.impl (le O n) (P bool.true))
             (sttfa.impl (sttfa.impl (connectives.Not (le O n)) (P bool.false)) (P (y n)))))
       (sym_eq_filter_nat_type_O
          (sttfa.arrow nat bool.bool)
          leb_body
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
           sttfa.forall
             (sttfa.arrow bool.bool sttfa.bool)
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              sttfa.impl
                (sttfa.impl (le O n) (P bool.true))
                (sttfa.impl (sttfa.impl (connectives.Not (le O n)) (P bool.false)) (P (y n)))))
          (sym_eq_leb_body_O
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
              sttfa.forall
                (sttfa.arrow bool.bool sttfa.bool)
                (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 sttfa.impl
                   (sttfa.impl (le O n) (P bool.true))
                   (sttfa.impl (sttfa.impl (connectives.Not (le O n)) (P bool.false)) (P (y n)))))
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              auto:(sttfa.eps (sttfa.impl (le O n) (P bool.true))) =>
              auto':(sttfa.eps (sttfa.impl (connectives.Not (le O n)) (P bool.false))) =>
              auto (le_O_n n)))))
    (n:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_leb
       (S n)
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
        sttfa.forall
          (sttfa.arrow bool.bool sttfa.bool)
          (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
           sttfa.impl
             (sttfa.impl (le (S n) O) (P bool.true))
             (sttfa.impl (sttfa.impl (connectives.Not (le (S n) O)) (P bool.false)) (P (y O)))))
       (sym_eq_filter_nat_type_S
          (sttfa.arrow nat bool.bool)
          leb_body
          n
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
           sttfa.forall
             (sttfa.arrow bool.bool sttfa.bool)
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              sttfa.impl
                (sttfa.impl (le (S n) O) (P bool.true))
                (sttfa.impl (sttfa.impl (connectives.Not (le (S n) O)) (P bool.false)) (P (y O)))))
          (sym_eq_leb_body_S
             n
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
              sttfa.forall
                (sttfa.arrow bool.bool sttfa.bool)
                (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 sttfa.impl
                   (sttfa.impl (le (S n) O) (P bool.true))
                   (sttfa.impl
                      (sttfa.impl (connectives.Not (le (S n) O)) (P bool.false))
                      (P (y O)))))
             (sym_eq_match_nat_type_O
                bool.bool
                bool.false
                (q:(sttfa.etap (sttfa.p nat)) => leb n q)
                (y:(sttfa.etap (sttfa.p bool.bool)) =>
                 sttfa.forall
                   (sttfa.arrow bool.bool sttfa.bool)
                   (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                    sttfa.impl
                      (sttfa.impl (le (S n) O) (P bool.true))
                      (sttfa.impl
                         (sttfa.impl (connectives.Not (le (S n) O)) (P bool.false))
                         (P y))))
                (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 auto:(sttfa.eps (sttfa.impl (le (S n) O) (P bool.true))) =>
                 auto':(sttfa.eps (sttfa.impl (connectives.Not (le (S n) O)) (P bool.false))) =>
                 auto' (not_le_Sn_O n))))))
    (n:(sttfa.etap (sttfa.p nat)) =>
     m:(sttfa.etap (sttfa.p nat)) =>
     sym_eq_leb
       (S n)
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
        sttfa.impl
          (sttfa.forall
             (sttfa.arrow bool.bool sttfa.bool)
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              sttfa.impl
                (sttfa.impl (le n m) (P bool.true))
                (sttfa.impl (sttfa.impl (connectives.Not (le n m)) (P bool.false)) (P (leb n m)))))
          (sttfa.forall
             (sttfa.arrow bool.bool sttfa.bool)
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              sttfa.impl
                (sttfa.impl (le (S n) (S m)) (P bool.true))
                (sttfa.impl
                   (sttfa.impl (connectives.Not (le (S n) (S m))) (P bool.false))
                   (P (y (S m)))))))
       (sym_eq_filter_nat_type_S
          (sttfa.arrow nat bool.bool)
          leb_body
          n
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
           sttfa.impl
             (sttfa.forall
                (sttfa.arrow bool.bool sttfa.bool)
                (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 sttfa.impl
                   (sttfa.impl (le n m) (P bool.true))
                   (sttfa.impl
                      (sttfa.impl (connectives.Not (le n m)) (P bool.false))
                      (P (leb n m)))))
             (sttfa.forall
                (sttfa.arrow bool.bool sttfa.bool)
                (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 sttfa.impl
                   (sttfa.impl (le (S n) (S m)) (P bool.true))
                   (sttfa.impl
                      (sttfa.impl (connectives.Not (le (S n) (S m))) (P bool.false))
                      (P (y (S m)))))))
          (sym_eq_leb_body_S
             n
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat bool.bool))) =>
              sttfa.impl
                (sttfa.forall
                   (sttfa.arrow bool.bool sttfa.bool)
                   (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                    sttfa.impl
                      (sttfa.impl (le n m) (P bool.true))
                      (sttfa.impl
                         (sttfa.impl (connectives.Not (le n m)) (P bool.false))
                         (P (leb n m)))))
                (sttfa.forall
                   (sttfa.arrow bool.bool sttfa.bool)
                   (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                    sttfa.impl
                      (sttfa.impl (le (S n) (S m)) (P bool.true))
                      (sttfa.impl
                         (sttfa.impl (connectives.Not (le (S n) (S m))) (P bool.false))
                         (P (y (S m)))))))
             (sym_eq_match_nat_type_S
                bool.bool
                bool.false
                (q:(sttfa.etap (sttfa.p nat)) => leb n q)
                m
                (y:(sttfa.etap (sttfa.p bool.bool)) =>
                 sttfa.impl
                   (sttfa.forall
                      (sttfa.arrow bool.bool sttfa.bool)
                      (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                       sttfa.impl
                         (sttfa.impl (le n m) (P bool.true))
                         (sttfa.impl
                            (sttfa.impl (connectives.Not (le n m)) (P bool.false))
                            (P (leb n m)))))
                   (sttfa.forall
                      (sttfa.arrow bool.bool sttfa.bool)
                      (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                       sttfa.impl
                         (sttfa.impl (le (S n) (S m)) (P bool.true))
                         (sttfa.impl
                            (sttfa.impl (connectives.Not (le (S n) (S m))) (P bool.false))
                            (P y)))))
                (Hind:(sttfa.eps
                         (sttfa.forall
                            (sttfa.arrow bool.bool sttfa.bool)
                            (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                             sttfa.impl
                               (sttfa.impl (le n m) (P bool.true))
                               (sttfa.impl
                                  (sttfa.impl (connectives.Not (le n m)) (P bool.false))
                                  (P (leb n m)))))) =>
                 P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 Pt:(sttfa.eps (sttfa.impl (le (S n) (S m)) (P bool.true))) =>
                 Pf:(sttfa.eps (sttfa.impl (connectives.Not (le (S n) (S m))) (P bool.false))) =>
                 Hind
                   P
                   (lenm:(sttfa.eps (le n m)) => Pt (le_S_S n m lenm))
                   (nlenm:(sttfa.eps (connectives.Not (le n m))) =>
                    Pf (not_le_to_not_le_S_S n m nlenm))))))).

def leb_true_to_le :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.impl (logic.eq bool.bool (leb n m) bool.true) (le n m))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  leb_elim
    n
    m
    (__:(sttfa.etap (sttfa.p bool.bool)) => sttfa.impl (logic.eq bool.bool __ bool.true) (le n m))
    (auto:(sttfa.eps (le n m)) => auto':(sttfa.eps (logic.eq bool.bool bool.true bool.true)) => auto)
    (__:(sttfa.eps (connectives.Not (le n m))) =>
     abs:(sttfa.eps (logic.eq bool.bool bool.false bool.true)) =>
     connectives.falsity
       (le n m)
       (logic.absurd
          (logic.eq bool.bool bool.true bool.false)
          (logic.rewrite_r
             bool.bool
             bool.true
             (__1:(sttfa.etap (sttfa.p bool.bool)) => logic.eq bool.bool bool.true __1)
             (logic.refl bool.bool bool.true)
             bool.false
             abs)
          bool.not_eq_true_false)).

def le_to_leb_true :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.impl (le n m) (logic.eq bool.bool (leb n m) bool.true))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  leb_elim
    n
    m
    (__:(sttfa.etap (sttfa.p bool.bool)) => sttfa.impl (le n m) (logic.eq bool.bool __ bool.true))
    (auto:(sttfa.eps (le n m)) => auto':(sttfa.eps (le n m)) => logic.refl bool.bool bool.true)
    (H:(sttfa.eps (connectives.Not (le n m))) =>
     H1:(sttfa.eps (le n m)) =>
     connectives.falsity (logic.eq bool.bool bool.false bool.true) (logic.absurd (le n m) H1 H)).

def not_le_to_leb_false :
  sttfa.eps
    (sttfa.forall
       nat
       (n:(sttfa.etap (sttfa.p nat)) =>
        sttfa.forall
          nat
          (m:(sttfa.etap (sttfa.p nat)) =>
           sttfa.impl (connectives.Not (le n m)) (logic.eq bool.bool (leb n m) bool.false))))
  :=
  n:(sttfa.etap (sttfa.p nat)) =>
  m:(sttfa.etap (sttfa.p nat)) =>
  leb_elim
    n
    m
    (__:(sttfa.etap (sttfa.p bool.bool)) =>
     sttfa.impl (connectives.Not (le n m)) (logic.eq bool.bool __ bool.false))
    (H:(sttfa.eps (le n m)) =>
     H1:(sttfa.eps (connectives.Not (le n m))) =>
     connectives.falsity (logic.eq bool.bool bool.true bool.false) (logic.absurd (le n m) H H1))
    (auto:(sttfa.eps (connectives.Not (le n m))) =>
     auto':(sttfa.eps (connectives.Not (le n m))) => logic.refl bool.bool bool.false).

