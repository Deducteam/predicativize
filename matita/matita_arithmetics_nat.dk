nat : pts.U pts.var.

O : pts.El pts.var nat.

S : __:(pts.El pts.var nat) -> pts.El pts.var nat.

def match_nat :
  return_sort:pts.Lvl ->
  return_type:(z:(pts.El pts.var nat) -> pts.U return_sort) ->
  case_O:(pts.El return_sort (return_type O)) ->
  case_S:(__:(pts.El pts.var nat) -> pts.El return_sort (return_type (S __))) ->
  z:(pts.El pts.var nat) -> pts.El return_sort (return_type z).

[case_S, case_O, return_type, return_sort]
  match_nat return_sort return_type case_O case_S (O) --> case_O.

[__, case_S, case_O, return_type, return_sort]
  match_nat return_sort return_type case_O case_S (S __) --> case_S __.

def filter_nat :
  return_sort:pts.Lvl ->
  return_type:(z:(pts.El pts.var nat) -> pts.U return_sort) ->
  return:(z:(pts.El pts.var nat) -> pts.El return_sort (return_type z)) ->
  z:(pts.El pts.var nat) -> pts.El return_sort (return_type z).

[return, return_type, return_sort]
  filter_nat return_sort return_type return (O) --> return O.

[__, return, return_type, return_sort]
  filter_nat return_sort return_type return (S __) --> return (S __).

def nat_ind :
  Q_:(_x_365:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H_O:(pts.El pts.var (Q_ O)) ->
  _H_S:(x_366:(pts.El pts.var nat) -> _x_368:(pts.El pts.var (Q_ x_366)) -> pts.El pts.var (Q_ (S x_366))) ->
  x_365:(pts.El pts.var nat) -> pts.El pts.var (Q_ x_365).

def nat_ind_body :
  Q_:(_x_365:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H_O:(pts.El pts.var (Q_ O)) ->
  _H_S:(x_366:(pts.El pts.var nat) -> _x_368:(pts.El pts.var (Q_ x_366)) -> pts.El pts.var (Q_ (S x_366))) ->
  x_365:(pts.El pts.var nat) -> pts.El pts.var (Q_ x_365).

[x_365, _H_S, _H_O, Q_]
  nat_ind Q_ _H_O _H_S x_365
  -->
  filter_nat pts.var (x_365:(pts.El pts.var nat) => Q_ x_365) (nat_ind_body Q_ _H_O _H_S) x_365.

[x_365, _H_S, _H_O, Q_]
  nat_ind_body Q_ _H_O _H_S x_365
  -->
  match_nat
    pts.var
    Q_
    _H_O
    (x_366:(pts.El pts.var nat) => _H_S x_366 (nat_ind Q_ _H_O _H_S x_366))
    x_365.

def nat_rect_Type4 :
  Q_:(_x_369:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H_O:(pts.El pts.var (Q_ O)) ->
  _H_S:(x_370:(pts.El pts.var nat) -> _x_372:(pts.El pts.var (Q_ x_370)) -> pts.El pts.var (Q_ (S x_370))) ->
  x_369:(pts.El pts.var nat) -> pts.El pts.var (Q_ x_369).

def nat_rect_Type4_body :
  Q_:(_x_369:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H_O:(pts.El pts.var (Q_ O)) ->
  _H_S:(x_370:(pts.El pts.var nat) -> _x_372:(pts.El pts.var (Q_ x_370)) -> pts.El pts.var (Q_ (S x_370))) ->
  x_369:(pts.El pts.var nat) -> pts.El pts.var (Q_ x_369).

[x_369, _H_S, _H_O, Q_]
  nat_rect_Type4 Q_ _H_O _H_S x_369
  -->
  filter_nat pts.var (x_369:(pts.El pts.var nat) => Q_ x_369) (nat_rect_Type4_body Q_ _H_O _H_S) x_369.

[x_369, _H_S, _H_O, Q_]
  nat_rect_Type4_body Q_ _H_O _H_S x_369
  -->
  match_nat
    pts.var
    Q_
    _H_O
    (x_370:(pts.El pts.var nat) => _H_S x_370 (nat_rect_Type4 Q_ _H_O _H_S x_370))
    x_369.

def nat_rect_Type3 :
  Q_:(_x_377:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H_O:(pts.El pts.var (Q_ O)) ->
  _H_S:(x_378:(pts.El pts.var nat) -> _x_380:(pts.El pts.var (Q_ x_378)) -> pts.El pts.var (Q_ (S x_378))) ->
  x_377:(pts.El pts.var nat) -> pts.El pts.var (Q_ x_377).

def nat_rect_Type3_body :
  Q_:(_x_377:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H_O:(pts.El pts.var (Q_ O)) ->
  _H_S:(x_378:(pts.El pts.var nat) -> _x_380:(pts.El pts.var (Q_ x_378)) -> pts.El pts.var (Q_ (S x_378))) ->
  x_377:(pts.El pts.var nat) -> pts.El pts.var (Q_ x_377).

[x_377, _H_S, _H_O, Q_]
  nat_rect_Type3 Q_ _H_O _H_S x_377
  -->
  filter_nat pts.var (x_377:(pts.El pts.var nat) => Q_ x_377) (nat_rect_Type3_body Q_ _H_O _H_S) x_377.

[x_377, _H_S, _H_O, Q_]
  nat_rect_Type3_body Q_ _H_O _H_S x_377
  -->
  match_nat
    pts.var
    Q_
    _H_O
    (x_378:(pts.El pts.var nat) => _H_S x_378 (nat_rect_Type3 Q_ _H_O _H_S x_378))
    x_377.

def nat_rect_Type2 :
  Q_:(_x_381:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H_O:(pts.El pts.var (Q_ O)) ->
  _H_S:(x_382:(pts.El pts.var nat) -> _x_384:(pts.El pts.var (Q_ x_382)) -> pts.El pts.var (Q_ (S x_382))) ->
  x_381:(pts.El pts.var nat) -> pts.El pts.var (Q_ x_381).

def nat_rect_Type2_body :
  Q_:(_x_381:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H_O:(pts.El pts.var (Q_ O)) ->
  _H_S:(x_382:(pts.El pts.var nat) -> _x_384:(pts.El pts.var (Q_ x_382)) -> pts.El pts.var (Q_ (S x_382))) ->
  x_381:(pts.El pts.var nat) -> pts.El pts.var (Q_ x_381).

[x_381, _H_S, _H_O, Q_]
  nat_rect_Type2 Q_ _H_O _H_S x_381
  -->
  filter_nat pts.var (x_381:(pts.El pts.var nat) => Q_ x_381) (nat_rect_Type2_body Q_ _H_O _H_S) x_381.

[x_381, _H_S, _H_O, Q_]
  nat_rect_Type2_body Q_ _H_O _H_S x_381
  -->
  match_nat
    pts.var
    Q_
    _H_O
    (x_382:(pts.El pts.var nat) => _H_S x_382 (nat_rect_Type2 Q_ _H_O _H_S x_382))
    x_381.

def nat_rect_Type1 :
  Q_:(_x_385:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H_O:(pts.El pts.var (Q_ O)) ->
  _H_S:(x_386:(pts.El pts.var nat) -> _x_388:(pts.El pts.var (Q_ x_386)) -> pts.El pts.var (Q_ (S x_386))) ->
  x_385:(pts.El pts.var nat) -> pts.El pts.var (Q_ x_385).

def nat_rect_Type1_body :
  Q_:(_x_385:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H_O:(pts.El pts.var (Q_ O)) ->
  _H_S:(x_386:(pts.El pts.var nat) -> _x_388:(pts.El pts.var (Q_ x_386)) -> pts.El pts.var (Q_ (S x_386))) ->
  x_385:(pts.El pts.var nat) -> pts.El pts.var (Q_ x_385).

[x_385, _H_S, _H_O, Q_]
  nat_rect_Type1 Q_ _H_O _H_S x_385
  -->
  filter_nat pts.var (x_385:(pts.El pts.var nat) => Q_ x_385) (nat_rect_Type1_body Q_ _H_O _H_S) x_385.

[x_385, _H_S, _H_O, Q_]
  nat_rect_Type1_body Q_ _H_O _H_S x_385
  -->
  match_nat
    pts.var
    Q_
    _H_O
    (x_386:(pts.El pts.var nat) => _H_S x_386 (nat_rect_Type1 Q_ _H_O _H_S x_386))
    x_385.

def nat_rect_Type0 :
  Q_:(_x_389:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H_O:(pts.El pts.var (Q_ O)) ->
  _H_S:(x_390:(pts.El pts.var nat) -> _x_392:(pts.El pts.var (Q_ x_390)) -> pts.El pts.var (Q_ (S x_390))) ->
  x_389:(pts.El pts.var nat) -> pts.El pts.var (Q_ x_389).

def nat_rect_Type0_body :
  Q_:(_x_389:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H_O:(pts.El pts.var (Q_ O)) ->
  _H_S:(x_390:(pts.El pts.var nat) -> _x_392:(pts.El pts.var (Q_ x_390)) -> pts.El pts.var (Q_ (S x_390))) ->
  x_389:(pts.El pts.var nat) -> pts.El pts.var (Q_ x_389).

[x_389, _H_S, _H_O, Q_]
  nat_rect_Type0 Q_ _H_O _H_S x_389
  -->
  filter_nat pts.var (x_389:(pts.El pts.var nat) => Q_ x_389) (nat_rect_Type0_body Q_ _H_O _H_S) x_389.

[x_389, _H_S, _H_O, Q_]
  nat_rect_Type0_body Q_ _H_O _H_S x_389
  -->
  match_nat
    pts.var
    Q_
    _H_O
    (x_390:(pts.El pts.var nat) => _H_S x_390 (nat_rect_Type0 Q_ _H_O _H_S x_390))
    x_389.

def nat_rect_CProp4 :
  Q_:(_x_393:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H_O:(pts.El pts.var (Q_ O)) ->
  _H_S:(x_394:(pts.El pts.var nat) -> _x_396:(pts.El pts.var (Q_ x_394)) -> pts.El pts.var (Q_ (S x_394))) ->
  x_393:(pts.El pts.var nat) -> pts.El pts.var (Q_ x_393).

def nat_rect_CProp4_body :
  Q_:(_x_393:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H_O:(pts.El pts.var (Q_ O)) ->
  _H_S:(x_394:(pts.El pts.var nat) -> _x_396:(pts.El pts.var (Q_ x_394)) -> pts.El pts.var (Q_ (S x_394))) ->
  x_393:(pts.El pts.var nat) -> pts.El pts.var (Q_ x_393).

[x_393, _H_S, _H_O, Q_]
  nat_rect_CProp4 Q_ _H_O _H_S x_393
  -->
  filter_nat
    pts.var
    (x_393:(pts.El pts.var nat) => Q_ x_393)
    (nat_rect_CProp4_body Q_ _H_O _H_S)
    x_393.

[x_393, _H_S, _H_O, Q_]
  nat_rect_CProp4_body Q_ _H_O _H_S x_393
  -->
  match_nat
    pts.var
    Q_
    _H_O
    (x_394:(pts.El pts.var nat) => _H_S x_394 (nat_rect_CProp4 Q_ _H_O _H_S x_394))
    x_393.

def nat_rect_CProp3 :
  Q_:(_x_401:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H_O:(pts.El pts.var (Q_ O)) ->
  _H_S:(x_402:(pts.El pts.var nat) -> _x_404:(pts.El pts.var (Q_ x_402)) -> pts.El pts.var (Q_ (S x_402))) ->
  x_401:(pts.El pts.var nat) -> pts.El pts.var (Q_ x_401).

def nat_rect_CProp3_body :
  Q_:(_x_401:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H_O:(pts.El pts.var (Q_ O)) ->
  _H_S:(x_402:(pts.El pts.var nat) -> _x_404:(pts.El pts.var (Q_ x_402)) -> pts.El pts.var (Q_ (S x_402))) ->
  x_401:(pts.El pts.var nat) -> pts.El pts.var (Q_ x_401).

[x_401, _H_S, _H_O, Q_]
  nat_rect_CProp3 Q_ _H_O _H_S x_401
  -->
  filter_nat
    pts.var
    (x_401:(pts.El pts.var nat) => Q_ x_401)
    (nat_rect_CProp3_body Q_ _H_O _H_S)
    x_401.

[x_401, _H_S, _H_O, Q_]
  nat_rect_CProp3_body Q_ _H_O _H_S x_401
  -->
  match_nat
    pts.var
    Q_
    _H_O
    (x_402:(pts.El pts.var nat) => _H_S x_402 (nat_rect_CProp3 Q_ _H_O _H_S x_402))
    x_401.

def nat_rect_CProp2 :
  Q_:(_x_405:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H_O:(pts.El pts.var (Q_ O)) ->
  _H_S:(x_406:(pts.El pts.var nat) -> _x_408:(pts.El pts.var (Q_ x_406)) -> pts.El pts.var (Q_ (S x_406))) ->
  x_405:(pts.El pts.var nat) -> pts.El pts.var (Q_ x_405).

def nat_rect_CProp2_body :
  Q_:(_x_405:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H_O:(pts.El pts.var (Q_ O)) ->
  _H_S:(x_406:(pts.El pts.var nat) -> _x_408:(pts.El pts.var (Q_ x_406)) -> pts.El pts.var (Q_ (S x_406))) ->
  x_405:(pts.El pts.var nat) -> pts.El pts.var (Q_ x_405).

[x_405, _H_S, _H_O, Q_]
  nat_rect_CProp2 Q_ _H_O _H_S x_405
  -->
  filter_nat
    pts.var
    (x_405:(pts.El pts.var nat) => Q_ x_405)
    (nat_rect_CProp2_body Q_ _H_O _H_S)
    x_405.

[x_405, _H_S, _H_O, Q_]
  nat_rect_CProp2_body Q_ _H_O _H_S x_405
  -->
  match_nat
    pts.var
    Q_
    _H_O
    (x_406:(pts.El pts.var nat) => _H_S x_406 (nat_rect_CProp2 Q_ _H_O _H_S x_406))
    x_405.

def nat_rect_CProp1 :
  Q_:(_x_409:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H_O:(pts.El pts.var (Q_ O)) ->
  _H_S:(x_410:(pts.El pts.var nat) -> _x_412:(pts.El pts.var (Q_ x_410)) -> pts.El pts.var (Q_ (S x_410))) ->
  x_409:(pts.El pts.var nat) -> pts.El pts.var (Q_ x_409).

def nat_rect_CProp1_body :
  Q_:(_x_409:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H_O:(pts.El pts.var (Q_ O)) ->
  _H_S:(x_410:(pts.El pts.var nat) -> _x_412:(pts.El pts.var (Q_ x_410)) -> pts.El pts.var (Q_ (S x_410))) ->
  x_409:(pts.El pts.var nat) -> pts.El pts.var (Q_ x_409).

[x_409, _H_S, _H_O, Q_]
  nat_rect_CProp1 Q_ _H_O _H_S x_409
  -->
  filter_nat
    pts.var
    (x_409:(pts.El pts.var nat) => Q_ x_409)
    (nat_rect_CProp1_body Q_ _H_O _H_S)
    x_409.

[x_409, _H_S, _H_O, Q_]
  nat_rect_CProp1_body Q_ _H_O _H_S x_409
  -->
  match_nat
    pts.var
    Q_
    _H_O
    (x_410:(pts.El pts.var nat) => _H_S x_410 (nat_rect_CProp1 Q_ _H_O _H_S x_410))
    x_409.

def nat_rect_CProp0 :
  Q_:(_x_413:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H_O:(pts.El pts.var (Q_ O)) ->
  _H_S:(x_414:(pts.El pts.var nat) -> _x_416:(pts.El pts.var (Q_ x_414)) -> pts.El pts.var (Q_ (S x_414))) ->
  x_413:(pts.El pts.var nat) -> pts.El pts.var (Q_ x_413).

def nat_rect_CProp0_body :
  Q_:(_x_413:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H_O:(pts.El pts.var (Q_ O)) ->
  _H_S:(x_414:(pts.El pts.var nat) -> _x_416:(pts.El pts.var (Q_ x_414)) -> pts.El pts.var (Q_ (S x_414))) ->
  x_413:(pts.El pts.var nat) -> pts.El pts.var (Q_ x_413).

[x_413, _H_S, _H_O, Q_]
  nat_rect_CProp0 Q_ _H_O _H_S x_413
  -->
  filter_nat
    pts.var
    (x_413:(pts.El pts.var nat) => Q_ x_413)
    (nat_rect_CProp0_body Q_ _H_O _H_S)
    x_413.

[x_413, _H_S, _H_O, Q_]
  nat_rect_CProp0_body Q_ _H_O _H_S x_413
  -->
  match_nat
    pts.var
    Q_
    _H_O
    (x_414:(pts.El pts.var nat) => _H_S x_414 (nat_rect_CProp0 Q_ _H_O _H_S x_414))
    x_413.

def nat_inv_ind :
  Hterm:(pts.El pts.var nat) ->
  P:(_z653:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H1:(_z654:(pts.El pts.var (matita_basics_logic.eq nat Hterm O)) -> pts.El pts.var (P O)) ->
  _H2:(x_366:(pts.El pts.var nat) ->
       _x_368:(_z654:(pts.El pts.var (matita_basics_logic.eq nat Hterm x_366)) -> pts.El pts.var (P x_366)) ->
       _z654:(pts.El pts.var (matita_basics_logic.eq nat Hterm (S x_366))) ->
       pts.El pts.var (P (S x_366))) ->
  pts.El pts.var (P Hterm)
  :=
  Hterm:(pts.El pts.var nat) =>
  P:(_z653:(pts.El pts.var nat) -> pts.U pts.var) =>
  H1:(_z654:(pts.El pts.var (matita_basics_logic.eq nat Hterm O)) -> pts.El pts.var (P O)) =>
  H2:(x_366:(pts.El pts.var nat) ->
      _x_368:(_z654:(pts.El pts.var (matita_basics_logic.eq nat Hterm x_366)) -> pts.El pts.var (P x_366)) ->
      _z654:(pts.El pts.var (matita_basics_logic.eq nat Hterm (S x_366))) ->
      pts.El pts.var (P (S x_366))) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       (matita_basics_logic.eq nat Hterm _x_365)
       (_z654:(pts.El pts.var (matita_basics_logic.eq nat Hterm _x_365)) => P _x_365))
    H1
    H2
    Hterm
    (matita_basics_logic.refl nat Hterm).

def nat_inv_rect_Type4 :
  Hterm:(pts.El pts.var nat) ->
  P:(_z659:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H1:(_z660:(pts.El pts.var (matita_basics_logic.eq nat Hterm O)) -> pts.El pts.var (P O)) ->
  _H2:(x_370:(pts.El pts.var nat) ->
       _x_372:(_z660:(pts.El pts.var (matita_basics_logic.eq nat Hterm x_370)) -> pts.El pts.var (P x_370)) ->
       _z660:(pts.El pts.var (matita_basics_logic.eq nat Hterm (S x_370))) ->
       pts.El pts.var (P (S x_370))) ->
  pts.El pts.var (P Hterm)
  :=
  Hterm:(pts.El pts.var nat) =>
  P:(_z659:(pts.El pts.var nat) -> pts.U pts.var) =>
  H1:(_z660:(pts.El pts.var (matita_basics_logic.eq nat Hterm O)) -> pts.El pts.var (P O)) =>
  H2:(x_370:(pts.El pts.var nat) ->
      _x_372:(_z660:(pts.El pts.var (matita_basics_logic.eq nat Hterm x_370)) -> pts.El pts.var (P x_370)) ->
      _z660:(pts.El pts.var (matita_basics_logic.eq nat Hterm (S x_370))) ->
      pts.El pts.var (P (S x_370))) =>
  nat_rect_Type4
    (_x_369:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       (matita_basics_logic.eq nat Hterm _x_369)
       (_z660:(pts.El pts.var (matita_basics_logic.eq nat Hterm _x_369)) => P _x_369))
    H1
    H2
    Hterm
    (matita_basics_logic.refl nat Hterm).

def nat_inv_rect_Type3 :
  Hterm:(pts.El pts.var nat) ->
  P:(_z665:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H1:(_z666:(pts.El pts.var (matita_basics_logic.eq nat Hterm O)) -> pts.El pts.var (P O)) ->
  _H2:(x_378:(pts.El pts.var nat) ->
       _x_380:(_z666:(pts.El pts.var (matita_basics_logic.eq nat Hterm x_378)) -> pts.El pts.var (P x_378)) ->
       _z666:(pts.El pts.var (matita_basics_logic.eq nat Hterm (S x_378))) ->
       pts.El pts.var (P (S x_378))) ->
  pts.El pts.var (P Hterm)
  :=
  Hterm:(pts.El pts.var nat) =>
  P:(_z665:(pts.El pts.var nat) -> pts.U pts.var) =>
  H1:(_z666:(pts.El pts.var (matita_basics_logic.eq nat Hterm O)) -> pts.El pts.var (P O)) =>
  H2:(x_378:(pts.El pts.var nat) ->
      _x_380:(_z666:(pts.El pts.var (matita_basics_logic.eq nat Hterm x_378)) -> pts.El pts.var (P x_378)) ->
      _z666:(pts.El pts.var (matita_basics_logic.eq nat Hterm (S x_378))) ->
      pts.El pts.var (P (S x_378))) =>
  nat_rect_Type3
    (_x_377:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       (matita_basics_logic.eq nat Hterm _x_377)
       (_z666:(pts.El pts.var (matita_basics_logic.eq nat Hterm _x_377)) => P _x_377))
    H1
    H2
    Hterm
    (matita_basics_logic.refl nat Hterm).

def nat_inv_rect_Type2 :
  Hterm:(pts.El pts.var nat) ->
  P:(_z671:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H1:(_z672:(pts.El pts.var (matita_basics_logic.eq nat Hterm O)) -> pts.El pts.var (P O)) ->
  _H2:(x_382:(pts.El pts.var nat) ->
       _x_384:(_z672:(pts.El pts.var (matita_basics_logic.eq nat Hterm x_382)) -> pts.El pts.var (P x_382)) ->
       _z672:(pts.El pts.var (matita_basics_logic.eq nat Hterm (S x_382))) ->
       pts.El pts.var (P (S x_382))) ->
  pts.El pts.var (P Hterm)
  :=
  Hterm:(pts.El pts.var nat) =>
  P:(_z671:(pts.El pts.var nat) -> pts.U pts.var) =>
  H1:(_z672:(pts.El pts.var (matita_basics_logic.eq nat Hterm O)) -> pts.El pts.var (P O)) =>
  H2:(x_382:(pts.El pts.var nat) ->
      _x_384:(_z672:(pts.El pts.var (matita_basics_logic.eq nat Hterm x_382)) -> pts.El pts.var (P x_382)) ->
      _z672:(pts.El pts.var (matita_basics_logic.eq nat Hterm (S x_382))) ->
      pts.El pts.var (P (S x_382))) =>
  nat_rect_Type2
    (_x_381:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       (matita_basics_logic.eq nat Hterm _x_381)
       (_z672:(pts.El pts.var (matita_basics_logic.eq nat Hterm _x_381)) => P _x_381))
    H1
    H2
    Hterm
    (matita_basics_logic.refl nat Hterm).

def nat_inv_rect_Type1 :
  Hterm:(pts.El pts.var nat) ->
  P:(_z677:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H1:(_z678:(pts.El pts.var (matita_basics_logic.eq nat Hterm O)) -> pts.El pts.var (P O)) ->
  _H2:(x_386:(pts.El pts.var nat) ->
       _x_388:(_z678:(pts.El pts.var (matita_basics_logic.eq nat Hterm x_386)) -> pts.El pts.var (P x_386)) ->
       _z678:(pts.El pts.var (matita_basics_logic.eq nat Hterm (S x_386))) ->
       pts.El pts.var (P (S x_386))) ->
  pts.El pts.var (P Hterm)
  :=
  Hterm:(pts.El pts.var nat) =>
  P:(_z677:(pts.El pts.var nat) -> pts.U pts.var) =>
  H1:(_z678:(pts.El pts.var (matita_basics_logic.eq nat Hterm O)) -> pts.El pts.var (P O)) =>
  H2:(x_386:(pts.El pts.var nat) ->
      _x_388:(_z678:(pts.El pts.var (matita_basics_logic.eq nat Hterm x_386)) -> pts.El pts.var (P x_386)) ->
      _z678:(pts.El pts.var (matita_basics_logic.eq nat Hterm (S x_386))) ->
      pts.El pts.var (P (S x_386))) =>
  nat_rect_Type1
    (_x_385:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       (matita_basics_logic.eq nat Hterm _x_385)
       (_z678:(pts.El pts.var (matita_basics_logic.eq nat Hterm _x_385)) => P _x_385))
    H1
    H2
    Hterm
    (matita_basics_logic.refl nat Hterm).

def nat_inv_rect_Type0 :
  Hterm:(pts.El pts.var nat) ->
  P:(_z683:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H1:(_z684:(pts.El pts.var (matita_basics_logic.eq nat Hterm O)) -> pts.El pts.var (P O)) ->
  _H2:(x_390:(pts.El pts.var nat) ->
       _x_392:(_z684:(pts.El pts.var (matita_basics_logic.eq nat Hterm x_390)) -> pts.El pts.var (P x_390)) ->
       _z684:(pts.El pts.var (matita_basics_logic.eq nat Hterm (S x_390))) ->
       pts.El pts.var (P (S x_390))) ->
  pts.El pts.var (P Hterm)
  :=
  Hterm:(pts.El pts.var nat) =>
  P:(_z683:(pts.El pts.var nat) -> pts.U pts.var) =>
  H1:(_z684:(pts.El pts.var (matita_basics_logic.eq nat Hterm O)) -> pts.El pts.var (P O)) =>
  H2:(x_390:(pts.El pts.var nat) ->
      _x_392:(_z684:(pts.El pts.var (matita_basics_logic.eq nat Hterm x_390)) -> pts.El pts.var (P x_390)) ->
      _z684:(pts.El pts.var (matita_basics_logic.eq nat Hterm (S x_390))) ->
      pts.El pts.var (P (S x_390))) =>
  nat_rect_Type0
    (_x_389:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       (matita_basics_logic.eq nat Hterm _x_389)
       (_z684:(pts.El pts.var (matita_basics_logic.eq nat Hterm _x_389)) => P _x_389))
    H1
    H2
    Hterm
    (matita_basics_logic.refl nat Hterm).

def nat_inv_rect_CProp4 :
  Hterm:(pts.El pts.var nat) ->
  P:(_z689:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H1:(_z690:(pts.El pts.var (matita_basics_logic.eq nat Hterm O)) -> pts.El pts.var (P O)) ->
  _H2:(x_394:(pts.El pts.var nat) ->
       _x_396:(_z690:(pts.El pts.var (matita_basics_logic.eq nat Hterm x_394)) -> pts.El pts.var (P x_394)) ->
       _z690:(pts.El pts.var (matita_basics_logic.eq nat Hterm (S x_394))) ->
       pts.El pts.var (P (S x_394))) ->
  pts.El pts.var (P Hterm)
  :=
  Hterm:(pts.El pts.var nat) =>
  P:(_z689:(pts.El pts.var nat) -> pts.U pts.var) =>
  H1:(_z690:(pts.El pts.var (matita_basics_logic.eq nat Hterm O)) -> pts.El pts.var (P O)) =>
  H2:(x_394:(pts.El pts.var nat) ->
      _x_396:(_z690:(pts.El pts.var (matita_basics_logic.eq nat Hterm x_394)) -> pts.El pts.var (P x_394)) ->
      _z690:(pts.El pts.var (matita_basics_logic.eq nat Hterm (S x_394))) ->
      pts.El pts.var (P (S x_394))) =>
  nat_rect_CProp4
    (_x_393:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       (matita_basics_logic.eq nat Hterm _x_393)
       (_z690:(pts.El pts.var (matita_basics_logic.eq nat Hterm _x_393)) => P _x_393))
    H1
    H2
    Hterm
    (matita_basics_logic.refl nat Hterm).

def nat_inv_rect_CProp3 :
  Hterm:(pts.El pts.var nat) ->
  P:(_z695:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H1:(_z696:(pts.El pts.var (matita_basics_logic.eq nat Hterm O)) -> pts.El pts.var (P O)) ->
  _H2:(x_402:(pts.El pts.var nat) ->
       _x_404:(_z696:(pts.El pts.var (matita_basics_logic.eq nat Hterm x_402)) -> pts.El pts.var (P x_402)) ->
       _z696:(pts.El pts.var (matita_basics_logic.eq nat Hterm (S x_402))) ->
       pts.El pts.var (P (S x_402))) ->
  pts.El pts.var (P Hterm)
  :=
  Hterm:(pts.El pts.var nat) =>
  P:(_z695:(pts.El pts.var nat) -> pts.U pts.var) =>
  H1:(_z696:(pts.El pts.var (matita_basics_logic.eq nat Hterm O)) -> pts.El pts.var (P O)) =>
  H2:(x_402:(pts.El pts.var nat) ->
      _x_404:(_z696:(pts.El pts.var (matita_basics_logic.eq nat Hterm x_402)) -> pts.El pts.var (P x_402)) ->
      _z696:(pts.El pts.var (matita_basics_logic.eq nat Hterm (S x_402))) ->
      pts.El pts.var (P (S x_402))) =>
  nat_rect_CProp3
    (_x_401:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       (matita_basics_logic.eq nat Hterm _x_401)
       (_z696:(pts.El pts.var (matita_basics_logic.eq nat Hterm _x_401)) => P _x_401))
    H1
    H2
    Hterm
    (matita_basics_logic.refl nat Hterm).

def nat_inv_rect_CProp2 :
  Hterm:(pts.El pts.var nat) ->
  P:(_z701:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H1:(_z702:(pts.El pts.var (matita_basics_logic.eq nat Hterm O)) -> pts.El pts.var (P O)) ->
  _H2:(x_406:(pts.El pts.var nat) ->
       _x_408:(_z702:(pts.El pts.var (matita_basics_logic.eq nat Hterm x_406)) -> pts.El pts.var (P x_406)) ->
       _z702:(pts.El pts.var (matita_basics_logic.eq nat Hterm (S x_406))) ->
       pts.El pts.var (P (S x_406))) ->
  pts.El pts.var (P Hterm)
  :=
  Hterm:(pts.El pts.var nat) =>
  P:(_z701:(pts.El pts.var nat) -> pts.U pts.var) =>
  H1:(_z702:(pts.El pts.var (matita_basics_logic.eq nat Hterm O)) -> pts.El pts.var (P O)) =>
  H2:(x_406:(pts.El pts.var nat) ->
      _x_408:(_z702:(pts.El pts.var (matita_basics_logic.eq nat Hterm x_406)) -> pts.El pts.var (P x_406)) ->
      _z702:(pts.El pts.var (matita_basics_logic.eq nat Hterm (S x_406))) ->
      pts.El pts.var (P (S x_406))) =>
  nat_rect_CProp2
    (_x_405:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       (matita_basics_logic.eq nat Hterm _x_405)
       (_z702:(pts.El pts.var (matita_basics_logic.eq nat Hterm _x_405)) => P _x_405))
    H1
    H2
    Hterm
    (matita_basics_logic.refl nat Hterm).

def nat_inv_rect_CProp1 :
  Hterm:(pts.El pts.var nat) ->
  P:(_z707:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H1:(_z708:(pts.El pts.var (matita_basics_logic.eq nat Hterm O)) -> pts.El pts.var (P O)) ->
  _H2:(x_410:(pts.El pts.var nat) ->
       _x_412:(_z708:(pts.El pts.var (matita_basics_logic.eq nat Hterm x_410)) -> pts.El pts.var (P x_410)) ->
       _z708:(pts.El pts.var (matita_basics_logic.eq nat Hterm (S x_410))) ->
       pts.El pts.var (P (S x_410))) ->
  pts.El pts.var (P Hterm)
  :=
  Hterm:(pts.El pts.var nat) =>
  P:(_z707:(pts.El pts.var nat) -> pts.U pts.var) =>
  H1:(_z708:(pts.El pts.var (matita_basics_logic.eq nat Hterm O)) -> pts.El pts.var (P O)) =>
  H2:(x_410:(pts.El pts.var nat) ->
      _x_412:(_z708:(pts.El pts.var (matita_basics_logic.eq nat Hterm x_410)) -> pts.El pts.var (P x_410)) ->
      _z708:(pts.El pts.var (matita_basics_logic.eq nat Hterm (S x_410))) ->
      pts.El pts.var (P (S x_410))) =>
  nat_rect_CProp1
    (_x_409:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       (matita_basics_logic.eq nat Hterm _x_409)
       (_z708:(pts.El pts.var (matita_basics_logic.eq nat Hterm _x_409)) => P _x_409))
    H1
    H2
    Hterm
    (matita_basics_logic.refl nat Hterm).

def nat_inv_rect_CProp0 :
  Hterm:(pts.El pts.var nat) ->
  P:(_z713:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H1:(_z714:(pts.El pts.var (matita_basics_logic.eq nat Hterm O)) -> pts.El pts.var (P O)) ->
  _H2:(x_414:(pts.El pts.var nat) ->
       _x_416:(_z714:(pts.El pts.var (matita_basics_logic.eq nat Hterm x_414)) -> pts.El pts.var (P x_414)) ->
       _z714:(pts.El pts.var (matita_basics_logic.eq nat Hterm (S x_414))) ->
       pts.El pts.var (P (S x_414))) ->
  pts.El pts.var (P Hterm)
  :=
  Hterm:(pts.El pts.var nat) =>
  P:(_z713:(pts.El pts.var nat) -> pts.U pts.var) =>
  H1:(_z714:(pts.El pts.var (matita_basics_logic.eq nat Hterm O)) -> pts.El pts.var (P O)) =>
  H2:(x_414:(pts.El pts.var nat) ->
      _x_416:(_z714:(pts.El pts.var (matita_basics_logic.eq nat Hterm x_414)) -> pts.El pts.var (P x_414)) ->
      _z714:(pts.El pts.var (matita_basics_logic.eq nat Hterm (S x_414))) ->
      pts.El pts.var (P (S x_414))) =>
  nat_rect_CProp0
    (_x_413:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       (matita_basics_logic.eq nat Hterm _x_413)
       (_z714:(pts.El pts.var (matita_basics_logic.eq nat Hterm _x_413)) => P _x_413))
    H1
    H2
    Hterm
    (matita_basics_logic.refl nat Hterm).

def nat_discr :
  x:(pts.El pts.var nat) ->
  y:(pts.El pts.var nat) ->
  _e:(pts.El pts.var (matita_basics_logic.eq nat x y)) ->
  pts.El
    pts.var
    (match_nat
       pts.var
       (__:(pts.El pts.var nat) => pts.u pts.var)
       (match_nat
          pts.var
          (__:(pts.El pts.var nat) => pts.u pts.var)
          (pts.Prod
             pts.var
             pts.var
             (pts.u pts.var)
             (P:(pts.U pts.var) => pts.Prod pts.var pts.var P (_z23:(pts.El pts.var P) => P)))
          (u0:(pts.El pts.var nat) =>
           pts.Prod pts.var pts.var (pts.u pts.var) (P:(pts.U pts.var) => P))
          y)
       (t0:(pts.El pts.var nat) =>
        match_nat
          pts.var
          (__:(pts.El pts.var nat) => pts.u pts.var)
          (pts.Prod pts.var pts.var (pts.u pts.var) (P:(pts.U pts.var) => P))
          (u0:(pts.El pts.var nat) =>
           pts.Prod
             pts.var
             pts.var
             (pts.u pts.var)
             (P:(pts.U pts.var) =>
              pts.Prod
                pts.var
                pts.var
                (pts.Prod
                   pts.var
                   pts.var
                   (matita_basics_logic.eq nat (matita_basics_logic.R0 nat t0) u0)
                   (_e0:(pts.El
                           pts.var
                           (matita_basics_logic.eq nat (matita_basics_logic.R0 nat t0) u0)) =>
                    P))
                (_z24:(_e0:(pts.El
                              pts.var
                              (matita_basics_logic.eq nat (matita_basics_logic.R0 nat t0) u0)) ->
                       pts.El pts.var P) =>
                 P)))
          y)
       x)
  :=
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  Deq:(pts.El pts.var (matita_basics_logic.eq nat x y)) =>
  matita_basics_logic.eq_rect_Type2
    nat
    x
    (x_13:(pts.El pts.var nat) =>
     _x_14:(pts.El pts.var (matita_basics_logic.eq nat x x_13)) =>
     match_nat
       pts.var
       (__:(pts.El pts.var nat) => pts.u pts.var)
       (match_nat
          pts.var
          (__:(pts.El pts.var nat) => pts.u pts.var)
          (pts.Prod
             pts.var
             pts.var
             (pts.u pts.var)
             (P:(pts.U pts.var) => pts.Prod pts.var pts.var P (_z23:(pts.El pts.var P) => P)))
          (u0:(pts.El pts.var nat) =>
           pts.Prod pts.var pts.var (pts.u pts.var) (P:(pts.U pts.var) => P))
          x_13)
       (t0:(pts.El pts.var nat) =>
        match_nat
          pts.var
          (__:(pts.El pts.var nat) => pts.u pts.var)
          (pts.Prod pts.var pts.var (pts.u pts.var) (P:(pts.U pts.var) => P))
          (u0:(pts.El pts.var nat) =>
           pts.Prod
             pts.var
             pts.var
             (pts.u pts.var)
             (P:(pts.U pts.var) =>
              pts.Prod
                pts.var
                pts.var
                (pts.Prod
                   pts.var
                   pts.var
                   (matita_basics_logic.eq nat (matita_basics_logic.R0 nat t0) u0)
                   (_e0:(pts.El
                           pts.var
                           (matita_basics_logic.eq nat (matita_basics_logic.R0 nat t0) u0)) =>
                    P))
                (_z24:(_e0:(pts.El
                              pts.var
                              (matita_basics_logic.eq nat (matita_basics_logic.R0 nat t0) u0)) ->
                       pts.El pts.var P) =>
                 P)))
          x_13)
       x)
    (match_nat
       pts.var
       (__:(pts.El pts.var nat) =>
        match_nat
          pts.var
          (_0:(pts.El pts.var nat) => pts.u pts.var)
          (match_nat
             pts.var
             (_0:(pts.El pts.var nat) => pts.u pts.var)
             (pts.Prod
                pts.var
                pts.var
                (pts.u pts.var)
                (P:(pts.U pts.var) => pts.Prod pts.var pts.var P (_z23:(pts.El pts.var P) => P)))
             (u0:(pts.El pts.var nat) =>
              pts.Prod pts.var pts.var (pts.u pts.var) (P:(pts.U pts.var) => P))
             __)
          (t0:(pts.El pts.var nat) =>
           match_nat
             pts.var
             (_0:(pts.El pts.var nat) => pts.u pts.var)
             (pts.Prod pts.var pts.var (pts.u pts.var) (P:(pts.U pts.var) => P))
             (u0:(pts.El pts.var nat) =>
              pts.Prod
                pts.var
                pts.var
                (pts.u pts.var)
                (P:(pts.U pts.var) =>
                 pts.Prod
                   pts.var
                   pts.var
                   (pts.Prod
                      pts.var
                      pts.var
                      (matita_basics_logic.eq nat (matita_basics_logic.R0 nat t0) u0)
                      (_e0:(pts.El
                              pts.var
                              (matita_basics_logic.eq
                                 nat
                                 (matita_basics_logic.R0 nat t0)
                                 u0)) =>
                       P))
                   (_z24:(_e0:(pts.El
                                 pts.var
                                 (matita_basics_logic.eq nat (matita_basics_logic.R0 nat t0) u0)) ->
                          pts.El pts.var P) =>
                    P)))
             __)
          __)
       (P:(pts.U pts.var) => DH:(pts.El pts.var P) => DH)
       (a0:(pts.El pts.var nat) =>
        P:(pts.U pts.var) =>
        DH:(_e0:(pts.El pts.var (matita_basics_logic.eq nat (matita_basics_logic.R0 nat a0) a0)) ->
            pts.El pts.var P) =>
        DH (matita_basics_logic.refl nat (matita_basics_logic.R0 nat a0)))
       x)
    y
    Deq.

def pred :
  _n:(pts.El pts.var nat) -> pts.El pts.var nat
  :=
  n:(pts.El pts.var nat) =>
  match_nat pts.var (__:(pts.El pts.var nat) => nat) O (p:(pts.El pts.var nat) => p) n.

def not_zero :
  __:(pts.El pts.var nat) -> pts.U pts.var
  :=
  n:(pts.El pts.var nat) =>
  match_nat
    pts.var
    (__:(pts.El pts.var nat) => pts.u pts.var)
    matita_basics_logic.False
    (p:(pts.El pts.var nat) => matita_basics_logic.True)
    n.

le : _n:(pts.El pts.var nat) -> __:(pts.El pts.var nat) -> pts.U pts.var.

le_n : n:(pts.El pts.var nat) -> pts.El pts.var (le n n).

le_S :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) -> __:(pts.El pts.var (le n m)) -> pts.El pts.var (le n (S m)).

def match_le :
  _n:(pts.El pts.var nat) ->
  return_sort:pts.Lvl ->
  return_type:(__:(pts.El pts.var nat) -> z:(pts.El pts.var (le _n __)) -> pts.U return_sort) ->
  case_le_n:(pts.El return_sort (return_type _n (le_n _n))) ->
  case_le_S:(m:(pts.El pts.var nat) ->
             __:(pts.El pts.var (le _n m)) -> pts.El return_sort (return_type (S m) (le_S _n m __))) ->
  __:(pts.El pts.var nat) -> z:(pts.El pts.var (le _n __)) -> pts.El return_sort (return_type __ z).

[case_le_S, case_le_n, return_type, return_sort, _n]
  match_le _n return_sort return_type case_le_n case_le_S _n (le_n _n)
  -->
  case_le_n.

[__, m, case_le_S, case_le_n, return_type, return_sort, _n]
  match_le _n return_sort return_type case_le_n case_le_S (S m) (le_S _n m __)
  -->
  case_le_S m __.

def filter_le :
  _n:(pts.El pts.var nat) ->
  __:(pts.El pts.var nat) ->
  return_sort:pts.Lvl ->
  return_type:(z:(pts.El pts.var (le _n __)) -> pts.U return_sort) ->
  return:(z:(pts.El pts.var (le _n __)) -> pts.El return_sort (return_type z)) ->
  z:(pts.El pts.var (le _n __)) -> pts.El return_sort (return_type z).

[return, return_type, return_sort, n]
  filter_le n n return_sort return_type return (le_n n) --> return (le_n n).

[__, return, return_type, return_sort, m, n]
  filter_le n (S m) return_sort return_type return (le_S n m __)
  -->
  return (le_S n m __).

def le_ind :
  _n:(pts.El pts.var nat) ->
  Q_:(x_417:(pts.El pts.var nat) -> _x_418:(pts.El pts.var (le _n x_417)) -> pts.U pts.var) ->
  _H_le_n:(pts.El pts.var (Q_ _n (le_n _n))) ->
  _H_le_S:(m:(pts.El pts.var nat) ->
           x_419:(pts.El pts.var (le _n m)) ->
           _x_421:(pts.El pts.var (Q_ m x_419)) -> pts.El pts.var (Q_ (S m) (le_S _n m x_419))) ->
  x_417:(pts.El pts.var nat) ->
  x_418:(pts.El pts.var (le _n x_417)) -> pts.El pts.var (Q_ x_417 x_418).

def le_ind_body :
  _n:(pts.El pts.var nat) ->
  Q_:(x_417:(pts.El pts.var nat) -> _x_418:(pts.El pts.var (le _n x_417)) -> pts.U pts.var) ->
  _H_le_n:(pts.El pts.var (Q_ _n (le_n _n))) ->
  _H_le_S:(m:(pts.El pts.var nat) ->
           x_419:(pts.El pts.var (le _n m)) ->
           _x_421:(pts.El pts.var (Q_ m x_419)) -> pts.El pts.var (Q_ (S m) (le_S _n m x_419))) ->
  x_417:(pts.El pts.var nat) ->
  x_418:(pts.El pts.var (le _n x_417)) -> pts.El pts.var (Q_ x_417 x_418).

[x_418, x_417, _H_le_S, _H_le_n, Q_, _n]
  le_ind _n Q_ _H_le_n _H_le_S x_417 x_418
  -->
  filter_le
    _n
    x_417
    pts.var
    (x_418:(pts.El pts.var (le _n x_417)) => Q_ x_417 x_418)
    (le_ind_body _n Q_ _H_le_n _H_le_S x_417)
    x_418.

[x_418, x_417, _H_le_S, _H_le_n, Q_, _n]
  le_ind_body _n Q_ _H_le_n _H_le_S x_417 x_418
  -->
  match_le
    _n
    pts.var
    Q_
    _H_le_n
    (m:(pts.El pts.var nat) =>
     x_419:(pts.El pts.var (le _n m)) => _H_le_S m x_419 (le_ind _n Q_ _H_le_n _H_le_S m x_419))
    x_417
    x_418.

def le_inv_ind :
  x1:(pts.El pts.var nat) ->
  x2:(pts.El pts.var nat) ->
  _Hterm:(pts.El pts.var (le x1 x2)) ->
  P:(_z724:(pts.El pts.var nat) -> pts.U pts.var) ->
  _H1:(_z725:(pts.El pts.var (matita_basics_logic.eq nat x2 x1)) -> pts.El pts.var (P x1)) ->
  _H2:(m:(pts.El pts.var nat) ->
       _x_419:(pts.El pts.var (le x1 m)) ->
       _x_421:(_z725:(pts.El pts.var (matita_basics_logic.eq nat x2 m)) -> pts.El pts.var (P m)) ->
       _z725:(pts.El pts.var (matita_basics_logic.eq nat x2 (S m))) -> pts.El pts.var (P (S m))) ->
  pts.El pts.var (P x2)
  :=
  x1:(pts.El pts.var nat) =>
  x2:(pts.El pts.var nat) =>
  Hterm:(pts.El pts.var (le x1 x2)) =>
  P:(_z724:(pts.El pts.var nat) -> pts.U pts.var) =>
  H1:(_z725:(pts.El pts.var (matita_basics_logic.eq nat x2 x1)) -> pts.El pts.var (P x1)) =>
  H2:(m:(pts.El pts.var nat) ->
      _x_419:(pts.El pts.var (le x1 m)) ->
      _x_421:(_z725:(pts.El pts.var (matita_basics_logic.eq nat x2 m)) -> pts.El pts.var (P m)) ->
      _z725:(pts.El pts.var (matita_basics_logic.eq nat x2 (S m))) -> pts.El pts.var (P (S m))) =>
  le_ind
    x1
    (x_417:(pts.El pts.var nat) =>
     _x_418:(pts.El pts.var (le x1 x_417)) =>
     pts.Prod
       pts.var
       pts.var
       (matita_basics_logic.eq nat x2 x_417)
       (_z725:(pts.El pts.var (matita_basics_logic.eq nat x2 x_417)) => P x_417))
    H1
    H2
    x2
    Hterm
    (matita_basics_logic.refl nat x2).

def lt :
  __:(pts.El pts.var nat) -> __1:(pts.El pts.var nat) -> pts.U pts.var
  :=
  n:(pts.El pts.var nat) => m:(pts.El pts.var nat) => le (S n) m.

def ge :
  __:(pts.El pts.var nat) -> __1:(pts.El pts.var nat) -> pts.U pts.var
  :=
  n:(pts.El pts.var nat) => m:(pts.El pts.var nat) => le m n.

def gt :
  __:(pts.El pts.var nat) -> __1:(pts.El pts.var nat) -> pts.U pts.var
  :=
  n:(pts.El pts.var nat) => m:(pts.El pts.var nat) => lt m n.

def increasing :
  _f:(__:(pts.El pts.var nat) -> pts.El pts.var nat) -> pts.U pts.var
  :=
  f:(__:(pts.El pts.var nat) -> pts.El pts.var nat) =>
  pts.Prod pts.var pts.var nat (n:(pts.El pts.var nat) => lt (f n) (f (S n))).

def plus :
  __:(pts.El pts.var nat) -> __1:(pts.El pts.var nat) -> pts.El pts.var nat.

def plus_body :
  __:(pts.El pts.var nat) -> __1:(pts.El pts.var nat) -> pts.El pts.var nat.

[__]
  plus __
  -->
  filter_nat
    pts.var
    (__:(pts.El pts.var nat) => pts.Prod pts.var pts.var nat (__1:(pts.El pts.var nat) => nat))
    plus_body
    __.

[__]
  plus_body __
  -->
  m:(pts.El pts.var nat) =>
  match_nat pts.var (__1:(pts.El pts.var nat) => nat) m (p:(pts.El pts.var nat) => S (plus p m)) __.

def times :
  __:(pts.El pts.var nat) -> __1:(pts.El pts.var nat) -> pts.El pts.var nat.

def times_body :
  __:(pts.El pts.var nat) -> __1:(pts.El pts.var nat) -> pts.El pts.var nat.

[__]
  times __
  -->
  filter_nat
    pts.var
    (__:(pts.El pts.var nat) => pts.Prod pts.var pts.var nat (__1:(pts.El pts.var nat) => nat))
    times_body
    __.

[__]
  times_body __
  -->
  m:(pts.El pts.var nat) =>
  match_nat
    pts.var
    (__1:(pts.El pts.var nat) => nat)
    O
    (p:(pts.El pts.var nat) => plus m (times p m))
    __.

def minus :
  __:(pts.El pts.var nat) -> __1:(pts.El pts.var nat) -> pts.El pts.var nat.

def minus_body :
  __:(pts.El pts.var nat) -> __1:(pts.El pts.var nat) -> pts.El pts.var nat.

[__]
  minus __
  -->
  filter_nat
    pts.var
    (__:(pts.El pts.var nat) => pts.Prod pts.var pts.var nat (__1:(pts.El pts.var nat) => nat))
    minus_body
    __.

[__]
  minus_body __
  -->
  m:(pts.El pts.var nat) =>
  match_nat
    pts.var
    (__1:(pts.El pts.var nat) => nat)
    O
    (p:(pts.El pts.var nat) =>
     match_nat
       pts.var
       (__1:(pts.El pts.var nat) => nat)
       (S p)
       (q:(pts.El pts.var nat) => minus p q)
       m)
    __.

def nat_case :
  n:(pts.El pts.var nat) ->
  P:(__:(pts.El pts.var nat) -> pts.U pts.var) ->
  __:(__:(pts.El pts.var (matita_basics_logic.eq nat n O)) -> pts.El pts.var (P O)) ->
  __1:(m:(pts.El pts.var nat) ->
       __1:(pts.El pts.var (matita_basics_logic.eq nat n (S m))) -> pts.El pts.var (P (S m))) ->
  pts.El pts.var (P n)
  :=
  n:(pts.El pts.var nat) =>
  P:(__:(pts.El pts.var nat) -> pts.U pts.var) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       (pts.Prod
          pts.var
          pts.var
          (matita_basics_logic.eq nat _x_365 O)
          (__:(pts.El pts.var (matita_basics_logic.eq nat _x_365 O)) => P O))
       (__:(__:(pts.El pts.var (matita_basics_logic.eq nat _x_365 O)) -> pts.El pts.var (P O)) =>
        pts.Prod
          pts.var
          pts.var
          (pts.Prod
             pts.var
             pts.var
             nat
             (m:(pts.El pts.var nat) =>
              pts.Prod
                pts.var
                pts.var
                (matita_basics_logic.eq nat _x_365 (S m))
                (__1:(pts.El pts.var (matita_basics_logic.eq nat _x_365 (S m))) => P (S m))))
          (__1:(m:(pts.El pts.var nat) ->
                __1:(pts.El pts.var (matita_basics_logic.eq nat _x_365 (S m))) ->
                pts.El pts.var (P (S m))) =>
           P _x_365)))
    (auto:(__:(pts.El pts.var (matita_basics_logic.eq nat O O)) -> pts.El pts.var (P O)) =>
     auto':(m:(pts.El pts.var nat) ->
            __:(pts.El pts.var (matita_basics_logic.eq nat O (S m))) -> pts.El pts.var (P (S m))) =>
     auto (matita_basics_logic.refl nat O))
    (x_366:(pts.El pts.var nat) =>
     _x_368:(__:(__:(pts.El pts.var (matita_basics_logic.eq nat x_366 O)) -> pts.El pts.var (P O)) ->
             __1:(m:(pts.El pts.var nat) ->
                  __1:(pts.El pts.var (matita_basics_logic.eq nat x_366 (S m))) ->
                  pts.El pts.var (P (S m))) ->
             pts.El pts.var (P x_366)) =>
     auto:(__:(pts.El pts.var (matita_basics_logic.eq nat (S x_366) O)) -> pts.El pts.var (P O)) =>
     auto':(m:(pts.El pts.var nat) ->
            __:(pts.El pts.var (matita_basics_logic.eq nat (S x_366) (S m))) ->
            pts.El pts.var (P (S m))) =>
     auto' x_366 (matita_basics_logic.refl nat (S x_366)))
    n.

def nat_elim2 :
  R:(__:(pts.El pts.var nat) -> __1:(pts.El pts.var nat) -> pts.U pts.var) ->
  __:(n:(pts.El pts.var nat) -> pts.El pts.var (R O n)) ->
  __1:(n:(pts.El pts.var nat) -> pts.El pts.var (R (S n) O)) ->
  __2:(n:(pts.El pts.var nat) ->
       m:(pts.El pts.var nat) -> __2:(pts.El pts.var (R n m)) -> pts.El pts.var (R (S n) (S m))) ->
  n:(pts.El pts.var nat) -> m:(pts.El pts.var nat) -> pts.El pts.var (R n m)
  :=
  R:(__:(pts.El pts.var nat) -> __1:(pts.El pts.var nat) -> pts.U pts.var) =>
  ROn:(n:(pts.El pts.var nat) -> pts.El pts.var (R O n)) =>
  RSO:(n:(pts.El pts.var nat) -> pts.El pts.var (R (S n) O)) =>
  RSS:(n:(pts.El pts.var nat) ->
       m:(pts.El pts.var nat) -> __:(pts.El pts.var (R n m)) -> pts.El pts.var (R (S n) (S m))) =>
  n:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) =>
     pts.Prod pts.var pts.var nat (m:(pts.El pts.var nat) => R _x_365 m))
    (m:(pts.El pts.var nat) => ROn m)
    (n0:(pts.El pts.var nat) =>
     Rn0m:(m:(pts.El pts.var nat) -> pts.El pts.var (R n0 m)) =>
     m:(pts.El pts.var nat) =>
     match_nat
       pts.var
       (__:(pts.El pts.var nat) => R (S n0) __)
       (RSO n0)
       (auto:(pts.El pts.var nat) => RSS n0 auto (Rn0m auto))
       m)
    n.

def le_gen :
  P:(__:(pts.El pts.var nat) -> pts.U pts.var) ->
  n:(pts.El pts.var nat) ->
  __:(i:(pts.El pts.var nat) -> __:(pts.El pts.var (le i n)) -> pts.El pts.var (P i)) ->
  pts.El pts.var (P n)
  :=
  P:(__:(pts.El pts.var nat) -> pts.U pts.var) =>
  n:(pts.El pts.var nat) =>
  auto:(i:(pts.El pts.var nat) -> __:(pts.El pts.var (le i n)) -> pts.El pts.var (P i)) =>
  auto n (le_n n).

def pred_Sn :
  n:(pts.El pts.var nat) -> pts.El pts.var (matita_basics_logic.eq nat n (pred (S n)))
  :=
  n:(pts.El pts.var nat) => matita_basics_logic.refl nat n.

def injective_S :
  pts.El pts.var (matita_basics_relations.{|injective|} nat nat S)
  :=
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (matita_basics_logic.eq nat (S x) (S y))) =>
  matita_basics_logic.rewrite_l
    nat
    y
    (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ y)
    (matita_basics_logic.refl nat y)
    x
    (matita_basics_logic.rewrite_r
       nat
       (pred (S x))
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat y __)
       (matita_basics_logic.rewrite_r
          nat
          (S y)
          (__:(pts.El pts.var nat) => matita_basics_logic.eq nat y (pred __))
          (pred_Sn y)
          (S x)
          auto)
       x
       (pred_Sn x)).

def S_pred :
  n:(pts.El pts.var nat) ->
  __:(pts.El pts.var (lt O n)) -> pts.El pts.var (matita_basics_logic.eq nat (S (pred n)) n)
  :=
  n:(pts.El pts.var nat) =>
  posn:(pts.El pts.var (lt O n)) =>
  match_le
    (S O)
    pts.var
    (__:(pts.El pts.var nat) =>
     _0:(pts.El pts.var (le (S O) __)) => matita_basics_logic.eq nat (S (pred __)) __)
    (matita_basics_logic.rewrite_l
       nat
       O
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (S __) (S O))
       (matita_basics_logic.refl nat (S O))
       (pred (S O))
       (pred_Sn O))
    (m:(pts.El pts.var nat) =>
     auto:(pts.El pts.var (le (S O) m)) =>
     matita_basics_logic.rewrite_l
       nat
       m
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (S __) (S m))
       (matita_basics_logic.refl nat (S m))
       (pred (S m))
       (pred_Sn m))
    n
    posn.

def plus_O_n :
  n:(pts.El pts.var nat) -> pts.El pts.var (matita_basics_logic.eq nat n (plus O n))
  :=
  n:(pts.El pts.var nat) => matita_basics_logic.refl nat n.

def plus_n_O :
  n:(pts.El pts.var nat) -> pts.El pts.var (matita_basics_logic.eq nat n (plus n O))
  :=
  n:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) => matita_basics_logic.eq nat _x_365 (plus _x_365 O))
    (matita_basics_logic.refl nat O)
    (x_366:(pts.El pts.var nat) =>
     _x_368:(pts.El pts.var (matita_basics_logic.eq nat x_366 (plus x_366 O))) =>
     matita_basics_logic.rewrite_l
       nat
       x_366
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (S x_366) (S __))
       (matita_basics_logic.refl nat (S x_366))
       (plus x_366 O)
       _x_368)
    n.

def plus_n_Sm :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) -> pts.El pts.var (matita_basics_logic.eq nat (S (plus n m)) (plus n (S m)))
  :=
  n:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       nat
       (m:(pts.El pts.var nat) => matita_basics_logic.eq nat (S (plus _x_365 m)) (plus _x_365 (S m))))
    (m:(pts.El pts.var nat) => matita_basics_logic.refl nat (S m))
    (x_366:(pts.El pts.var nat) =>
     _x_368:(m:(pts.El pts.var nat) ->
             pts.El pts.var (matita_basics_logic.eq nat (S (plus x_366 m)) (plus x_366 (S m)))) =>
     m:(pts.El pts.var nat) =>
     matita_basics_logic.rewrite_r
       nat
       (plus x_366 (S m))
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (S __) (S (plus x_366 (S m))))
       (matita_basics_logic.rewrite_r
          nat
          (plus x_366 (S (S m)))
          (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (S (plus x_366 (S m))))
          (matita_basics_logic.rewrite_r
             nat
             (plus x_366 (S (S m)))
             (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (plus x_366 (S (S m))) __)
             (matita_basics_logic.refl nat (plus x_366 (S (S m))))
             (S (plus x_366 (S m)))
             (_x_368 (S m)))
          (S (plus x_366 (S m)))
          (_x_368 (S m)))
       (S (plus x_366 m))
       (_x_368 m))
    n.

def commutative_plus :
  pts.El pts.var (matita_basics_relations.commutative nat plus)
  :=
  n:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       nat
       (y:(pts.El pts.var nat) => matita_basics_logic.eq nat (plus _x_365 y) (plus y _x_365)))
    (y:(pts.El pts.var nat) =>
     matita_basics_logic.rewrite_l
       nat
       y
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat y __)
       (matita_basics_logic.refl nat y)
       (plus y O)
       (plus_n_O y))
    (x_366:(pts.El pts.var nat) =>
     _x_368:(y:(pts.El pts.var nat) ->
             pts.El pts.var (matita_basics_logic.eq nat (plus x_366 y) (plus y x_366))) =>
     y:(pts.El pts.var nat) =>
     matita_basics_logic.rewrite_r
       nat
       (plus x_366 (S y))
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (plus y (S x_366)))
       (matita_basics_logic.rewrite_r
          nat
          (plus y (S x_366))
          (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (plus y (S x_366)))
          (matita_basics_logic.refl nat (plus y (S x_366)))
          (plus x_366 (S y))
          (matita_basics_logic.rewrite_l
             nat
             (S (plus x_366 y))
             (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (plus y (S x_366)))
             (matita_basics_logic.rewrite_r
                nat
                (plus y x_366)
                (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (S __) (plus y (S x_366)))
                (plus_n_Sm y x_366)
                (plus x_366 y)
                (_x_368 y))
             (plus x_366 (S y))
             (plus_n_Sm x_366 y)))
       (S (plus x_366 y))
       (plus_n_Sm x_366 y))
    n.

def associative_plus :
  pts.El pts.var (matita_basics_relations.associative nat plus)
  :=
  n:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       nat
       (y:(pts.El pts.var nat) =>
        pts.Prod
          pts.var
          pts.var
          nat
          (z:(pts.El pts.var nat) =>
           matita_basics_logic.eq nat (plus (plus _x_365 y) z) (plus _x_365 (plus y z)))))
    (y:(pts.El pts.var nat) => z:(pts.El pts.var nat) => matita_basics_logic.refl nat (plus y z))
    (x_366:(pts.El pts.var nat) =>
     _x_368:(y:(pts.El pts.var nat) ->
             z:(pts.El pts.var nat) ->
             pts.El
               pts.var
               (matita_basics_logic.eq nat (plus (plus x_366 y) z) (plus x_366 (plus y z)))) =>
     y:(pts.El pts.var nat) =>
     z:(pts.El pts.var nat) =>
     matita_basics_logic.rewrite_r
       nat
       (plus x_366 (plus y z))
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (S __) (S (plus x_366 (plus y z))))
       (matita_basics_logic.refl nat (S (plus x_366 (plus y z))))
       (plus (plus x_366 y) z)
       (_x_368 y z))
    n.

def assoc_plus1 :
  a:(pts.El pts.var nat) ->
  b:(pts.El pts.var nat) ->
  c:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_logic.eq nat (plus c (plus b a)) (plus (plus b c) a))
  :=
  a:(pts.El pts.var nat) =>
  b:(pts.El pts.var nat) =>
  c:(pts.El pts.var nat) =>
  matita_basics_logic.rewrite_r
    nat
    (plus a b)
    (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (plus c __) (plus (plus b c) a))
    (matita_basics_logic.rewrite_r
       nat
       (plus a (plus b c))
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (plus c (plus a b)) __)
       (matita_basics_logic.rewrite_r
          nat
          (plus a (plus b c))
          (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (plus a (plus b c)))
          (matita_basics_logic.refl nat (plus a (plus b c)))
          (plus c (plus a b))
          (matita_basics_logic.rewrite_l
             nat
             (plus (plus a b) c)
             (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (plus c (plus a b)) __)
             (commutative_plus c (plus a b))
             (plus a (plus b c))
             (associative_plus a b c)))
       (plus (plus b c) a)
       (commutative_plus (plus b c) a))
    (plus b a)
    (commutative_plus b a).

def injective_plus_r :
  n:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_relations.{|injective|} nat nat (m:(pts.El pts.var nat) => plus n m))
  :=
  n:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) =>
     matita_basics_relations.{|injective|} nat nat (m:(pts.El pts.var nat) => plus _x_365 m))
    (x:(pts.El pts.var nat) =>
     y:(pts.El pts.var nat) =>
     auto:(pts.El pts.var (matita_basics_logic.eq nat x y)) =>
     matita_basics_logic.rewrite_l
       nat
       x
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat x __)
       (matita_basics_logic.refl nat x)
       y
       auto)
    (x_366:(pts.El pts.var nat) =>
     _x_368:(x:(pts.El pts.var nat) ->
             y:(pts.El pts.var nat) ->
             __:(pts.El pts.var (matita_basics_logic.eq nat (plus x_366 x) (plus x_366 y))) ->
             pts.El pts.var (matita_basics_logic.eq nat x y)) =>
     x:(pts.El pts.var nat) =>
     y:(pts.El pts.var nat) =>
     auto:(pts.El pts.var (matita_basics_logic.eq nat (S (plus x_366 x)) (S (plus x_366 y)))) =>
     _x_368
       x
       y
       (injective_S
          (plus x_366 x)
          (plus x_366 y)
          (matita_basics_logic.rewrite_r
             nat
             (plus x_366 (S x))
             (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (S (plus x_366 y)))
             (matita_basics_logic.rewrite_r
                nat
                (plus x_366 (S y))
                (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (plus x_366 (S x)) __)
                (matita_basics_logic.rewrite_l
                   nat
                   (plus x_366 (S x))
                   (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (plus x_366 (S x)) __)
                   (matita_basics_logic.refl nat (plus x_366 (S x)))
                   (plus x_366 (S y))
                   (matita_basics_logic.rewrite_l
                      nat
                      (S (plus x_366 y))
                      (__:(pts.El pts.var nat) =>
                       matita_basics_logic.eq nat (plus x_366 (S x)) __)
                      (matita_basics_logic.rewrite_l
                         nat
                         (S (plus x_366 x))
                         (__:(pts.El pts.var nat) =>
                          matita_basics_logic.eq nat __ (S (plus x_366 y)))
                         auto
                         (plus x_366 (S x))
                         (plus_n_Sm x_366 x))
                      (plus x_366 (S y))
                      (plus_n_Sm x_366 y)))
                (S (plus x_366 y))
                (plus_n_Sm x_366 y))
             (S (plus x_366 x))
             (plus_n_Sm x_366 x))))
    n.

def injective_plus_l :
  n:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_relations.{|injective|} nat nat (m:(pts.El pts.var nat) => plus m n))
  :=
  n:(pts.El pts.var nat) =>
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (matita_basics_logic.eq nat (plus x n) (plus y n))) =>
  injective_plus_r
    n
    x
    y
    (matita_basics_logic.rewrite_r
       nat
       (plus n y)
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (plus n y))
       (matita_basics_logic.refl nat (plus n y))
       (plus n x)
       (matita_basics_logic.rewrite_l
          nat
          (plus y n)
          (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (plus n x) __)
          (matita_basics_logic.rewrite_l
             nat
             (plus x n)
             (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (plus y n))
             auto
             (plus n x)
             (commutative_plus x n))
          (plus n y)
          (commutative_plus y n))).

def times_Sn_m :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_logic.eq nat (plus m (times n m)) (times (S n) m))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) => matita_basics_logic.refl nat (plus m (times n m)).

def times_O_n :
  n:(pts.El pts.var nat) -> pts.El pts.var (matita_basics_logic.eq nat O (times O n))
  :=
  n:(pts.El pts.var nat) => matita_basics_logic.refl nat O.

def times_n_O :
  n:(pts.El pts.var nat) -> pts.El pts.var (matita_basics_logic.eq nat O (times n O))
  :=
  n:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) => matita_basics_logic.eq nat O (times _x_365 O))
    (matita_basics_logic.rewrite_l
       nat
       O
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat O __)
       (matita_basics_logic.refl nat O)
       (times O O)
       (times_O_n O))
    (x_366:(pts.El pts.var nat) =>
     _x_368:(pts.El pts.var (matita_basics_logic.eq nat O (times x_366 O))) =>
     matita_basics_logic.rewrite_l
       nat
       (plus O (times x_366 O))
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat O __)
       (matita_basics_logic.rewrite_l
          nat
          O
          (__:(pts.El pts.var nat) => matita_basics_logic.eq nat O (plus O __))
          (matita_basics_logic.rewrite_l
             nat
             O
             (__:(pts.El pts.var nat) => matita_basics_logic.eq nat O __)
             (matita_basics_logic.refl nat O)
             (plus O O)
             (plus_O_n O))
          (times x_366 O)
          _x_368)
       (times (S x_366) O)
       (times_Sn_m x_366 O))
    n.

def times_n_Sm :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_logic.eq nat (plus n (times n m)) (times n (S m)))
  :=
  n:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       nat
       (m:(pts.El pts.var nat) =>
        matita_basics_logic.eq nat (plus _x_365 (times _x_365 m)) (times _x_365 (S m))))
    (_m:(pts.El pts.var nat) => matita_basics_logic.refl nat O)
    (x_366:(pts.El pts.var nat) =>
     _x_368:(m:(pts.El pts.var nat) ->
             pts.El
               pts.var
               (matita_basics_logic.eq nat (plus x_366 (times x_366 m)) (times x_366 (S m)))) =>
     m:(pts.El pts.var nat) =>
     matita_basics_logic.rewrite_r
       nat
       (plus x_366 (S (plus m (times x_366 m))))
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (S (plus m (times x_366 (S m)))))
       (matita_basics_logic.rewrite_r
          nat
          (plus m (S (times x_366 m)))
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq nat (plus x_366 __) (S (plus m (times x_366 (S m)))))
          (matita_basics_logic.rewrite_l
             nat
             (plus x_366 (times x_366 m))
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq nat (plus x_366 (plus m (S (times x_366 m)))) (S (plus m __)))
             (matita_basics_logic.rewrite_r
                nat
                (plus x_366 (plus m (times x_366 m)))
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq nat (plus x_366 (plus m (S (times x_366 m)))) (S __))
                (matita_basics_logic.rewrite_r
                   nat
                   (plus x_366 (S (plus m (times x_366 m))))
                   (__:(pts.El pts.var nat) =>
                    matita_basics_logic.eq nat (plus x_366 (plus m (S (times x_366 m)))) __)
                   (matita_basics_logic.rewrite_r
                      nat
                      (plus m (S (times x_366 m)))
                      (__:(pts.El pts.var nat) =>
                       matita_basics_logic.eq
                         nat
                         (plus x_366 (plus m (S (times x_366 m))))
                         (plus x_366 __))
                      (matita_basics_logic.refl nat (plus x_366 (plus m (S (times x_366 m)))))
                      (S (plus m (times x_366 m)))
                      (plus_n_Sm m (times x_366 m)))
                   (S (plus x_366 (plus m (times x_366 m))))
                   (plus_n_Sm x_366 (plus m (times x_366 m))))
                (plus m (plus x_366 (times x_366 m)))
                (matita_basics_logic.rewrite_l
                   nat
                   (plus (plus x_366 m) (times x_366 m))
                   (__:(pts.El pts.var nat) =>
                    matita_basics_logic.eq nat (plus m (plus x_366 (times x_366 m))) __)
                   (assoc_plus1 (times x_366 m) x_366 m)
                   (plus x_366 (plus m (times x_366 m)))
                   (associative_plus x_366 m (times x_366 m))))
             (times x_366 (S m))
             (_x_368 m))
          (S (plus m (times x_366 m)))
          (plus_n_Sm m (times x_366 m)))
       (S (plus x_366 (plus m (times x_366 m))))
       (plus_n_Sm x_366 (plus m (times x_366 m))))
    n.

def commutative_times :
  pts.El pts.var (matita_basics_relations.commutative nat times)
  :=
  n:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       nat
       (y:(pts.El pts.var nat) => matita_basics_logic.eq nat (times _x_365 y) (times y _x_365)))
    (y:(pts.El pts.var nat) =>
     matita_basics_logic.rewrite_l
       nat
       O
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat O __)
       (matita_basics_logic.refl nat O)
       (times y O)
       (times_n_O y))
    (x_366:(pts.El pts.var nat) =>
     _x_368:(y:(pts.El pts.var nat) ->
             pts.El pts.var (matita_basics_logic.eq nat (times x_366 y) (times y x_366))) =>
     y:(pts.El pts.var nat) =>
     matita_basics_logic.rewrite_l
       nat
       (plus y (times y x_366))
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (plus y (times x_366 y)) __)
       (matita_basics_logic.rewrite_l
          nat
          (times x_366 y)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq nat (plus y (times x_366 y)) (plus y __))
          (matita_basics_logic.refl nat (plus y (times x_366 y)))
          (times y x_366)
          (_x_368 y))
       (times y (S x_366))
       (times_n_Sm y x_366))
    n.

def distributive_times_plus :
  pts.El pts.var (matita_basics_relations.distributive nat times plus)
  :=
  n:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       nat
       (y:(pts.El pts.var nat) =>
        pts.Prod
          pts.var
          pts.var
          nat
          (z:(pts.El pts.var nat) =>
           matita_basics_logic.eq
             nat
             (times _x_365 (plus y z))
             (plus (times _x_365 y) (times _x_365 z)))))
    (_y:(pts.El pts.var nat) => _z:(pts.El pts.var nat) => matita_basics_logic.refl nat O)
    (x_366:(pts.El pts.var nat) =>
     _x_368:(y:(pts.El pts.var nat) ->
             z:(pts.El pts.var nat) ->
             pts.El
               pts.var
               (matita_basics_logic.eq
                  nat
                  (times x_366 (plus y z))
                  (plus (times x_366 y) (times x_366 z)))) =>
     y:(pts.El pts.var nat) =>
     z:(pts.El pts.var nat) =>
     matita_basics_logic.rewrite_r
       nat
       (plus y (plus z (times x_366 (plus y z))))
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq nat __ (plus (plus y (times x_366 y)) (plus z (times x_366 z))))
       (matita_basics_logic.rewrite_r
          nat
          (plus y (plus (times x_366 y) (plus z (times x_366 z))))
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq nat (plus y (plus z (times x_366 (plus y z)))) __)
          (matita_basics_logic.rewrite_r
             nat
             (plus z (plus (times x_366 y) (times x_366 z)))
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq nat (plus y (plus z (times x_366 (plus y z)))) (plus y __))
             (matita_basics_logic.rewrite_l
                nat
                (times x_366 (plus y z))
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq
                   nat
                   (plus y (plus z (times x_366 (plus y z))))
                   (plus y (plus z __)))
                (matita_basics_logic.refl nat (plus y (plus z (times x_366 (plus y z)))))
                (plus (times x_366 y) (times x_366 z))
                (_x_368 y z))
             (plus (times x_366 y) (plus z (times x_366 z)))
             (matita_basics_logic.rewrite_l
                nat
                (plus (plus z (times x_366 y)) (times x_366 z))
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq nat (plus (times x_366 y) (plus z (times x_366 z))) __)
                (assoc_plus1 (times x_366 z) z (times x_366 y))
                (plus z (plus (times x_366 y) (times x_366 z)))
                (associative_plus z (times x_366 y) (times x_366 z))))
          (plus (plus y (times x_366 y)) (plus z (times x_366 z)))
          (associative_plus y (times x_366 y) (plus z (times x_366 z))))
       (plus (plus y z) (times x_366 (plus y z)))
       (associative_plus y z (times x_366 (plus y z))))
    n.

def distributive_times_plus_r :
  a:(pts.El pts.var nat) ->
  b:(pts.El pts.var nat) ->
  c:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_logic.eq nat (times (plus b c) a) (plus (times b a) (times c a)))
  :=
  a:(pts.El pts.var nat) =>
  b:(pts.El pts.var nat) =>
  c:(pts.El pts.var nat) =>
  matita_basics_logic.rewrite_r
    nat
    (times a (plus b c))
    (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (plus (times b a) (times c a)))
    (matita_basics_logic.rewrite_r
       nat
       (times a b)
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq nat (times a (plus b c)) (plus __ (times c a)))
       (matita_basics_logic.rewrite_r
          nat
          (times a c)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq nat (times a (plus b c)) (plus (times a b) __))
          (matita_basics_logic.rewrite_l
             nat
             (times a (plus b c))
             (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (times a (plus b c)) __)
             (matita_basics_logic.refl nat (times a (plus b c)))
             (plus (times a b) (times a c))
             (distributive_times_plus a b c))
          (times c a)
          (commutative_times c a))
       (times b a)
       (commutative_times b a))
    (times (plus b c) a)
    (commutative_times (plus b c) a).

def associative_times :
  pts.El pts.var (matita_basics_relations.associative nat times)
  :=
  n:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       nat
       (y:(pts.El pts.var nat) =>
        pts.Prod
          pts.var
          pts.var
          nat
          (z:(pts.El pts.var nat) =>
           matita_basics_logic.eq nat (times (times _x_365 y) z) (times _x_365 (times y z)))))
    (_y:(pts.El pts.var nat) => _z:(pts.El pts.var nat) => matita_basics_logic.refl nat O)
    (x_366:(pts.El pts.var nat) =>
     _x_368:(y:(pts.El pts.var nat) ->
             z:(pts.El pts.var nat) ->
             pts.El
               pts.var
               (matita_basics_logic.eq nat (times (times x_366 y) z) (times x_366 (times y z)))) =>
     y:(pts.El pts.var nat) =>
     z:(pts.El pts.var nat) =>
     matita_basics_logic.rewrite_r
       nat
       (plus (times y z) (times x_366 (times y z)))
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq nat __ (plus (times y z) (times x_366 (times y z))))
       (matita_basics_logic.refl nat (plus (times y z) (times x_366 (times y z))))
       (times (plus y (times x_366 y)) z)
       (matita_basics_logic.rewrite_l
          nat
          (times (times x_366 y) z)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq nat (times (plus y (times x_366 y)) z) (plus (times y z) __))
          (distributive_times_plus_r z y (times x_366 y))
          (times x_366 (times y z))
          (_x_368 y z)))
    n.

def times_times :
  x:(pts.El pts.var nat) ->
  y:(pts.El pts.var nat) ->
  z:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_logic.eq nat (times x (times y z)) (times y (times x z)))
  :=
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  z:(pts.El pts.var nat) =>
  matita_basics_logic.rewrite_r
    nat
    (times y (times x z))
    (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (times y (times x z)))
    (matita_basics_logic.refl nat (times y (times x z)))
    (times x (times y z))
    (matita_basics_logic.rewrite_l
       nat
       (times (times x y) z)
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (times y (times x z)))
       (matita_basics_logic.rewrite_l
          nat
          (times y x)
          (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (times __ z) (times y (times x z)))
          (associative_times y x z)
          (times x y)
          (commutative_times y x))
       (times x (times y z))
       (associative_times x y z)).

def times_n_1 :
  n:(pts.El pts.var nat) -> pts.El pts.var (matita_basics_logic.eq nat n (times n (S O)))
  :=
  n:(pts.El pts.var nat) =>
  matita_basics_logic.rewrite_l
    nat
    (plus n (times n O))
    (__:(pts.El pts.var nat) => matita_basics_logic.eq nat n __)
    (matita_basics_logic.rewrite_l
       nat
       O
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat n (plus n __))
       (matita_basics_logic.rewrite_l
          nat
          n
          (__:(pts.El pts.var nat) => matita_basics_logic.eq nat n __)
          (matita_basics_logic.refl nat n)
          (plus n O)
          (plus_n_O n))
       (times n O)
       (times_n_O n))
    (times n (S O))
    (times_n_Sm n O).

def minus_S_S :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_logic.eq nat (minus (S n) (S m)) (minus n m))
  :=
  n:(pts.El pts.var nat) => m:(pts.El pts.var nat) => matita_basics_logic.refl nat (minus (S n) (S m)).

def minus_O_n :
  n:(pts.El pts.var nat) -> pts.El pts.var (matita_basics_logic.eq nat O (minus O n))
  :=
  n:(pts.El pts.var nat) =>
  match_nat
    pts.var
    (__:(pts.El pts.var nat) => matita_basics_logic.eq nat O (minus O __))
    (matita_basics_logic.refl nat O)
    (auto:(pts.El pts.var nat) => matita_basics_logic.refl nat O)
    n.

def minus_n_O :
  n:(pts.El pts.var nat) -> pts.El pts.var (matita_basics_logic.eq nat n (minus n O))
  :=
  n:(pts.El pts.var nat) =>
  match_nat
    pts.var
    (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (minus __ O))
    (matita_basics_logic.rewrite_l
       nat
       O
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat O __)
       (matita_basics_logic.refl nat O)
       (minus O O)
       (minus_O_n O))
    (auto:(pts.El pts.var nat) => matita_basics_logic.refl nat (S auto))
    n.

def minus_n_n :
  n:(pts.El pts.var nat) -> pts.El pts.var (matita_basics_logic.eq nat O (minus n n))
  :=
  n:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) => matita_basics_logic.eq nat O (minus _x_365 _x_365))
    (matita_basics_logic.rewrite_l
       nat
       O
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat O __)
       (matita_basics_logic.refl nat O)
       (minus O O)
       (minus_O_n O))
    (x_366:(pts.El pts.var nat) =>
     _x_368:(pts.El pts.var (matita_basics_logic.eq nat O (minus x_366 x_366))) =>
     matita_basics_logic.rewrite_r
       nat
       (minus x_366 x_366)
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat O __)
       (matita_basics_logic.rewrite_l
          nat
          O
          (__:(pts.El pts.var nat) => matita_basics_logic.eq nat O __)
          (matita_basics_logic.refl nat O)
          (minus x_366 x_366)
          _x_368)
       (minus (S x_366) (S x_366))
       (minus_S_S x_366 x_366))
    n.

def minus_Sn_n :
  n:(pts.El pts.var nat) -> pts.El pts.var (matita_basics_logic.eq nat (S O) (minus (S n) n))
  :=
  n:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) => matita_basics_logic.eq nat (S O) (minus (S _x_365) _x_365))
    (matita_basics_logic.refl nat (S O))
    (x_366:(pts.El pts.var nat) =>
     _x_368:(pts.El
               pts.var
               (matita_basics_logic.eq
                  nat
                  (S O)
                  (match_nat
                     pts.var
                     (__:(pts.El pts.var nat) => nat)
                     (S x_366)
                     (q:(pts.El pts.var nat) => minus x_366 q)
                     x_366))) =>
     matita_basics_logic.rewrite_r
       nat
       (match_nat
          pts.var
          (__:(pts.El pts.var nat) => nat)
          (S x_366)
          (q:(pts.El pts.var nat) => minus x_366 q)
          x_366)
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq
          nat
          __
          (match_nat
             pts.var
             (__1:(pts.El pts.var nat) => nat)
             (S x_366)
             (q:(pts.El pts.var nat) => minus x_366 q)
             x_366))
       (matita_basics_logic.refl
          nat
          (match_nat
             pts.var
             (__:(pts.El pts.var nat) => nat)
             (S x_366)
             (q:(pts.El pts.var nat) => minus x_366 q)
             x_366))
       (S O)
       _x_368)
    n.

def eq_minus_S_pred :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_logic.eq nat (minus n (S m)) (pred (minus n m)))
  :=
  nat_elim2
    (__:(pts.El pts.var nat) =>
     _0:(pts.El pts.var nat) => matita_basics_logic.eq nat (minus __ (S _0)) (pred (minus __ _0)))
    (_n:(pts.El pts.var nat) => matita_basics_logic.refl nat O)
    (n:(pts.El pts.var nat) =>
     matita_basics_logic.rewrite_l
       nat
       n
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ n)
       (matita_basics_logic.refl nat n)
       (minus n O)
       (minus_n_O n))
    (n:(pts.El pts.var nat) =>
     m:(pts.El pts.var nat) =>
     auto:(pts.El
             pts.var
             (matita_basics_logic.eq
                nat
                (minus n (S m))
                (match_nat
                   pts.var
                   (__:(pts.El pts.var nat) => nat)
                   O
                   (p:(pts.El pts.var nat) => p)
                   (minus n m)))) =>
     matita_basics_logic.rewrite_r
       nat
       (match_nat
          pts.var
          (__:(pts.El pts.var nat) => nat)
          O
          (p:(pts.El pts.var nat) => p)
          (minus n m))
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq
          nat
          __
          (match_nat
             pts.var
             (_0:(pts.El pts.var nat) => nat)
             O
             (p:(pts.El pts.var nat) => p)
             (minus n m)))
       (matita_basics_logic.refl
          nat
          (match_nat
             pts.var
             (__:(pts.El pts.var nat) => nat)
             O
             (p:(pts.El pts.var nat) => p)
             (minus n m)))
       (minus n (S m))
       auto).

def let_clause_73 :
  x:(pts.El pts.var nat) ->
  y:(pts.El pts.var nat) ->
  z:(pts.El pts.var nat) ->
  x134:(pts.El pts.var nat) ->
  x135:(pts.El pts.var nat) ->
  x136:(pts.El pts.var nat) ->
  pts.El
    pts.var
    (matita_basics_logic.eq nat (plus x134 (plus x135 x136)) (plus x135 (plus x134 x136)))
  :=
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  z:(pts.El pts.var nat) =>
  x134:(pts.El pts.var nat) =>
  x135:(pts.El pts.var nat) =>
  x136:(pts.El pts.var nat) =>
  matita_basics_logic.rewrite_l
    nat
    (plus (plus x135 x134) x136)
    (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (plus x134 (plus x135 x136)) __)
    (assoc_plus1 x136 x135 x134)
    (plus x135 (plus x134 x136))
    (associative_plus x135 x134 x136).

def plus_plus_comm_23 :
  x:(pts.El pts.var nat) ->
  y:(pts.El pts.var nat) ->
  z:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_logic.eq nat (plus (plus x y) z) (plus (plus x z) y))
  :=
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  z:(pts.El pts.var nat) =>
  matita_basics_logic.rewrite_r
    nat
    (plus z (plus x y))
    (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (plus (plus x z) y))
    (matita_basics_logic.rewrite_r
       nat
       (plus x (plus z y))
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (plus (plus x z) y))
       (matita_basics_logic.rewrite_r
          nat
          (plus y z)
          (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (plus x __) (plus (plus x z) y))
          (matita_basics_logic.rewrite_r
             nat
             (plus y (plus x z))
             (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (plus x (plus y z)) __)
             (matita_basics_logic.rewrite_r
                nat
                (plus x (plus y z))
                (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (plus x (plus y z)) __)
                (matita_basics_logic.refl nat (plus x (plus y z)))
                (plus y (plus x z))
                (let_clause_73 x y z y x z))
             (plus (plus x z) y)
             (commutative_plus (plus x z) y))
          (plus z y)
          (commutative_plus z y))
       (plus z (plus x y))
       (let_clause_73 x y z z x y))
    (plus (plus x y) z)
    (commutative_plus (plus x y) z).

def discr_plus_xy_minus_xz :
  x:(pts.El pts.var nat) ->
  z:(pts.El pts.var nat) ->
  y:(pts.El pts.var nat) ->
  __:(pts.El pts.var (matita_basics_logic.eq nat (plus x y) (minus x z))) ->
  pts.El pts.var (matita_basics_logic.eq nat y O)
  :=
  x:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       nat
       (z:(pts.El pts.var nat) =>
        pts.Prod
          pts.var
          pts.var
          nat
          (y:(pts.El pts.var nat) =>
           pts.Prod
             pts.var
             pts.var
             (matita_basics_logic.eq nat (plus _x_365 y) (minus _x_365 z))
             (__:(pts.El pts.var (matita_basics_logic.eq nat (plus _x_365 y) (minus _x_365 z))) =>
              matita_basics_logic.eq nat y O))))
    (z:(pts.El pts.var nat) =>
     y:(pts.El pts.var nat) =>
     auto:(pts.El pts.var (matita_basics_logic.eq nat (plus O y) (minus O z))) =>
     matita_basics_logic.rewrite_l
       nat
       y
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat y __)
       (matita_basics_logic.refl nat y)
       O
       (matita_basics_logic.rewrite_r
          nat
          (minus O z)
          (__:(pts.El pts.var nat) => matita_basics_logic.eq nat y __)
          (matita_basics_logic.rewrite_r
             nat
             (plus y O)
             (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (minus O z))
             (matita_basics_logic.rewrite_l
                nat
                (plus O y)
                (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (minus O z))
                auto
                (plus y O)
                (commutative_plus O y))
             y
             (plus_n_O y))
          O
          (minus_O_n z)))
    (x0:(pts.El pts.var nat) =>
     IHx:(z:(pts.El pts.var nat) ->
          y:(pts.El pts.var nat) ->
          __:(pts.El pts.var (matita_basics_logic.eq nat (plus x0 y) (minus x0 z))) ->
          pts.El pts.var (matita_basics_logic.eq nat y O)) =>
     _clearme:(pts.El pts.var nat) =>
     match_nat
       pts.var
       (__:(pts.El pts.var nat) =>
        pts.Prod
          pts.var
          pts.var
          nat
          (y:(pts.El pts.var nat) =>
           pts.Prod
             pts.var
             pts.var
             (matita_basics_logic.eq nat (plus (S x0) y) (minus (S x0) __))
             (__1:(pts.El
                     pts.var
                     (matita_basics_logic.eq nat (plus (S x0) y) (minus (S x0) __))) =>
              matita_basics_logic.eq nat y O)))
       (y:(pts.El pts.var nat) =>
        H:(pts.El pts.var (matita_basics_logic.eq nat (S (plus x0 y)) (S x0))) =>
        IHx
          O
          y
          (matita_basics_logic.eq_ind
             nat
             x0
             (x_1:(pts.El pts.var nat) =>
              _x_2:(pts.El pts.var (matita_basics_logic.eq nat x0 x_1)) =>
              matita_basics_logic.eq nat (plus x0 y) x_1)
             (injective_S
                (plus x0 y)
                x0
                (matita_basics_logic.rewrite_r
                   nat
                   (plus x0 (S y))
                   (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (S x0))
                   (matita_basics_logic.rewrite_r
                      nat
                      (S x0)
                      (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (S x0))
                      (matita_basics_logic.refl nat (S x0))
                      (plus x0 (S y))
                      (matita_basics_logic.rewrite_l
                         nat
                         (S (plus x0 y))
                         (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (S x0))
                         H
                         (plus x0 (S y))
                         (plus_n_Sm x0 y)))
                   (S (plus x0 y))
                   (plus_n_Sm x0 y)))
             (minus x0 O)
             (minus_n_O x0)))
       (z:(pts.El pts.var nat) =>
        y:(pts.El pts.var nat) =>
        matita_basics_logic.eq_ind_r
          nat
          (plus x0 (S y))
          (x1:(pts.El pts.var nat) =>
           __:(pts.El pts.var (matita_basics_logic.eq nat x1 (plus x0 (S y)))) =>
           pts.Prod
             pts.var
             pts.var
             (matita_basics_logic.eq nat x1 (minus x0 z))
             (__1:(pts.El pts.var (matita_basics_logic.eq nat x1 (minus x0 z))) =>
              matita_basics_logic.eq nat y O))
          (H:(pts.El pts.var (matita_basics_logic.eq nat (plus x0 (S y)) (minus x0 z))) =>
           nat_discr (S y) O (IHx z (S y) H) (matita_basics_logic.eq nat y O))
          (S (plus x0 y))
          (plus_n_Sm x0 y))
       _clearme)
    x.

def not_eq_S :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (matita_basics_logic.Not (matita_basics_logic.eq nat n m))) ->
  pts.El pts.var (matita_basics_logic.Not (matita_basics_logic.eq nat (S n) (S m)))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (matita_basics_logic.Not (matita_basics_logic.eq nat n m))) =>
  matita_basics_logic.not_to_not
    (matita_basics_logic.eq nat (S n) (S m))
    (matita_basics_logic.eq nat n m)
    (auto':(pts.El pts.var (matita_basics_logic.eq nat (S n) (S m))) =>
     matita_basics_logic.rewrite_l
       nat
       m
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ m)
       (matita_basics_logic.refl nat m)
       n
       (matita_basics_logic.rewrite_r
          nat
          (pred (S n))
          (__:(pts.El pts.var nat) => matita_basics_logic.eq nat m __)
          (matita_basics_logic.rewrite_r
             nat
             (S m)
             (__:(pts.El pts.var nat) => matita_basics_logic.eq nat m (pred __))
             (pred_Sn m)
             (S n)
             auto')
          n
          (pred_Sn n)))
    auto.

def not_eq_O_S :
  n:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_logic.Not (matita_basics_logic.eq nat O (S n)))
  :=
  n:(pts.El pts.var nat) =>
  matita_basics_logic.nmk
    (matita_basics_logic.eq nat O (S n))
    (eqOS:(pts.El pts.var (matita_basics_logic.eq nat O (S n))) =>
     matita_basics_logic.eq_ind_r
       nat
       (S n)
       (x:(pts.El pts.var nat) =>
        __:(pts.El pts.var (matita_basics_logic.eq nat x (S n))) => not_zero x)
       matita_basics_logic.I
       O
       eqOS).

def not_eq_n_Sn :
  n:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_logic.Not (matita_basics_logic.eq nat n (S n)))
  :=
  n:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) =>
     matita_basics_logic.Not (matita_basics_logic.eq nat _x_365 (S _x_365)))
    (not_eq_O_S O)
    (x_366:(pts.El pts.var nat) =>
     _x_368:(pts.El pts.var (matita_basics_logic.Not (matita_basics_logic.eq nat x_366 (S x_366)))) =>
     not_eq_S x_366 (S x_366) _x_368)
    n.

def lt_to_not_zero :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) -> __:(pts.El pts.var (lt n m)) -> pts.El pts.var (not_zero m)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  Hlt:(pts.El pts.var (lt n m)) =>
  le_ind
    (S n)
    (x_417:(pts.El pts.var nat) => _x_418:(pts.El pts.var (le (S n) x_417)) => not_zero x_417)
    matita_basics_logic.I
    (m0:(pts.El pts.var nat) =>
     _x_419:(pts.El pts.var (le (S n) m0)) =>
     _x_421:(pts.El pts.var (not_zero m0)) => matita_basics_logic.I)
    m
    Hlt.

def le_S_S :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) -> __:(pts.El pts.var (le n m)) -> pts.El pts.var (le (S n) (S m))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  lenm:(pts.El pts.var (le n m)) =>
  le_ind
    n
    (x_417:(pts.El pts.var nat) => _x_418:(pts.El pts.var (le n x_417)) => le (S n) (S x_417))
    (le_n (S n))
    (m0:(pts.El pts.var nat) =>
     _x_419:(pts.El pts.var (le n m0)) =>
     _x_421:(pts.El pts.var (le (S n) (S m0))) => le_S (S n) (S m0) _x_421)
    m
    lenm.

def le_O_n :
  n:(pts.El pts.var nat) -> pts.El pts.var (le O n)
  :=
  n:(pts.El pts.var nat) =>
  nat_ind
    (le O)
    (le_n O)
    (x_366:(pts.El pts.var nat) => _x_368:(pts.El pts.var (le O x_366)) => le_S O x_366 _x_368)
    n.

def le_n_Sn :
  n:(pts.El pts.var nat) -> pts.El pts.var (le n (S n))
  :=
  n:(pts.El pts.var nat) => le_S n n (le_n n).

def transitive_le :
  pts.El pts.var (matita_basics_relations.transitive nat le)
  :=
  a:(pts.El pts.var nat) =>
  b:(pts.El pts.var nat) =>
  c:(pts.El pts.var nat) =>
  leab:(pts.El pts.var (le a b)) =>
  lebc:(pts.El pts.var (le b c)) =>
  le_ind
    b
    (x_417:(pts.El pts.var nat) => _x_418:(pts.El pts.var (le b x_417)) => le a x_417)
    leab
    (m:(pts.El pts.var nat) =>
     _x_419:(pts.El pts.var (le b m)) => _x_421:(pts.El pts.var (le a m)) => le_S a m _x_421)
    c
    lebc.

def le_pred_n :
  n:(pts.El pts.var nat) -> pts.El pts.var (le (pred n) n)
  :=
  n:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) => le (pred _x_365) _x_365)
    (le_n (pred O))
    (x_366:(pts.El pts.var nat) =>
     _x_368:(pts.El pts.var (le (pred x_366) x_366)) => le_n_Sn (pred (S x_366)))
    n.

def monotonic_pred :
  pts.El pts.var (matita_basics_relations.monotonic nat le pred)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  lenm:(pts.El pts.var (le n m)) =>
  le_ind
    n
    (x_417:(pts.El pts.var nat) => _x_418:(pts.El pts.var (le n x_417)) => le (pred n) (pred x_417))
    (le_n (pred n))
    (m0:(pts.El pts.var nat) =>
     _x_419:(pts.El pts.var (le n m0)) =>
     _x_421:(pts.El pts.var (le (pred n) (pred m0))) =>
     transitive_le (pred n) n (pred (S m0)) (le_pred_n n) _x_419)
    m
    lenm.

def le_S_S_to_le :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) -> __:(pts.El pts.var (le (S n) (S m))) -> pts.El pts.var (le n m)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (le (S n) (S m))) =>
  matita_basics_logic.eq_coerc
    (le (pred (S n)) (pred (S m)))
    (le n m)
    (monotonic_pred (S n) (S m) auto)
    (matita_basics_logic.rewrite_l
       nat
       n
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq (pts.u pts.var) (le __ (pred (S m))) (le n m))
       (matita_basics_logic.rewrite_l
          nat
          m
          (__:(pts.El pts.var nat) => matita_basics_logic.eq (pts.u pts.var) (le n __) (le n m))
          (matita_basics_logic.refl (pts.u pts.var) (le n m))
          (pred (S m))
          (pred_Sn m))
       (pred (S n))
       (pred_Sn n)).

def monotonic_le_plus_r :
  n:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_relations.monotonic nat le (m:(pts.El pts.var nat) => plus n m))
  :=
  n:(pts.El pts.var nat) =>
  a:(pts.El pts.var nat) =>
  b:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       (le a b)
       (__:(pts.El pts.var (le a b)) => le (plus _x_365 a) (plus _x_365 b)))
    (auto:(pts.El pts.var (le a b)) => auto)
    (m:(pts.El pts.var nat) =>
     H:(__:(pts.El pts.var (le a b)) -> pts.El pts.var (le (plus m a) (plus m b))) =>
     leab:(pts.El pts.var (le a b)) => le_S_S (plus m a) (plus m b) (H leab))
    n.

def monotonic_le_plus_l :
  m:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_relations.monotonic nat le (n:(pts.El pts.var nat) => plus n m))
  :=
  m:(pts.El pts.var nat) =>
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (le x y)) =>
  matita_basics_logic.eq_coerc
    (le (plus m x) (plus m y))
    (le (plus x m) (plus y m))
    (monotonic_le_plus_r m x y auto)
    (matita_basics_logic.rewrite_r
       nat
       (plus m x)
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq (pts.u pts.var) (le (plus m x) (plus m y)) (le __ (plus y m)))
       (matita_basics_logic.rewrite_r
          nat
          (plus m y)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq (pts.u pts.var) (le (plus m x) (plus m y)) (le (plus m x) __))
          (matita_basics_logic.refl (pts.u pts.var) (le (plus m x) (plus m y)))
          (plus y m)
          (commutative_plus y m))
       (plus x m)
       (commutative_plus x m)).

def le_plus :
  n1:(pts.El pts.var nat) ->
  n2:(pts.El pts.var nat) ->
  m1:(pts.El pts.var nat) ->
  m2:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le n1 n2)) ->
  __1:(pts.El pts.var (le m1 m2)) -> pts.El pts.var (le (plus n1 m1) (plus n2 m2))
  :=
  n1:(pts.El pts.var nat) =>
  n2:(pts.El pts.var nat) =>
  m1:(pts.El pts.var nat) =>
  m2:(pts.El pts.var nat) =>
  len:(pts.El pts.var (le n1 n2)) =>
  lem:(pts.El pts.var (le m1 m2)) =>
  transitive_le
    (plus n1 m1)
    (plus n1 m2)
    (plus n2 m2)
    (monotonic_le_plus_r n1 m1 m2 lem)
    (monotonic_le_plus_l m2 n1 n2 len).

def le_plus_n :
  n:(pts.El pts.var nat) -> m:(pts.El pts.var nat) -> pts.El pts.var (le m (plus n m))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  matita_basics_logic.eq_coerc
    (le (plus O m) (plus n m))
    (le m (plus n m))
    (monotonic_le_plus_l m O n (le_O_n n))
    (matita_basics_logic.rewrite_l
       nat
       m
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq (pts.u pts.var) (le __ (plus n m)) (le m (plus n m)))
       (matita_basics_logic.refl (pts.u pts.var) (le m (plus n m)))
       (plus O m)
       (plus_O_n m)).

def le_plus_a :
  a:(pts.El pts.var nat) ->
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) -> __:(pts.El pts.var (le n m)) -> pts.El pts.var (le n (plus a m))
  :=
  a:(pts.El pts.var nat) =>
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (le n m)) =>
  matita_basics_logic.eq_coerc
    (le (plus O n) (plus a m))
    (le n (plus a m))
    (le_plus O a n m (le_O_n a) auto)
    (matita_basics_logic.rewrite_l
       nat
       n
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq (pts.u pts.var) (le __ (plus a m)) (le n (plus a m)))
       (matita_basics_logic.refl (pts.u pts.var) (le n (plus a m)))
       (plus O n)
       (plus_O_n n)).

def le_plus_b :
  b:(pts.El pts.var nat) ->
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) -> __:(pts.El pts.var (le (plus n b) m)) -> pts.El pts.var (le n m)
  :=
  b:(pts.El pts.var nat) =>
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (le (plus n b) m)) =>
  transitive_le
    n
    (plus n b)
    m
    (matita_basics_logic.eq_coerc
       (le n (plus b n))
       (le n (plus n b))
       (le_plus_n b n)
       (matita_basics_logic.rewrite_r
          nat
          (plus b n)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq (pts.u pts.var) (le n (plus b n)) (le n __))
          (matita_basics_logic.refl (pts.u pts.var) (le n (plus b n)))
          (plus n b)
          (commutative_plus n b)))
    auto.

def le_plus_n_r :
  n:(pts.El pts.var nat) -> m:(pts.El pts.var nat) -> pts.El pts.var (le m (plus m n))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  matita_basics_logic.eq_coerc
    (le m (plus n m))
    (le m (plus m n))
    (le_plus_n n m)
    (matita_basics_logic.rewrite_r
       nat
       (plus n m)
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq (pts.u pts.var) (le m (plus n m)) (le m __))
       (matita_basics_logic.refl (pts.u pts.var) (le m (plus n m)))
       (plus m n)
       (commutative_plus m n)).

def eq_plus_to_le :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  p:(pts.El pts.var nat) ->
  __:(pts.El pts.var (matita_basics_logic.eq nat n (plus m p))) -> pts.El pts.var (le m n)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  p:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (matita_basics_logic.eq nat n (plus m p))) =>
  matita_basics_logic.eq_coerc
    (le m (plus m p))
    (le m n)
    (le_plus_n_r p m)
    (matita_basics_logic.rewrite_l
       nat
       n
       (__:(pts.El pts.var nat) => matita_basics_logic.eq (pts.u pts.var) (le m __) (le m n))
       (matita_basics_logic.refl (pts.u pts.var) (le m n))
       (plus m p)
       auto).

def le_plus_to_le :
  a:(pts.El pts.var nat) ->
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) -> __:(pts.El pts.var (le (plus a n) (plus a m))) -> pts.El pts.var (le n m)
  :=
  a:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       nat
       (n:(pts.El pts.var nat) =>
        pts.Prod
          pts.var
          pts.var
          nat
          (m:(pts.El pts.var nat) =>
           pts.Prod
             pts.var
             pts.var
             (le (plus _x_365 n) (plus _x_365 m))
             (__:(pts.El pts.var (le (plus _x_365 n) (plus _x_365 m))) => le n m))))
    (n:(pts.El pts.var nat) => m:(pts.El pts.var nat) => auto:(pts.El pts.var (le n m)) => auto)
    (x_366:(pts.El pts.var nat) =>
     _x_368:(n:(pts.El pts.var nat) ->
             m:(pts.El pts.var nat) ->
             __:(pts.El pts.var (le (plus x_366 n) (plus x_366 m))) -> pts.El pts.var (le n m)) =>
     n:(pts.El pts.var nat) =>
     m:(pts.El pts.var nat) =>
     auto:(pts.El pts.var (le (S (plus x_366 n)) (S (plus x_366 m)))) =>
     matita_basics_logic.eq_coerc
       (le (pred (S n)) (pred (S m)))
       (le n m)
       (monotonic_pred
          (S n)
          (S m)
          (_x_368
             (S n)
             (S m)
             (matita_basics_logic.eq_coerc
                (le (S (plus x_366 n)) (S (plus x_366 m)))
                (le (plus x_366 (S n)) (plus x_366 (S m)))
                auto
                (matita_basics_logic.rewrite_r
                   nat
                   (plus x_366 (S n))
                   (__:(pts.El pts.var nat) =>
                    matita_basics_logic.eq
                      (pts.u pts.var)
                      (le __ (S (plus x_366 m)))
                      (le (plus x_366 (S n)) (plus x_366 (S m))))
                   (matita_basics_logic.rewrite_r
                      nat
                      (plus x_366 (S m))
                      (__:(pts.El pts.var nat) =>
                       matita_basics_logic.eq
                         (pts.u pts.var)
                         (le (plus x_366 (S n)) __)
                         (le (plus x_366 (S n)) (plus x_366 (S m))))
                      (matita_basics_logic.refl
                         (pts.u pts.var)
                         (le (plus x_366 (S n)) (plus x_366 (S m))))
                      (S (plus x_366 m))
                      (plus_n_Sm x_366 m))
                   (S (plus x_366 n))
                   (plus_n_Sm x_366 n)))))
       (matita_basics_logic.rewrite_l
          nat
          n
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq (pts.u pts.var) (le __ (pred (S m))) (le n m))
          (matita_basics_logic.rewrite_l
             nat
             m
             (__:(pts.El pts.var nat) => matita_basics_logic.eq (pts.u pts.var) (le n __) (le n m))
             (matita_basics_logic.refl (pts.u pts.var) (le n m))
             (pred (S m))
             (pred_Sn m))
          (pred (S n))
          (pred_Sn n)))
    a.

def le_plus_to_le_r :
  a:(pts.El pts.var nat) ->
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) -> __:(pts.El pts.var (le (plus n a) (plus m a))) -> pts.El pts.var (le n m)
  :=
  a:(pts.El pts.var nat) =>
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (le (plus n a) (plus m a))) =>
  le_plus_to_le
    a
    n
    m
    (matita_basics_logic.eq_coerc
       (le (plus n a) (plus m a))
       (le (plus a n) (plus a m))
       auto
       (matita_basics_logic.rewrite_r
          nat
          (plus a n)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq (pts.u pts.var) (le __ (plus m a)) (le (plus a n) (plus a m)))
          (matita_basics_logic.rewrite_r
             nat
             (plus a m)
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq (pts.u pts.var) (le (plus a n) __) (le (plus a n) (plus a m)))
             (matita_basics_logic.refl (pts.u pts.var) (le (plus a n) (plus a m)))
             (plus m a)
             (commutative_plus m a))
          (plus n a)
          (commutative_plus n a))).

def monotonic_le_times_r :
  n:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_relations.monotonic nat le (m:(pts.El pts.var nat) => times n m))
  :=
  n:(pts.El pts.var nat) =>
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  lexy:(pts.El pts.var (le x y)) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) => le (times _x_365 x) (times _x_365 y))
    (le_O_n O)
    (a:(pts.El pts.var nat) =>
     lea:(pts.El pts.var (le (times a x) (times a y))) =>
     le_plus x y (times a x) (times a y) lexy lea)
    n.

def le_times :
  n1:(pts.El pts.var nat) ->
  n2:(pts.El pts.var nat) ->
  m1:(pts.El pts.var nat) ->
  m2:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le n1 n2)) ->
  __1:(pts.El pts.var (le m1 m2)) -> pts.El pts.var (le (times n1 m1) (times n2 m2))
  :=
  n1:(pts.El pts.var nat) =>
  n2:(pts.El pts.var nat) =>
  m1:(pts.El pts.var nat) =>
  m2:(pts.El pts.var nat) =>
  len:(pts.El pts.var (le n1 n2)) =>
  lem:(pts.El pts.var (le m1 m2)) =>
  transitive_le
    (times n1 m1)
    (times n1 m2)
    (times n2 m2)
    (monotonic_le_times_r n1 m1 m2 lem)
    (matita_basics_logic.eq_coerc
       (le (times m2 n1) (times m2 n2))
       (le (times n1 m2) (times n2 m2))
       (monotonic_le_times_r m2 n1 n2 len)
       (matita_basics_logic.rewrite_r
          nat
          (times n1 m2)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq
             (pts.u pts.var)
             (le __ (times m2 n2))
             (le (times n1 m2) (times n2 m2)))
          (matita_basics_logic.rewrite_r
             nat
             (times n2 m2)
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq
                (pts.u pts.var)
                (le (times n1 m2) __)
                (le (times n1 m2) (times n2 m2)))
             (matita_basics_logic.refl (pts.u pts.var) (le (times n1 m2) (times n2 m2)))
             (times m2 n2)
             (commutative_times m2 n2))
          (times m2 n1)
          (commutative_times m2 n1))).

def lt_times_n :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) -> __:(pts.El pts.var (lt O n)) -> pts.El pts.var (le m (times n m))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  H:(pts.El pts.var (lt O n)) =>
  matita_basics_logic.eq_coerc
    (le (times m (S O)) (times m n))
    (le m (times n m))
    (monotonic_le_times_r m (S O) n H)
    (matita_basics_logic.rewrite_l
       nat
       m
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq (pts.u pts.var) (le __ (times m n)) (le m (times n m)))
       (matita_basics_logic.rewrite_r
          nat
          (times n m)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq (pts.u pts.var) (le m __) (le m (times n m)))
          (matita_basics_logic.refl (pts.u pts.var) (le m (times n m)))
          (times m n)
          (commutative_times m n))
       (times m (S O))
       (times_n_1 m)).

def le_times_to_le :
  a:(pts.El pts.var nat) ->
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (lt O a)) ->
  __1:(pts.El pts.var (le (times a n) (times a m))) -> pts.El pts.var (le n m)
  :=
  a:(pts.El pts.var nat) =>
  nat_elim2
    (__:(pts.El pts.var nat) =>
     _0:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       (lt O a)
       (__1:(pts.El pts.var (lt O a)) =>
        pts.Prod
          pts.var
          pts.var
          (le (times a __) (times a _0))
          (__2:(pts.El pts.var (le (times a __) (times a _0))) => le __ _0)))
    (n:(pts.El pts.var nat) =>
     auto:(pts.El pts.var (le (S O) a)) =>
     auto':(pts.El pts.var (le (times a O) (times a n))) => le_O_n n)
    (n:(pts.El pts.var nat) =>
     H1:(pts.El pts.var (le (S O) a)) =>
     H2:(pts.El pts.var (le (times a (S n)) (times a O))) =>
     transitive_le
       (S n)
       (times a (S n))
       O
       (matita_basics_logic.eq_coerc
          (le (times (S n) (S O)) (times (S n) a))
          (le (S n) (times a (S n)))
          (monotonic_le_times_r (S n) (S O) a H1)
          (matita_basics_logic.rewrite_l
             nat
             (plus a (times a n))
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq
                (pts.u pts.var)
                (le (times (S n) (S O)) (times (S n) a))
                (le (S n) __))
             (matita_basics_logic.rewrite_r
                nat
                (times a (S n))
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq
                   (pts.u pts.var)
                   (le (times (S n) (S O)) __)
                   (le (S n) (plus a (times a n))))
                (matita_basics_logic.rewrite_l
                   nat
                   (S n)
                   (__:(pts.El pts.var nat) =>
                    matita_basics_logic.eq
                      (pts.u pts.var)
                      (le __ (times a (S n)))
                      (le (S n) (plus a (times a n))))
                   (matita_basics_logic.rewrite_l
                      nat
                      (plus a (times a n))
                      (__:(pts.El pts.var nat) =>
                       matita_basics_logic.eq
                         (pts.u pts.var)
                         (le (S n) __)
                         (le (S n) (plus a (times a n))))
                      (matita_basics_logic.refl (pts.u pts.var) (le (S n) (plus a (times a n))))
                      (times a (S n))
                      (times_n_Sm a n))
                   (times (S n) (S O))
                   (times_n_1 (S n)))
                (times (S n) a)
                (commutative_times (S n) a))
             (times a (S n))
             (times_n_Sm a n)))
       (matita_basics_logic.eq_coerc
          (le (times a (S n)) (times a O))
          (le (times a (S n)) O)
          H2
          (matita_basics_logic.rewrite_l
             nat
             (plus a (times a n))
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq (pts.u pts.var) (le __ (times a O)) (le (times a (S n)) O))
             (matita_basics_logic.rewrite_l
                nat
                O
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq
                   (pts.u pts.var)
                   (le (plus a (times a n)) __)
                   (le (times a (S n)) O))
                (matita_basics_logic.rewrite_l
                   nat
                   (plus a (times a n))
                   (__:(pts.El pts.var nat) =>
                    matita_basics_logic.eq (pts.u pts.var) (le (plus a (times a n)) O) (le __ O))
                   (matita_basics_logic.refl (pts.u pts.var) (le (plus a (times a n)) O))
                   (times a (S n))
                   (times_n_Sm a n))
                (times a O)
                (times_n_O a))
             (times a (S n))
             (times_n_Sm a n))))
    (n:(pts.El pts.var nat) =>
     m:(pts.El pts.var nat) =>
     H:(__:(pts.El pts.var (le (S O) a)) ->
        __1:(pts.El pts.var (le (times a n) (times a m))) -> pts.El pts.var (le n m)) =>
     lta:(pts.El pts.var (le (S O) a)) =>
     le:(pts.El pts.var (le (times a (S n)) (times a (S m)))) =>
     le_S_S
       n
       m
       (H
          lta
          (le_plus_to_le
             a
             (times a n)
             (times a m)
             (matita_basics_logic.eq_coerc
                (matita_arithmetics_nat.le (times a (S n)) (times a (S m)))
                (matita_arithmetics_nat.le (plus a (times a n)) (plus a (times a m)))
                le
                (matita_basics_logic.rewrite_l
                   nat
                   (plus a (times a n))
                   (__:(pts.El pts.var nat) =>
                    matita_basics_logic.eq
                      (pts.u pts.var)
                      (matita_arithmetics_nat.le __ (times a (S m)))
                      (matita_arithmetics_nat.le (plus a (times a n)) (plus a (times a m))))
                   (matita_basics_logic.rewrite_l
                      nat
                      (plus a (times a m))
                      (__:(pts.El pts.var nat) =>
                       matita_basics_logic.eq
                         (pts.u pts.var)
                         (matita_arithmetics_nat.le (plus a (times a n)) __)
                         (matita_arithmetics_nat.le (plus a (times a n)) (plus a (times a m))))
                      (matita_basics_logic.refl
                         (pts.u pts.var)
                         (matita_arithmetics_nat.le (plus a (times a n)) (plus a (times a m))))
                      (times a (S m))
                      (times_n_Sm a m))
                   (times a (S n))
                   (times_n_Sm a n)))))).

def le_plus_minus_m_m :
  n:(pts.El pts.var nat) -> m:(pts.El pts.var nat) -> pts.El pts.var (le n (plus (minus n m) m))
  :=
  n:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) =>
     pts.Prod pts.var pts.var nat (m:(pts.El pts.var nat) => le _x_365 (plus (minus _x_365 m) m)))
    (m:(pts.El pts.var nat) => le_plus_n_r m O)
    (a:(pts.El pts.var nat) =>
     Hind:(m:(pts.El pts.var nat) -> pts.El pts.var (le a (plus (minus a m) m))) =>
     m:(pts.El pts.var nat) =>
     match_nat
       pts.var
       (__:(pts.El pts.var nat) => le (S a) (plus (minus (S a) __) __))
       (le_plus_n_r O (S a))
       (n0:(pts.El pts.var nat) =>
        matita_basics_logic.eq_coerc
          (le (S a) (S (plus (minus a n0) n0)))
          (le (S a) (plus (minus a n0) (S n0)))
          (le_S_S a (plus (minus a n0) n0) (Hind n0))
          (matita_basics_logic.rewrite_r
             nat
             (plus (minus a n0) (S n0))
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq
                (pts.u pts.var)
                (le (S a) __)
                (le (S a) (plus (minus a n0) (S n0))))
             (matita_basics_logic.refl (pts.u pts.var) (le (S a) (plus (minus a n0) (S n0))))
             (S (plus (minus a n0) n0))
             (plus_n_Sm (minus a n0) n0)))
       m)
    n.

def le_plus_to_minus_r :
  a:(pts.El pts.var nat) ->
  b:(pts.El pts.var nat) ->
  c:(pts.El pts.var nat) -> __:(pts.El pts.var (le (plus a b) c)) -> pts.El pts.var (le a (minus c b))
  :=
  a:(pts.El pts.var nat) =>
  b:(pts.El pts.var nat) =>
  c:(pts.El pts.var nat) =>
  H:(pts.El pts.var (le (plus a b) c)) =>
  le_plus_to_le_r
    b
    a
    (minus c b)
    (transitive_le (plus a b) c (plus (minus c b) b) H (le_plus_minus_m_m c b)).

def lt_to_le :
  x:(pts.El pts.var nat) ->
  y:(pts.El pts.var nat) -> __:(pts.El pts.var (lt x y)) -> pts.El pts.var (le x y)
  :=
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (lt x y)) =>
  le_plus_b
    (S O)
    x
    y
    (matita_basics_logic.eq_coerc
       (le (S x) y)
       (le (plus x (S O)) y)
       auto
       (matita_basics_logic.rewrite_r
          nat
          (plus x (S O))
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq (pts.u pts.var) (le __ y) (le (plus x (S O)) y))
          (matita_basics_logic.refl (pts.u pts.var) (le (plus x (S O)) y))
          (S x)
          (matita_basics_logic.rewrite_r
             nat
             (plus x O)
             (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (S __) (plus x (S O)))
             (plus_n_Sm x O)
             x
             (plus_n_O x)))).

def inv_eq_minus_O :
  x:(pts.El pts.var nat) ->
  y:(pts.El pts.var nat) ->
  __:(pts.El pts.var (matita_basics_logic.eq nat (minus x y) O)) -> pts.El pts.var (le x y)
  :=
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (matita_basics_logic.eq nat (minus x y) O)) =>
  matita_basics_logic.eq_coerc
    (le x (plus (minus x y) y))
    (le x y)
    (le_plus_minus_m_m x y)
    (matita_basics_logic.rewrite_r
       nat
       (plus y (minus x y))
       (__:(pts.El pts.var nat) => matita_basics_logic.eq (pts.u pts.var) (le x __) (le x y))
       (matita_basics_logic.rewrite_r
          nat
          O
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq (pts.u pts.var) (le x (plus y __)) (le x y))
          (matita_basics_logic.rewrite_l
             nat
             y
             (__:(pts.El pts.var nat) => matita_basics_logic.eq (pts.u pts.var) (le x __) (le x y))
             (matita_basics_logic.refl (pts.u pts.var) (le x y))
             (plus y O)
             (plus_n_O y))
          (minus x y)
          auto)
       (plus (minus x y) y)
       (commutative_plus (minus x y) y)).

def le_x_times_x :
  x:(pts.El pts.var nat) -> pts.El pts.var (le x (times x x))
  :=
  x:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) => le _x_365 (times _x_365 _x_365))
    (le_O_n (times O O))
    (x_366:(pts.El pts.var nat) =>
     _x_368:(pts.El pts.var (le x_366 (times x_366 x_366))) =>
     le_plus_n_r (times x_366 (S x_366)) (S x_366))
    x.

def transitive_lt :
  pts.El pts.var (matita_basics_relations.transitive nat lt)
  :=
  a:(pts.El pts.var nat) =>
  b:(pts.El pts.var nat) =>
  c:(pts.El pts.var nat) =>
  ltab:(pts.El pts.var (lt a b)) =>
  ltbc:(pts.El pts.var (lt b c)) =>
  le_ind
    (S b)
    (x_417:(pts.El pts.var nat) => _x_418:(pts.El pts.var (le (S b) x_417)) => lt a x_417)
    (le_S (S a) b ltab)
    (m:(pts.El pts.var nat) =>
     _x_419:(pts.El pts.var (le (S b) m)) => _x_421:(pts.El pts.var (lt a m)) => le_S (S a) m _x_421)
    c
    ltbc.

def lt_to_le_to_lt :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  p:(pts.El pts.var nat) ->
  __:(pts.El pts.var (lt n m)) -> __1:(pts.El pts.var (le m p)) -> pts.El pts.var (lt n p)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  p:(pts.El pts.var nat) =>
  H:(pts.El pts.var (lt n m)) =>
  H1:(pts.El pts.var (le m p)) =>
  le_ind
    m
    (x_417:(pts.El pts.var nat) => _x_418:(pts.El pts.var (le m x_417)) => lt n x_417)
    H
    (m0:(pts.El pts.var nat) =>
     _x_419:(pts.El pts.var (le m m0)) =>
     _x_421:(pts.El pts.var (lt n m0)) =>
     transitive_lt
       n
       m0
       (S m0)
       _x_421
       (matita_basics_logic.eq_coerc
          (le (S m0) (plus O (S m0)))
          (le (S m0) (S m0))
          (le_plus_n O (S m0))
          (matita_basics_logic.rewrite_l
             nat
             (S m0)
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq (pts.u pts.var) (le (S m0) __) (le (S m0) (S m0)))
             (matita_basics_logic.refl (pts.u pts.var) (le (S m0) (S m0)))
             (plus O (S m0))
             (plus_O_n (S m0)))))
    p
    H1.

def le_to_lt_to_lt :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  p:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le n m)) -> __1:(pts.El pts.var (lt m p)) -> pts.El pts.var (lt n p)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  p:(pts.El pts.var nat) =>
  H:(pts.El pts.var (le n m)) =>
  le_ind
    n
    (x_417:(pts.El pts.var nat) =>
     _x_418:(pts.El pts.var (le n x_417)) =>
     pts.Prod pts.var pts.var (lt x_417 p) (__:(pts.El pts.var (lt x_417 p)) => lt n p))
    (auto:(pts.El pts.var (lt n p)) => auto)
    (m0:(pts.El pts.var nat) =>
     _x_419:(pts.El pts.var (le n m0)) =>
     _x_421:(__:(pts.El pts.var (lt m0 p)) -> pts.El pts.var (lt n p)) =>
     auto:(pts.El pts.var (lt (S m0) p)) =>
     _x_421
       (transitive_lt
          m0
          (S m0)
          p
          (matita_basics_logic.eq_coerc
             (le (S m0) (plus O (S m0)))
             (le (S m0) (S m0))
             (le_plus_n O (S m0))
             (matita_basics_logic.rewrite_l
                nat
                (S m0)
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq (pts.u pts.var) (le (S m0) __) (le (S m0) (S m0)))
                (matita_basics_logic.refl (pts.u pts.var) (le (S m0) (S m0)))
                (plus O (S m0))
                (plus_O_n (S m0))))
          auto))
    m
    H.

def lt_S_to_lt :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) -> __:(pts.El pts.var (lt (S n) m)) -> pts.El pts.var (lt n m)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (lt (S n) m)) =>
  transitive_lt
    n
    (S n)
    m
    (matita_basics_logic.eq_coerc
       (le (S n) (plus O (S n)))
       (le (S n) (S n))
       (le_plus_n O (S n))
       (matita_basics_logic.rewrite_l
          nat
          (S n)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq (pts.u pts.var) (le (S n) __) (le (S n) (S n)))
          (matita_basics_logic.refl (pts.u pts.var) (le (S n) (S n)))
          (plus O (S n))
          (plus_O_n (S n))))
    auto.

def ltn_to_ltO :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) -> __:(pts.El pts.var (lt n m)) -> pts.El pts.var (lt O m)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (lt n m)) =>
  lt_to_le_to_lt
    O
    (S n)
    m
    (matita_basics_logic.eq_coerc
       (le (S O) (plus n (S O)))
       (le (S O) (S n))
       (le_plus_n n (S O))
       (matita_basics_logic.rewrite_l
          nat
          (S n)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq (pts.u pts.var) (le (S O) __) (le (S O) (S n)))
          (matita_basics_logic.refl (pts.u pts.var) (le (S O) (S n)))
          (plus n (S O))
          (matita_basics_logic.rewrite_r
             nat
             (plus n O)
             (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (S __) (plus n (S O)))
             (plus_n_Sm n O)
             n
             (plus_n_O n))))
    auto.

def lt_O_S :
  n:(pts.El pts.var nat) -> pts.El pts.var (lt O (S n))
  :=
  n:(pts.El pts.var nat) =>
  ltn_to_ltO
    n
    (S n)
    (matita_basics_logic.eq_coerc
       (le (S n) (plus O (S n)))
       (le (S n) (S n))
       (le_plus_n O (S n))
       (matita_basics_logic.rewrite_l
          nat
          (S n)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq (pts.u pts.var) (le (S n) __) (le (S n) (S n)))
          (matita_basics_logic.refl (pts.u pts.var) (le (S n) (S n)))
          (plus O (S n))
          (plus_O_n (S n)))).

def monotonic_lt_plus_r :
  n:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_relations.monotonic nat lt (m:(pts.El pts.var nat) => plus n m))
  :=
  n:(pts.El pts.var nat) =>
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (lt x y)) =>
  matita_basics_logic.eq_coerc
    (le (plus n (S x)) (plus n y))
    (le (S (plus n x)) (plus n y))
    (monotonic_le_plus_r n (S x) y auto)
    (matita_basics_logic.rewrite_r
       nat
       (plus n (S x))
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq (pts.u pts.var) (le (plus n (S x)) (plus n y)) (le __ (plus n y)))
       (matita_basics_logic.refl (pts.u pts.var) (le (plus n (S x)) (plus n y)))
       (S (plus n x))
       (plus_n_Sm n x)).

def monotonic_lt_plus_l :
  n:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_relations.monotonic nat lt (m:(pts.El pts.var nat) => plus m n))
  :=
  n:(pts.El pts.var nat) =>
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (lt x y)) =>
  matita_basics_logic.eq_coerc
    (le (plus n (S x)) (plus n y))
    (le (S (plus x n)) (plus y n))
    (monotonic_le_plus_r n (S x) y auto)
    (matita_basics_logic.rewrite_r
       nat
       (plus n x)
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq (pts.u pts.var) (le (plus n (S x)) (plus n y)) (le (S __) (plus y n)))
       (matita_basics_logic.rewrite_r
          nat
          (plus n (S x))
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq (pts.u pts.var) (le (plus n (S x)) (plus n y)) (le __ (plus y n)))
          (matita_basics_logic.rewrite_r
             nat
             (plus n y)
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq
                (pts.u pts.var)
                (le (plus n (S x)) (plus n y))
                (le (plus n (S x)) __))
             (matita_basics_logic.refl (pts.u pts.var) (le (plus n (S x)) (plus n y)))
             (plus y n)
             (commutative_plus y n))
          (S (plus n x))
          (plus_n_Sm n x))
       (plus x n)
       (commutative_plus x n)).

def lt_plus :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  p:(pts.El pts.var nat) ->
  q:(pts.El pts.var nat) ->
  __:(pts.El pts.var (lt n m)) ->
  __1:(pts.El pts.var (lt p q)) -> pts.El pts.var (lt (plus n p) (plus m q))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  p:(pts.El pts.var nat) =>
  q:(pts.El pts.var nat) =>
  ltnm:(pts.El pts.var (lt n m)) =>
  ltpq:(pts.El pts.var (lt p q)) =>
  transitive_lt
    (plus n p)
    (plus n q)
    (plus m q)
    (matita_basics_logic.eq_coerc
       (le (plus n (S p)) (plus n q))
       (le (S (plus n p)) (plus n q))
       (monotonic_le_plus_r n (S p) q ltpq)
       (matita_basics_logic.rewrite_r
          nat
          (plus n (S p))
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq (pts.u pts.var) (le (plus n (S p)) (plus n q)) (le __ (plus n q)))
          (matita_basics_logic.refl (pts.u pts.var) (le (plus n (S p)) (plus n q)))
          (S (plus n p))
          (plus_n_Sm n p)))
    (monotonic_lt_plus_l q n m ltnm).

def lt_plus_to_lt_l :
  n:(pts.El pts.var nat) ->
  p:(pts.El pts.var nat) ->
  q:(pts.El pts.var nat) -> __:(pts.El pts.var (lt (plus p n) (plus q n))) -> pts.El pts.var (lt p q)
  :=
  n:(pts.El pts.var nat) =>
  p:(pts.El pts.var nat) =>
  q:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (lt (plus p n) (plus q n))) =>
  le_plus_to_le
    n
    (S p)
    q
    (matita_basics_logic.eq_coerc
       (le (S (plus p n)) (plus q n))
       (le (plus n (S p)) (plus n q))
       auto
       (matita_basics_logic.rewrite_r
          nat
          (plus n p)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq
             (pts.u pts.var)
             (le (S __) (plus q n))
             (le (plus n (S p)) (plus n q)))
          (matita_basics_logic.rewrite_r
             nat
             (plus n (S p))
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq
                (pts.u pts.var)
                (le __ (plus q n))
                (le (plus n (S p)) (plus n q)))
             (matita_basics_logic.rewrite_r
                nat
                (plus n q)
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq
                   (pts.u pts.var)
                   (le (plus n (S p)) __)
                   (le (plus n (S p)) (plus n q)))
                (matita_basics_logic.refl (pts.u pts.var) (le (plus n (S p)) (plus n q)))
                (plus q n)
                (commutative_plus q n))
             (S (plus n p))
             (plus_n_Sm n p))
          (plus p n)
          (commutative_plus p n))).

def lt_plus_to_lt_r :
  n:(pts.El pts.var nat) ->
  p:(pts.El pts.var nat) ->
  q:(pts.El pts.var nat) -> __:(pts.El pts.var (lt (plus n p) (plus n q))) -> pts.El pts.var (lt p q)
  :=
  n:(pts.El pts.var nat) =>
  p:(pts.El pts.var nat) =>
  q:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (lt (plus n p) (plus n q))) =>
  lt_plus_to_lt_l
    n
    p
    q
    (matita_basics_logic.eq_coerc
       (lt (plus n p) (plus n q))
       (lt (plus p n) (plus q n))
       auto
       (matita_basics_logic.rewrite_r
          nat
          (plus p n)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq (pts.u pts.var) (lt __ (plus n q)) (lt (plus p n) (plus q n)))
          (matita_basics_logic.rewrite_r
             nat
             (plus q n)
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq (pts.u pts.var) (lt (plus p n) __) (lt (plus p n) (plus q n)))
             (matita_basics_logic.refl (pts.u pts.var) (lt (plus p n) (plus q n)))
             (plus n q)
             (commutative_plus n q))
          (plus n p)
          (commutative_plus n p))).

def increasing_to_monotonic :
  f:(__:(pts.El pts.var nat) -> pts.El pts.var nat) ->
  __:(pts.El pts.var (increasing f)) -> pts.El pts.var (matita_basics_relations.monotonic nat lt f)
  :=
  f:(__:(pts.El pts.var nat) -> pts.El pts.var nat) =>
  incr:(pts.El pts.var (increasing f)) =>
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  ltnm:(pts.El pts.var (lt n m)) =>
  le_ind
    (S n)
    (x_417:(pts.El pts.var nat) => _x_418:(pts.El pts.var (le (S n) x_417)) => lt (f n) (f x_417))
    (incr n)
    (m0:(pts.El pts.var nat) =>
     _x_419:(pts.El pts.var (le (S n) m0)) =>
     _x_421:(pts.El pts.var (lt (f n) (f m0))) =>
     transitive_lt (f n) (f m0) (f (S m0)) _x_421 (incr m0))
    m
    ltnm.

def monotonic_lt_times_r :
  c:(pts.El pts.var nat) ->
  __:(pts.El pts.var (lt O c)) ->
  pts.El pts.var (matita_basics_relations.monotonic nat lt (t:(pts.El pts.var nat) => times c t))
  :=
  c:(pts.El pts.var nat) =>
  posc:(pts.El pts.var (lt O c)) =>
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  ltnm:(pts.El pts.var (lt n m)) =>
  le_ind
    (S n)
    (x_417:(pts.El pts.var nat) =>
     _x_418:(pts.El pts.var (le (S n) x_417)) => lt (times c n) (times c x_417))
    (matita_basics_logic.eq_coerc
       (le (S (plus O (times c n))) (plus c (times c n)))
       (le (S (times c n)) (times c (S n)))
       (monotonic_lt_plus_l (times c n) O c posc)
       (matita_basics_logic.rewrite_r
          nat
          (plus O (S (times c n)))
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq
             (pts.u pts.var)
             (le __ (plus c (times c n)))
             (le (S (times c n)) (times c (S n))))
          (matita_basics_logic.rewrite_l
             nat
             (plus c (times c n))
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq
                (pts.u pts.var)
                (le (plus O (S (times c n))) (plus c (times c n)))
                (le (S (times c n)) __))
             (matita_basics_logic.rewrite_l
                nat
                (S (times c n))
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq
                   (pts.u pts.var)
                   (le __ (plus c (times c n)))
                   (le (S (times c n)) (plus c (times c n))))
                (matita_basics_logic.refl
                   (pts.u pts.var)
                   (le (S (times c n)) (plus c (times c n))))
                (plus O (S (times c n)))
                (plus_O_n (S (times c n))))
             (times c (S n))
             (times_n_Sm c n))
          (S (plus O (times c n)))
          (plus_n_Sm O (times c n))))
    (a:(pts.El pts.var nat) =>
     __:(pts.El pts.var (le (S n) a)) =>
     lt1:(pts.El pts.var (le (S (times c n)) (times c a))) =>
     transitive_le
       (S (times c n))
       (times c a)
       (times c (S a))
       lt1
       (matita_basics_logic.eq_coerc
          (le (times c a) (plus (times c a) c))
          (le (times c a) (times c (S a)))
          (le_plus_n_r c (times c a))
          (matita_basics_logic.rewrite_l
             nat
             (plus c (times c a))
             (__1:(pts.El pts.var nat) =>
              matita_basics_logic.eq
                (pts.u pts.var)
                (le (times c a) (plus (times c a) c))
                (le (times c a) __1))
             (matita_basics_logic.rewrite_r
                nat
                (plus c (times c a))
                (__1:(pts.El pts.var nat) =>
                 matita_basics_logic.eq
                   (pts.u pts.var)
                   (le (times c a) __1)
                   (le (times c a) (plus c (times c a))))
                (matita_basics_logic.refl (pts.u pts.var) (le (times c a) (plus c (times c a))))
                (plus (times c a) c)
                (commutative_plus (times c a) c))
             (times c (S a))
             (times_n_Sm c a))))
    m
    ltnm.

def monotonic_lt_times_l :
  c:(pts.El pts.var nat) ->
  __:(pts.El pts.var (lt O c)) ->
  pts.El pts.var (matita_basics_relations.monotonic nat lt (t:(pts.El pts.var nat) => times t c))
  :=
  c:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (lt O c)) =>
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  auto':(pts.El pts.var (lt x y)) =>
  matita_basics_logic.eq_coerc
    (le (S (times c x)) (times c y))
    (le (S (times x c)) (times y c))
    (monotonic_lt_times_r c auto x y auto')
    (matita_basics_logic.rewrite_r
       nat
       (times c x)
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq
          (pts.u pts.var)
          (le (S (times c x)) (times c y))
          (le (S __) (times y c)))
       (matita_basics_logic.rewrite_r
          nat
          (times c y)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq
             (pts.u pts.var)
             (le (S (times c x)) (times c y))
             (le (S (times c x)) __))
          (matita_basics_logic.refl (pts.u pts.var) (le (S (times c x)) (times c y)))
          (times y c)
          (commutative_times y c))
       (times x c)
       (commutative_times x c)).

def lt_to_le_to_lt_times :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  p:(pts.El pts.var nat) ->
  q:(pts.El pts.var nat) ->
  __:(pts.El pts.var (lt n m)) ->
  __1:(pts.El pts.var (le p q)) ->
  __2:(pts.El pts.var (lt O q)) -> pts.El pts.var (lt (times n p) (times m q))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  p:(pts.El pts.var nat) =>
  q:(pts.El pts.var nat) =>
  ltnm:(pts.El pts.var (lt n m)) =>
  lepq:(pts.El pts.var (le p q)) =>
  posq:(pts.El pts.var (lt O q)) =>
  le_to_lt_to_lt
    (times n p)
    (times n q)
    (times m q)
    (monotonic_le_times_r n p q lepq)
    (monotonic_lt_times_l q posq n m ltnm).

def lt_times :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  p:(pts.El pts.var nat) ->
  q:(pts.El pts.var nat) ->
  __:(pts.El pts.var (lt n m)) ->
  __1:(pts.El pts.var (lt p q)) -> pts.El pts.var (lt (times n p) (times m q))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  p:(pts.El pts.var nat) =>
  q:(pts.El pts.var nat) =>
  ltnm:(pts.El pts.var (lt n m)) =>
  ltpq:(pts.El pts.var (lt p q)) =>
  lt_to_le_to_lt_times n m p q ltnm (lt_to_le p q ltpq) (ltn_to_ltO p q ltpq).

def lt_plus_to_minus_r :
  a:(pts.El pts.var nat) ->
  b:(pts.El pts.var nat) ->
  c:(pts.El pts.var nat) -> __:(pts.El pts.var (lt (plus a b) c)) -> pts.El pts.var (lt a (minus c b))
  :=
  a:(pts.El pts.var nat) =>
  b:(pts.El pts.var nat) =>
  c:(pts.El pts.var nat) => H:(pts.El pts.var (lt (plus a b) c)) => le_plus_to_minus_r (S a) b c H.

def lt_plus_Sn_r :
  a:(pts.El pts.var nat) ->
  x:(pts.El pts.var nat) -> n:(pts.El pts.var nat) -> pts.El pts.var (lt a (plus (plus a x) (S n)))
  :=
  a:(pts.El pts.var nat) =>
  x:(pts.El pts.var nat) =>
  n:(pts.El pts.var nat) =>
  matita_basics_logic.eq_coerc
    (le (S a) (S (plus (plus a x) n)))
    (le (S a) (plus (plus a x) (S n)))
    (le_S_S
       a
       (plus (plus a x) n)
       (matita_basics_logic.eq_coerc
          (le a (plus a (plus x n)))
          (le a (plus (plus a x) n))
          (le_plus_n_r (plus x n) a)
          (matita_basics_logic.rewrite_r
             nat
             (plus n (plus a x))
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq (pts.u pts.var) (le a (plus a (plus x n))) (le a __))
             (matita_basics_logic.rewrite_r
                nat
                (plus a (plus n x))
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq (pts.u pts.var) (le a (plus a (plus x n))) (le a __))
                (matita_basics_logic.rewrite_r
                   nat
                   (plus x n)
                   (__:(pts.El pts.var nat) =>
                    matita_basics_logic.eq
                      (pts.u pts.var)
                      (le a (plus a (plus x n)))
                      (le a (plus a __)))
                   (matita_basics_logic.refl (pts.u pts.var) (le a (plus a (plus x n))))
                   (plus n x)
                   (commutative_plus n x))
                (plus n (plus a x))
                (matita_basics_logic.rewrite_l
                   nat
                   (plus (plus a n) x)
                   (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (plus n (plus a x)) __)
                   (assoc_plus1 x a n)
                   (plus a (plus n x))
                   (associative_plus a n x)))
             (plus (plus a x) n)
             (commutative_plus (plus a x) n))))
    (matita_basics_logic.rewrite_r
       nat
       (plus a (plus x (S n)))
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq (pts.u pts.var) (le (S a) (S (plus (plus a x) n))) (le (S a) __))
       (matita_basics_logic.rewrite_r
          nat
          (plus (plus a x) (S n))
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq (pts.u pts.var) (le (S a) __) (le (S a) (plus a (plus x (S n)))))
          (matita_basics_logic.rewrite_r
             nat
             (plus a (plus x (S n)))
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq
                (pts.u pts.var)
                (le (S a) __)
                (le (S a) (plus a (plus x (S n)))))
             (matita_basics_logic.refl (pts.u pts.var) (le (S a) (plus a (plus x (S n)))))
             (plus (plus a x) (S n))
             (associative_plus a x (S n)))
          (S (plus (plus a x) n))
          (plus_n_Sm (plus a x) n))
       (plus (plus a x) (S n))
       (associative_plus a x (S n))).

def let_clause_16 :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  auto:(pts.El pts.var (lt (S n) (S m))) ->
  x32:(pts.El pts.var nat) -> pts.El pts.var (matita_basics_logic.eq nat (S x32) (plus x32 (S O)))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (lt (S n) (S m))) =>
  x32:(pts.El pts.var nat) =>
  matita_basics_logic.rewrite_r
    nat
    (plus x32 O)
    (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (S __) (plus x32 (S O)))
    (plus_n_Sm x32 O)
    x32
    (plus_n_O x32).

def lt_S_S_to_lt :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) -> __:(pts.El pts.var (lt (S n) (S m))) -> pts.El pts.var (lt n m)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (lt (S n) (S m))) =>
  lt_plus_to_lt_l
    (S O)
    n
    m
    (matita_basics_logic.eq_coerc
       (lt (S n) (S m))
       (lt (plus n (S O)) (plus m (S O)))
       auto
       (matita_basics_logic.rewrite_r
          nat
          (plus n (S O))
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq (pts.u pts.var) (lt __ (S m)) (lt (plus n (S O)) (plus m (S O))))
          (matita_basics_logic.rewrite_r
             nat
             (plus m (S O))
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq
                (pts.u pts.var)
                (lt (plus n (S O)) __)
                (lt (plus n (S O)) (plus m (S O))))
             (matita_basics_logic.refl (pts.u pts.var) (lt (plus n (S O)) (plus m (S O))))
             (S m)
             (let_clause_16 n m auto m))
          (S n)
          (let_clause_16 n m auto n))).

def not_le_Sn_O :
  n:(pts.El pts.var nat) -> pts.El pts.var (matita_basics_logic.Not (le (S n) O))
  :=
  n:(pts.El pts.var nat) =>
  matita_basics_logic.nmk
    (le (S n) O)
    (Hlen0:(pts.El pts.var (le (S n) O)) => lt_to_not_zero n O Hlen0).

def not_le_to_not_le_S_S :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (matita_basics_logic.Not (le n m))) ->
  pts.El pts.var (matita_basics_logic.Not (le (S n) (S m)))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (matita_basics_logic.Not (le n m))) =>
  matita_basics_logic.not_to_not
    (le (S n) (S m))
    (le n m)
    (auto':(pts.El pts.var (le (S n) (S m))) =>
     matita_basics_logic.eq_coerc
       (le (pred (S n)) (pred (S m)))
       (le n m)
       (monotonic_pred (S n) (S m) auto')
       (matita_basics_logic.rewrite_l
          nat
          n
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq (pts.u pts.var) (le __ (pred (S m))) (le n m))
          (matita_basics_logic.rewrite_l
             nat
             m
             (__:(pts.El pts.var nat) => matita_basics_logic.eq (pts.u pts.var) (le n __) (le n m))
             (matita_basics_logic.refl (pts.u pts.var) (le n m))
             (pred (S m))
             (pred_Sn m))
          (pred (S n))
          (pred_Sn n)))
    auto.

def not_le_S_S_to_not_le :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (matita_basics_logic.Not (le (S n) (S m)))) ->
  pts.El pts.var (matita_basics_logic.Not (le n m))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (matita_basics_logic.Not (le (S n) (S m)))) =>
  matita_basics_logic.not_to_not
    (le n m)
    (le (S n) (S m))
    (auto':(pts.El pts.var (le n m)) => le_S_S n m auto')
    auto.

def not_le_Sn_n :
  n:(pts.El pts.var nat) -> pts.El pts.var (matita_basics_logic.Not (le (S n) n))
  :=
  n:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) => matita_basics_logic.Not (le (S _x_365) _x_365))
    (not_le_Sn_O O)
    (x_366:(pts.El pts.var nat) =>
     _x_368:(pts.El pts.var (matita_basics_logic.Not (le (S x_366) x_366))) =>
     not_le_to_not_le_S_S (S x_366) x_366 _x_368)
    n.

def lt_to_not_le :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (lt n m)) -> pts.El pts.var (matita_basics_logic.Not (le m n))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  Hltnm:(pts.El pts.var (lt n m)) =>
  le_ind
    (S n)
    (x_417:(pts.El pts.var nat) =>
     _x_418:(pts.El pts.var (le (S n) x_417)) => matita_basics_logic.Not (le x_417 n))
    (not_le_Sn_n n)
    (m0:(pts.El pts.var nat) =>
     _x_419:(pts.El pts.var (le (S n) m0)) =>
     _x_421:(pts.El pts.var (matita_basics_logic.Not (le m0 n))) =>
     matita_basics_logic.not_to_not
       (le (S m0) n)
       (le m0 n)
       (auto:(pts.El pts.var (le (S m0) n)) => lt_to_le m0 n auto)
       _x_421)
    m
    Hltnm.

def not_le_to_lt :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (matita_basics_logic.Not (le n m))) -> pts.El pts.var (lt m n)
  :=
  nat_elim2
    (__:(pts.El pts.var nat) =>
     _0:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       (matita_basics_logic.Not (le __ _0))
       (__1:(pts.El pts.var (matita_basics_logic.Not (le __ _0))) => lt _0 __))
    (n:(pts.El pts.var nat) =>
     abs:(pts.El pts.var (matita_basics_logic.Not (le O n))) =>
     matita_basics_logic.False_ind
       (_x_66:(pts.El pts.var matita_basics_logic.False) => lt n O)
       (matita_basics_logic.absurd
          (le O n)
          (matita_basics_logic.eq_coerc
             (le O (plus n O))
             (le O n)
             (le_plus_n n O)
             (matita_basics_logic.rewrite_l
                nat
                n
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq (pts.u pts.var) (le O __) (le O n))
                (matita_basics_logic.refl (pts.u pts.var) (le O n))
                (plus n O)
                (plus_n_O n)))
          abs))
    (n:(pts.El pts.var nat) =>
     auto:(pts.El pts.var (matita_basics_logic.Not (le (S n) O))) => lt_O_S n)
    (n:(pts.El pts.var nat) =>
     m:(pts.El pts.var nat) =>
     Hind:(__:(pts.El pts.var (matita_basics_logic.Not (le n m))) -> pts.El pts.var (lt m n)) =>
     HnotleSS:(pts.El pts.var (matita_basics_logic.Not (le (S n) (S m)))) =>
     le_S_S (S m) n (Hind (not_le_S_S_to_not_le n m HnotleSS))).

def not_lt_to_le :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (matita_basics_logic.Not (lt n m))) -> pts.El pts.var (le m n)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  H:(pts.El pts.var (matita_basics_logic.Not (lt n m))) =>
  le_S_S_to_le
    m
    n
    (not_le_to_lt
       (S n)
       m
       (matita_basics_logic.not_to_not
          (le (S n) m)
          (lt n m)
          (auto:(pts.El pts.var (le (S n) m)) => auto)
          H)).

def le_to_not_lt :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le n m)) -> pts.El pts.var (matita_basics_logic.Not (lt m n))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  H:(pts.El pts.var (le n m)) =>
  lt_to_not_le
    n
    (S m)
    (le_to_lt_to_lt
       n
       m
       (S m)
       H
       (matita_basics_logic.eq_coerc
          (le (S m) (plus O (S m)))
          (le (S m) (S m))
          (le_plus_n O (S m))
          (matita_basics_logic.rewrite_l
             nat
             (S m)
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq (pts.u pts.var) (le (S m) __) (le (S m) (S m)))
             (matita_basics_logic.refl (pts.u pts.var) (le (S m) (S m)))
             (plus O (S m))
             (plus_O_n (S m))))).

def decidable_eq_nat :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_logic.decidable (matita_basics_logic.eq nat n m))
  :=
  nat_elim2
    (__:(pts.El pts.var nat) =>
     _0:(pts.El pts.var nat) => matita_basics_logic.decidable (matita_basics_logic.eq nat __ _0))
    (n:(pts.El pts.var nat) =>
     match_nat
       pts.var
       (__:(pts.El pts.var nat) => matita_basics_logic.decidable (matita_basics_logic.eq nat O __))
       (matita_basics_logic.or_introl
          (matita_basics_logic.eq nat O O)
          (matita_basics_logic.Not (matita_basics_logic.eq nat O O))
          (matita_basics_logic.refl nat O))
       (auto:(pts.El pts.var nat) =>
        matita_basics_logic.or_intror
          (matita_basics_logic.eq nat O (S auto))
          (matita_basics_logic.Not (matita_basics_logic.eq nat O (S auto)))
          (not_eq_O_S auto))
       n)
    (n:(pts.El pts.var nat) =>
     matita_basics_logic.or_intror
       (matita_basics_logic.eq nat (S n) O)
       (matita_basics_logic.Not (matita_basics_logic.eq nat (S n) O))
       (matita_basics_logic.sym_not_eq nat O (S n) (not_eq_O_S n)))
    (n:(pts.El pts.var nat) =>
     m:(pts.El pts.var nat) =>
     Hind:(pts.El pts.var (matita_basics_logic.decidable (matita_basics_logic.eq nat n m))) =>
     matita_basics_logic.match_Or
       (matita_basics_logic.eq nat n m)
       (matita_basics_logic.Not (matita_basics_logic.eq nat n m))
       pts.var
       (__:(pts.El
              pts.var
              (matita_basics_logic.Or
                 (matita_basics_logic.eq nat n m)
                 (matita_basics_logic.Not (matita_basics_logic.eq nat n m)))) =>
        matita_basics_logic.decidable (matita_basics_logic.eq nat (S n) (S m)))
       (auto:(pts.El pts.var (matita_basics_logic.eq nat n m)) =>
        matita_basics_logic.or_introl
          (matita_basics_logic.eq nat (S n) (S m))
          (matita_basics_logic.Not (matita_basics_logic.eq nat (S n) (S m)))
          (matita_basics_logic.rewrite_l
             nat
             n
             (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (S n) (S __))
             (matita_basics_logic.refl nat (S n))
             m
             auto))
       (auto:(pts.El pts.var (matita_basics_logic.Not (matita_basics_logic.eq nat n m))) =>
        matita_basics_logic.or_intror
          (matita_basics_logic.eq nat (S n) (S m))
          (matita_basics_logic.Not (matita_basics_logic.eq nat (S n) (S m)))
          (not_eq_S n m auto))
       Hind).

def decidable_le :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) -> pts.El pts.var (matita_basics_logic.decidable (le n m))
  :=
  nat_elim2
    (__:(pts.El pts.var nat) => _0:(pts.El pts.var nat) => matita_basics_logic.decidable (le __ _0))
    (n:(pts.El pts.var nat) =>
     matita_basics_logic.or_introl (le O n) (matita_basics_logic.Not (le O n)) (le_O_n n))
    (n:(pts.El pts.var nat) =>
     matita_basics_logic.or_intror
       (le (S n) O)
       (matita_basics_logic.Not (le (S n) O))
       (not_le_Sn_O n))
    (n:(pts.El pts.var nat) =>
     m:(pts.El pts.var nat) =>
     _clearme:(pts.El pts.var (matita_basics_logic.decidable (le n m))) =>
     matita_basics_logic.match_Or
       (le n m)
       (matita_basics_logic.Not (le n m))
       pts.var
       (__:(pts.El pts.var (matita_basics_logic.Or (le n m) (matita_basics_logic.Not (le n m)))) =>
        matita_basics_logic.decidable (le (S n) (S m)))
       (auto:(pts.El pts.var (le n m)) =>
        matita_basics_logic.or_introl
          (le (S n) (S m))
          (matita_basics_logic.Not (le (S n) (S m)))
          (le_S_S n m auto))
       (auto:(pts.El pts.var (matita_basics_logic.Not (le n m))) =>
        matita_basics_logic.or_intror
          (le (S n) (S m))
          (matita_basics_logic.Not (le (S n) (S m)))
          (not_le_to_not_le_S_S n m auto))
       _clearme).

def decidable_lt :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) -> pts.El pts.var (matita_basics_logic.decidable (lt n m))
  :=
  n:(pts.El pts.var nat) => m:(pts.El pts.var nat) => decidable_le (S n) m.

def le_to_or_lt_eq :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le n m)) ->
  pts.El pts.var (matita_basics_logic.Or (lt n m) (matita_basics_logic.eq nat n m))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  lenm:(pts.El pts.var (le n m)) =>
  le_ind
    n
    (x_417:(pts.El pts.var nat) =>
     _x_418:(pts.El pts.var (le n x_417)) =>
     matita_basics_logic.Or (lt n x_417) (matita_basics_logic.eq nat n x_417))
    (matita_basics_relations.RC_reflexive nat lt n)
    (m0:(pts.El pts.var nat) =>
     _x_419:(pts.El pts.var (le n m0)) =>
     _x_421:(pts.El pts.var (matita_basics_logic.Or (lt n m0) (matita_basics_logic.eq nat n m0))) =>
     matita_basics_logic.or_introl
       (lt n (S m0))
       (matita_basics_logic.eq nat n (S m0))
       (le_to_lt_to_lt
          n
          m0
          (S m0)
          _x_419
          (matita_basics_logic.eq_coerc
             (le (S m0) (plus O (S m0)))
             (le (S m0) (S m0))
             (le_plus_n O (S m0))
             (matita_basics_logic.rewrite_l
                nat
                (S m0)
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq (pts.u pts.var) (le (S m0) __) (le (S m0) (S m0)))
                (matita_basics_logic.refl (pts.u pts.var) (le (S m0) (S m0)))
                (plus O (S m0))
                (plus_O_n (S m0))))))
    m
    lenm.

def eq_or_gt :
  n:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_logic.Or (matita_basics_logic.eq nat O n) (lt O n))
  :=
  n:(pts.El pts.var nat) =>
  matita_basics_logic.Or_ind
    (lt O n)
    (matita_basics_logic.eq nat O n)
    (_x_170:(pts.El pts.var (matita_basics_logic.Or (lt O n) (matita_basics_logic.eq nat O n))) =>
     matita_basics_logic.Or (matita_basics_logic.eq nat O n) (lt O n))
    (_x_171:(pts.El pts.var (lt O n)) =>
     matita_basics_logic.or_intror (matita_basics_logic.eq nat O n) (lt O n) _x_171)
    (_x_172:(pts.El pts.var (matita_basics_logic.eq nat O n)) =>
     matita_basics_logic.or_introl
       (matita_basics_logic.eq nat O n)
       (lt O n)
       (matita_basics_logic.rewrite_r
          nat
          n
          (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ n)
          (matita_basics_logic.refl nat n)
          O
          _x_172))
    (le_to_or_lt_eq O n (le_O_n n)).

def increasing_to_le2 :
  f:(__:(pts.El pts.var nat) -> pts.El pts.var nat) ->
  __:(pts.El pts.var (increasing f)) ->
  m:(pts.El pts.var nat) ->
  __1:(pts.El pts.var (le (f O) m)) ->
  pts.El
    pts.var
    (matita_basics_logic.ex
       nat
       (i:(pts.El pts.var nat) => matita_basics_logic.And (le (f i) m) (lt m (f (S i)))))
  :=
  f:(__:(pts.El pts.var nat) -> pts.El pts.var nat) =>
  incr:(pts.El pts.var (increasing f)) =>
  m:(pts.El pts.var nat) =>
  lem:(pts.El pts.var (le (f O) m)) =>
  le_ind
    (f O)
    (x_417:(pts.El pts.var nat) =>
     _x_418:(pts.El pts.var (le (f O) x_417)) =>
     matita_basics_logic.ex
       nat
       (i:(pts.El pts.var nat) => matita_basics_logic.And (le (f i) x_417) (lt x_417 (f (S i)))))
    (matita_basics_logic.ex_intro
       nat
       (i:(pts.El pts.var nat) => matita_basics_logic.And (le (f i) (f O)) (lt (f O) (f (S i))))
       O
       (matita_basics_logic.conj (le (f O) (f O)) (lt (f O) (f (S O))) (le_n (f O)) (incr O)))
    (n:(pts.El pts.var nat) =>
     len:(pts.El pts.var (le (f O) n)) =>
     _clearme:(pts.El
                 pts.var
                 (matita_basics_logic.ex
                    nat
                    (i:(pts.El pts.var nat) =>
                     matita_basics_logic.And (le (f i) n) (lt n (f (S i)))))) =>
     matita_basics_logic.match_ex
       nat
       (i:(pts.El pts.var nat) => matita_basics_logic.And (le (f i) n) (lt n (f (S i))))
       pts.var
       (__:(pts.El
              pts.var
              (matita_basics_logic.ex
                 nat
                 (i:(pts.El pts.var nat) =>
                  matita_basics_logic.And (le (f i) n) (lt n (f (S i)))))) =>
        matita_basics_logic.ex
          nat
          (i:(pts.El pts.var nat) => matita_basics_logic.And (le (f i) (S n)) (lt (S n) (f (S i)))))
       (a:(pts.El pts.var nat) =>
        _clearme0:(pts.El pts.var (matita_basics_logic.And (le (f a) n) (lt n (f (S a))))) =>
        matita_basics_logic.match_And
          (le (f a) n)
          (lt n (f (S a)))
          pts.var
          (__:(pts.El pts.var (matita_basics_logic.And (le (f a) n) (lt n (f (S a))))) =>
           matita_basics_logic.ex
             nat
             (i:(pts.El pts.var nat) =>
              matita_basics_logic.And (le (f i) (S n)) (lt (S n) (f (S i)))))
          (len0:(pts.El pts.var (le (f a) n)) =>
           ltnr:(pts.El pts.var (lt n (f (S a)))) =>
           matita_basics_logic.match_Or
             (lt (S n) (f (S a)))
             (matita_basics_logic.eq nat (S n) (f (S a)))
             pts.var
             (__:(pts.El
                    pts.var
                    (matita_basics_logic.Or
                       (lt (S n) (f (S a)))
                       (matita_basics_logic.eq nat (S n) (f (S a))))) =>
              matita_basics_logic.ex
                nat
                (i:(pts.El pts.var nat) =>
                 matita_basics_logic.And (le (f i) (S n)) (lt (S n) (f (S i)))))
             (H:(pts.El pts.var (lt (S n) (f (S a)))) =>
              matita_basics_logic.ex_intro
                nat
                (i:(pts.El pts.var nat) =>
                 matita_basics_logic.And (le (f i) (S n)) (lt (S n) (f (S i))))
                a
                (matita_basics_logic.conj
                   (le (f a) (S n))
                   (lt (S n) (f (S a)))
                   (le_S (f a) n len0)
                   H))
             (H:(pts.El pts.var (matita_basics_logic.eq nat (S n) (f (S a)))) =>
              matita_basics_logic.ex_intro
                nat
                (i:(pts.El pts.var nat) =>
                 matita_basics_logic.And (le (f i) (S n)) (lt (S n) (f (S i))))
                (S a)
                (matita_basics_logic.conj
                   (le (f (S a)) (S n))
                   (lt (S n) (f (S (S a))))
                   (matita_basics_logic.eq_coerc
                      (le (S n) (S n))
                      (le (f (S a)) (S n))
                      (le_n (S n))
                      (matita_basics_logic.rewrite_l
                         nat
                         (S n)
                         (__:(pts.El pts.var nat) =>
                          matita_basics_logic.eq
                            (pts.u pts.var)
                            (le (S n) (S n))
                            (le __ (S n)))
                         (matita_basics_logic.refl (pts.u pts.var) (le (S n) (S n)))
                         (f (S a))
                         H))
                   (matita_basics_logic.eq_coerc
                      (lt (f (S a)) (f (S (S a))))
                      (lt (S n) (f (S (S a))))
                      (incr (S a))
                      (matita_basics_logic.rewrite_l
                         nat
                         (S n)
                         (__:(pts.El pts.var nat) =>
                          matita_basics_logic.eq
                            (pts.u pts.var)
                            (lt __ (f (S (S a))))
                            (lt (S n) (f (S (S a)))))
                         (matita_basics_logic.refl (pts.u pts.var) (lt (S n) (f (S (S a)))))
                         (f (S a))
                         H))))
             (le_to_or_lt_eq (S n) (f (S a)) ltnr))
          _clearme0)
       _clearme)
    m
    lem.

def le_inv_plus_l :
  x:(pts.El pts.var nat) ->
  y:(pts.El pts.var nat) ->
  z:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le (plus x y) z)) ->
  pts.El pts.var (matita_basics_logic.And (le x (minus z y)) (le y z))
  :=
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  z:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (le (plus x y) z)) =>
  matita_basics_logic.conj
    (le x (minus z y))
    (le y z)
    (le_plus_to_minus_r x y z auto)
    (le_plus_b
       x
       y
       z
       (matita_basics_logic.eq_coerc
          (le (plus x y) z)
          (le (plus y x) z)
          auto
          (matita_basics_logic.rewrite_r
             nat
             (plus y x)
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq (pts.u pts.var) (le __ z) (le (plus y x) z))
             (matita_basics_logic.refl (pts.u pts.var) (le (plus y x) z))
             (plus x y)
             (commutative_plus x y)))).

def lt_inv_plus_l :
  x:(pts.El pts.var nat) ->
  y:(pts.El pts.var nat) ->
  z:(pts.El pts.var nat) ->
  __:(pts.El pts.var (lt (plus x y) z)) ->
  pts.El pts.var (matita_basics_logic.And (lt x z) (lt y (minus z x)))
  :=
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  z:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (lt (plus x y) z)) =>
  matita_basics_logic.conj
    (lt x z)
    (lt y (minus z x))
    (lt_to_le_to_lt
       x
       (S (plus x y))
       z
       (matita_basics_logic.eq_coerc
          (lt x (plus (plus x O) (S y)))
          (lt x (S (plus x y)))
          (lt_plus_Sn_r x O y)
          (matita_basics_logic.rewrite_r
             nat
             (plus x (plus O (S y)))
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq (pts.u pts.var) (lt x __) (lt x (S (plus x y))))
             (matita_basics_logic.rewrite_r
                nat
                (plus x (S y))
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq (pts.u pts.var) (lt x (plus x (plus O (S y)))) (lt x __))
                (matita_basics_logic.rewrite_l
                   nat
                   (S y)
                   (__:(pts.El pts.var nat) =>
                    matita_basics_logic.eq
                      (pts.u pts.var)
                      (lt x (plus x __))
                      (lt x (plus x (S y))))
                   (matita_basics_logic.refl (pts.u pts.var) (lt x (plus x (S y))))
                   (plus O (S y))
                   (plus_O_n (S y)))
                (S (plus x y))
                (plus_n_Sm x y))
             (plus (plus x O) (S y))
             (associative_plus x O (S y))))
       auto)
    (lt_plus_to_minus_r
       y
       x
       z
       (matita_basics_logic.eq_coerc
          (lt (plus x y) z)
          (lt (plus y x) z)
          auto
          (matita_basics_logic.rewrite_r
             nat
             (plus x y)
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq (pts.u pts.var) (lt (plus x y) z) (lt __ z))
             (matita_basics_logic.refl (pts.u pts.var) (lt (plus x y) z))
             (plus y x)
             (commutative_plus y x)))).

def lt_or_ge :
  m:(pts.El pts.var nat) ->
  n:(pts.El pts.var nat) -> pts.El pts.var (matita_basics_logic.Or (lt m n) (le n m))
  :=
  m:(pts.El pts.var nat) =>
  n:(pts.El pts.var nat) =>
  matita_basics_logic.Or_ind
    (lt m n)
    (matita_basics_logic.Not (lt m n))
    (_x_170:(pts.El pts.var (matita_basics_logic.Or (lt m n) (matita_basics_logic.Not (lt m n)))) =>
     matita_basics_logic.Or (lt m n) (le n m))
    (_x_171:(pts.El pts.var (lt m n)) => matita_basics_logic.or_introl (lt m n) (le n m) _x_171)
    (_x_172:(pts.El pts.var (matita_basics_logic.Not (lt m n))) =>
     matita_basics_logic.or_intror (lt m n) (le n m) (not_lt_to_le m n _x_172))
    (decidable_lt m n).

def le_or_ge :
  m:(pts.El pts.var nat) ->
  n:(pts.El pts.var nat) -> pts.El pts.var (matita_basics_logic.Or (le m n) (le n m))
  :=
  m:(pts.El pts.var nat) =>
  n:(pts.El pts.var nat) =>
  matita_basics_logic.Or_ind
    (le m n)
    (matita_basics_logic.Not (le m n))
    (_x_170:(pts.El pts.var (matita_basics_logic.Or (le m n) (matita_basics_logic.Not (le m n)))) =>
     matita_basics_logic.Or (le m n) (le n m))
    (_x_171:(pts.El pts.var (le m n)) => matita_basics_logic.or_introl (le m n) (le n m) _x_171)
    (_x_172:(pts.El pts.var (matita_basics_logic.Not (le m n))) =>
     matita_basics_logic.or_intror (le m n) (le n m) (lt_to_le n m (not_le_to_lt m n _x_172)))
    (decidable_le m n).

def le_inv_S1 :
  x:(pts.El pts.var nat) ->
  y:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le (S x) y)) ->
  pts.El
    pts.var
    (matita_basics_logic.ex2
       nat
       (z:(pts.El pts.var nat) => le x z)
       (z:(pts.El pts.var nat) => matita_basics_logic.eq nat y (S z)))
  :=
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  H:(pts.El pts.var (le (S x) y)) =>
  le_ind
    (S x)
    (x_417:(pts.El pts.var nat) =>
     _x_418:(pts.El pts.var (le (S x) x_417)) =>
     matita_basics_logic.ex2
       nat
       (z:(pts.El pts.var nat) => le x z)
       (z:(pts.El pts.var nat) => matita_basics_logic.eq nat x_417 (S z)))
    (matita_basics_logic.ex2_intro
       nat
       (z:(pts.El pts.var nat) => le x z)
       (z:(pts.El pts.var nat) => matita_basics_logic.eq nat (S x) (S z))
       x
       (matita_basics_logic.eq_coerc
          (le x (plus O x))
          (le x x)
          (le_plus_n O x)
          (matita_basics_logic.rewrite_l
             nat
             x
             (__:(pts.El pts.var nat) => matita_basics_logic.eq (pts.u pts.var) (le x __) (le x x))
             (matita_basics_logic.refl (pts.u pts.var) (le x x))
             (plus O x)
             (plus_O_n x)))
       (matita_basics_logic.refl nat (S x)))
    (y0:(pts.El pts.var nat) =>
     __:(pts.El pts.var (le (S x) y0)) =>
     _clearme:(pts.El
                 pts.var
                 (matita_basics_logic.ex2
                    nat
                    (z:(pts.El pts.var nat) => le x z)
                    (z:(pts.El pts.var nat) => matita_basics_logic.eq nat y0 (S z)))) =>
     matita_basics_logic.match_ex2
       nat
       (z:(pts.El pts.var nat) => le x z)
       (z:(pts.El pts.var nat) => matita_basics_logic.eq nat y0 (S z))
       pts.var
       (_0:(pts.El
              pts.var
              (matita_basics_logic.ex2
                 nat
                 (z:(pts.El pts.var nat) => le x z)
                 (z:(pts.El pts.var nat) => matita_basics_logic.eq nat y0 (S z)))) =>
        matita_basics_logic.ex2
          nat
          (z:(pts.El pts.var nat) => le x z)
          (z:(pts.El pts.var nat) => matita_basics_logic.eq nat (S y0) (S z)))
       (n:(pts.El pts.var nat) =>
        Hxn:(pts.El pts.var (le x n)) =>
        H0:(pts.El pts.var (matita_basics_logic.eq nat y0 (S n))) =>
        matita_basics_logic.eq_ind_r
          nat
          (S n)
          (x0:(pts.El pts.var nat) =>
           _0:(pts.El pts.var (matita_basics_logic.eq nat x0 (S n))) =>
           matita_basics_logic.ex2
             nat
             (z:(pts.El pts.var nat) => le x z)
             (z:(pts.El pts.var nat) => matita_basics_logic.eq nat (S x0) (S z)))
          (matita_basics_logic.ex2_intro
             nat
             (z:(pts.El pts.var nat) => le x z)
             (z:(pts.El pts.var nat) => matita_basics_logic.eq nat (S (S n)) (S z))
             (S n)
             (le_S x n Hxn)
             (matita_basics_logic.refl nat (S (S n))))
          y0
          H0)
       _clearme)
    y
    H.

def nat_ind_plus :
  R:(pts.El pts.var (matita_basics_relations.predicate nat)) ->
  __:(pts.El pts.var (R O)) ->
  __1:(n:(pts.El pts.var nat) -> __1:(pts.El pts.var (R n)) -> pts.El pts.var (R (plus n (S O)))) ->
  n:(pts.El pts.var nat) -> pts.El pts.var (R n)
  :=
  R:(pts.El pts.var (matita_basics_relations.predicate nat)) =>
  auto:(pts.El pts.var (R O)) =>
  auto':(n:(pts.El pts.var nat) -> __:(pts.El pts.var (R n)) -> pts.El pts.var (R (plus n (S O)))) =>
  n:(pts.El pts.var nat) =>
  nat_ind
    R
    auto
    (x_366:(pts.El pts.var nat) =>
     _x_368:(pts.El pts.var (R x_366)) =>
     matita_basics_logic.eq_coerc
       (R (plus x_366 (S O)))
       (R (S x_366))
       (auto' x_366 _x_368)
       (matita_basics_logic.rewrite_l
          nat
          (S x_366)
          (__:(pts.El pts.var nat) => matita_basics_logic.eq (pts.u pts.var) (R __) (R (S x_366)))
          (matita_basics_logic.refl (pts.u pts.var) (R (S x_366)))
          (plus x_366 (S O))
          (matita_basics_logic.rewrite_r
             nat
             (plus x_366 O)
             (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (S __) (plus x_366 (S O)))
             (plus_n_Sm x_366 O)
             x_366
             (plus_n_O x_366))))
    n.

def lt_O_n_elim :
  n:(pts.El pts.var nat) ->
  __:(pts.El pts.var (lt O n)) ->
  P:(__1:(pts.El pts.var nat) -> pts.U pts.var) ->
  __1:(m:(pts.El pts.var nat) -> pts.El pts.var (P (S m))) -> pts.El pts.var (P n)
  :=
  n:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       (lt O _x_365)
       (__:(pts.El pts.var (lt O _x_365)) =>
        pts.Prod
          pts.var
          pts.var
          (pts.Prod pts.var pts.var nat (__1:(pts.El pts.var nat) => pts.u pts.var))
          (P:(__1:(pts.El pts.var nat) -> pts.U pts.var) =>
           pts.Prod
             pts.var
             pts.var
             (pts.Prod pts.var pts.var nat (m:(pts.El pts.var nat) => P (S m)))
             (__1:(m:(pts.El pts.var nat) -> pts.El pts.var (P (S m))) => P _x_365))))
    (abs:(pts.El pts.var (lt O O)) =>
     matita_basics_logic.False_ind
       (_x_66:(pts.El pts.var matita_basics_logic.False) =>
        pts.Prod
          pts.var
          pts.var
          (pts.Prod pts.var pts.var nat (__:(pts.El pts.var nat) => pts.u pts.var))
          (P:(__:(pts.El pts.var nat) -> pts.U pts.var) =>
           pts.Prod
             pts.var
             pts.var
             (pts.Prod pts.var pts.var nat (m:(pts.El pts.var nat) => P (S m)))
             (__:(m:(pts.El pts.var nat) -> pts.El pts.var (P (S m))) => P O)))
       (matita_basics_logic.absurd (le (S O) O) abs (not_le_Sn_O O)))
    (x_366:(pts.El pts.var nat) =>
     _x_368:(__:(pts.El pts.var (lt O x_366)) ->
             P:(__1:(pts.El pts.var nat) -> pts.U pts.var) ->
             __1:(m:(pts.El pts.var nat) -> pts.El pts.var (P (S m))) -> pts.El pts.var (P x_366)) =>
     auto:(pts.El pts.var (lt O (S x_366))) =>
     P:(__:(pts.El pts.var nat) -> pts.U pts.var) =>
     auto':(m:(pts.El pts.var nat) -> pts.El pts.var (P (S m))) => auto' x_366)
    n.

def le_n_O_elim :
  n:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le n O)) ->
  P:(__1:(pts.El pts.var nat) -> pts.U pts.var) -> __1:(pts.El pts.var (P O)) -> pts.El pts.var (P n)
  :=
  n:(pts.El pts.var nat) =>
  match_nat
    pts.var
    (__:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       (le __ O)
       (__1:(pts.El pts.var (le __ O)) =>
        pts.Prod
          pts.var
          pts.var
          (pts.Prod pts.var pts.var nat (__2:(pts.El pts.var nat) => pts.u pts.var))
          (P:(__2:(pts.El pts.var nat) -> pts.U pts.var) =>
           pts.Prod pts.var pts.var (P O) (__2:(pts.El pts.var (P O)) => P __))))
    (auto:(pts.El pts.var (le O O)) =>
     P:(__:(pts.El pts.var nat) -> pts.U pts.var) => auto':(pts.El pts.var (P O)) => auto')
    (a:(pts.El pts.var nat) =>
     abs:(pts.El pts.var (le (S a) O)) =>
     matita_basics_logic.False_ind
       (_x_66:(pts.El pts.var matita_basics_logic.False) =>
        pts.Prod
          pts.var
          pts.var
          (pts.Prod pts.var pts.var nat (__:(pts.El pts.var nat) => pts.u pts.var))
          (P:(__:(pts.El pts.var nat) -> pts.U pts.var) =>
           pts.Prod pts.var pts.var (P O) (__:(pts.El pts.var (P O)) => P (S a))))
       (matita_basics_logic.absurd (le (S a) O) abs (not_le_Sn_O a)))
    n.

def le_n_Sm_elim :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le n (S m))) ->
  P:(pts.U pts.var) ->
  __1:(__1:(pts.El pts.var (le (S n) (S m))) -> pts.El pts.var P) ->
  __2:(__2:(pts.El pts.var (matita_basics_logic.eq nat n (S m))) -> pts.El pts.var P) ->
  pts.El pts.var P
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  Hle:(pts.El pts.var (le n (S m))) =>
  P:(pts.U pts.var) =>
  le_ind
    n
    (x_417:(pts.El pts.var nat) =>
     _x_418:(pts.El pts.var (le n x_417)) =>
     pts.Prod
       pts.var
       pts.var
       (pts.Prod pts.var pts.var (le (S n) x_417) (__:(pts.El pts.var (le (S n) x_417)) => P))
       (__:(__:(pts.El pts.var (le (S n) x_417)) -> pts.El pts.var P) =>
        pts.Prod
          pts.var
          pts.var
          (pts.Prod
             pts.var
             pts.var
             (matita_basics_logic.eq nat n x_417)
             (__1:(pts.El pts.var (matita_basics_logic.eq nat n x_417)) => P))
          (__1:(__1:(pts.El pts.var (matita_basics_logic.eq nat n x_417)) -> pts.El pts.var P) => P)))
    (auto:(__:(pts.El pts.var (le (S n) n)) -> pts.El pts.var P) =>
     auto':(__:(pts.El pts.var (matita_basics_logic.eq nat n n)) -> pts.El pts.var P) =>
     auto' (matita_basics_logic.refl nat n))
    (m0:(pts.El pts.var nat) =>
     _x_419:(pts.El pts.var (le n m0)) =>
     _x_421:(__:(__:(pts.El pts.var (le (S n) m0)) -> pts.El pts.var P) ->
             __1:(__1:(pts.El pts.var (matita_basics_logic.eq nat n m0)) -> pts.El pts.var P) ->
             pts.El pts.var P) =>
     auto:(__:(pts.El pts.var (le (S n) (S m0))) -> pts.El pts.var P) =>
     auto':(__:(pts.El pts.var (matita_basics_logic.eq nat n (S m0))) -> pts.El pts.var P) =>
     auto (le_S_S n m0 _x_419))
    (S m)
    Hle.

def nat_elim1 :
  n:(pts.El pts.var nat) ->
  P:(__:(pts.El pts.var nat) -> pts.U pts.var) ->
  __:(m:(pts.El pts.var nat) ->
      __:(p:(pts.El pts.var nat) -> __:(pts.El pts.var (lt p m)) -> pts.El pts.var (P p)) ->
      pts.El pts.var (P m)) ->
  pts.El pts.var (P n)
  :=
  n:(pts.El pts.var nat) =>
  P:(__:(pts.El pts.var nat) -> pts.U pts.var) =>
  H:(m:(pts.El pts.var nat) ->
     __:(p:(pts.El pts.var nat) -> __:(pts.El pts.var (lt p m)) -> pts.El pts.var (P p)) ->
     pts.El pts.var (P m)) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       nat
       (q:(pts.El pts.var nat) =>
        pts.Prod pts.var pts.var (le q _x_365) (__:(pts.El pts.var (le q _x_365)) => P q)))
    (q:(pts.El pts.var nat) =>
     HleO:(pts.El pts.var (le q O)) =>
     le_n_O_elim
       q
       HleO
       P
       (H
          O
          (p:(pts.El pts.var nat) =>
           ltpO:(pts.El pts.var (lt p O)) =>
           matita_basics_logic.False_ind
             (_x_66:(pts.El pts.var matita_basics_logic.False) => P p)
             (matita_basics_logic.absurd (le (S p) O) ltpO (not_le_Sn_O p)))))
    (p:(pts.El pts.var nat) =>
     Hind:(q:(pts.El pts.var nat) -> __:(pts.El pts.var (le q p)) -> pts.El pts.var (P q)) =>
     q:(pts.El pts.var nat) =>
     HleS:(pts.El pts.var (le q (S p))) =>
     H
       q
       (a:(pts.El pts.var nat) =>
        lta:(pts.El pts.var (lt a q)) =>
        Hind a (le_S_S_to_le a p (transitive_le (S a) q (S p) lta HleS))))
    n
    n
    (le_n n).

def f_ind_aux :
  A:(pts.U pts.var) ->
  f:(__:(pts.El pts.var A) -> pts.El pts.var nat) ->
  P:(pts.El pts.var (matita_basics_relations.predicate A)) ->
  __:(n:(pts.El pts.var nat) ->
      __:(a:(pts.El pts.var A) -> __:(pts.El pts.var (lt (f a) n)) -> pts.El pts.var (P a)) ->
      a:(pts.El pts.var A) ->
      __1:(pts.El pts.var (matita_basics_logic.eq nat (f a) n)) -> pts.El pts.var (P a)) ->
  n:(pts.El pts.var nat) ->
  a:(pts.El pts.var A) ->
  __1:(pts.El pts.var (matita_basics_logic.eq nat (f a) n)) -> pts.El pts.var (P a)
  :=
  A:(pts.U pts.var) =>
  f:(__:(pts.El pts.var A) -> pts.El pts.var nat) =>
  P:(pts.El pts.var (matita_basics_relations.predicate A)) =>
  H:(n:(pts.El pts.var nat) ->
     __:(a:(pts.El pts.var A) -> __:(pts.El pts.var (lt (f a) n)) -> pts.El pts.var (P a)) ->
     a:(pts.El pts.var A) ->
     __1:(pts.El pts.var (matita_basics_logic.eq nat (f a) n)) -> pts.El pts.var (P a)) =>
  n:(pts.El pts.var nat) =>
  nat_elim1
    n
    (__:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       A
       (a:(pts.El pts.var A) =>
        pts.Prod
          pts.var
          pts.var
          (matita_basics_logic.eq nat (f a) __)
          (__1:(pts.El pts.var (matita_basics_logic.eq nat (f a) __)) => P a)))
    (n0:(pts.El pts.var nat) =>
     auto:(p:(pts.El pts.var nat) ->
           __:(pts.El pts.var (lt p n0)) ->
           a:(pts.El pts.var A) ->
           __1:(pts.El pts.var (matita_basics_logic.eq nat (f a) p)) -> pts.El pts.var (P a)) =>
     a:(pts.El pts.var A) =>
     auto':(pts.El pts.var (matita_basics_logic.eq nat (f a) n0)) =>
     H
       n0
       (a0:(pts.El pts.var A) =>
        auto'':(pts.El pts.var (lt (f a0) n0)) =>
        auto (f a0) auto'' a0 (matita_basics_logic.refl nat (f a0)))
       a
       (matita_basics_logic.rewrite_r
          nat
          n0
          (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ n0)
          (matita_basics_logic.refl nat n0)
          (f a)
          auto')).

def f_ind :
  A:(pts.U pts.var) ->
  f:(__:(pts.El pts.var A) -> pts.El pts.var nat) ->
  P:(pts.El pts.var (matita_basics_relations.predicate A)) ->
  __:(n:(pts.El pts.var nat) ->
      __:(a:(pts.El pts.var A) -> __:(pts.El pts.var (lt (f a) n)) -> pts.El pts.var (P a)) ->
      a:(pts.El pts.var A) ->
      __1:(pts.El pts.var (matita_basics_logic.eq nat (f a) n)) -> pts.El pts.var (P a)) ->
  a:(pts.El pts.var A) -> pts.El pts.var (P a)
  :=
  A:(pts.U pts.var) =>
  f:(__:(pts.El pts.var A) -> pts.El pts.var nat) =>
  P:(pts.El pts.var (matita_basics_relations.predicate A)) =>
  H:(n:(pts.El pts.var nat) ->
     __:(a:(pts.El pts.var A) -> __:(pts.El pts.var (lt (f a) n)) -> pts.El pts.var (P a)) ->
     a:(pts.El pts.var A) ->
     __1:(pts.El pts.var (matita_basics_logic.eq nat (f a) n)) -> pts.El pts.var (P a)) =>
  a:(pts.El pts.var A) => f_ind_aux A f P H (f a) a (matita_basics_logic.refl nat (f a)).

def f2_ind_aux :
  A1:(pts.U pts.var) ->
  A2:(pts.U pts.var) ->
  f:(__:(pts.El pts.var A1) -> __1:(pts.El pts.var A2) -> pts.El pts.var nat) ->
  P:(pts.El pts.var (matita_basics_relations.relation2 A1 A2)) ->
  __:(n:(pts.El pts.var nat) ->
      __:(a1:(pts.El pts.var A1) ->
          a2:(pts.El pts.var A2) -> __:(pts.El pts.var (lt (f a1 a2) n)) -> pts.El pts.var (P a1 a2)) ->
      a1:(pts.El pts.var A1) ->
      a2:(pts.El pts.var A2) ->
      __1:(pts.El pts.var (matita_basics_logic.eq nat (f a1 a2) n)) -> pts.El pts.var (P a1 a2)) ->
  n:(pts.El pts.var nat) ->
  a1:(pts.El pts.var A1) ->
  a2:(pts.El pts.var A2) ->
  __1:(pts.El pts.var (matita_basics_logic.eq nat (f a1 a2) n)) -> pts.El pts.var (P a1 a2)
  :=
  A1:(pts.U pts.var) =>
  A2:(pts.U pts.var) =>
  f:(__:(pts.El pts.var A1) -> __1:(pts.El pts.var A2) -> pts.El pts.var nat) =>
  P:(pts.El pts.var (matita_basics_relations.relation2 A1 A2)) =>
  H:(n:(pts.El pts.var nat) ->
     __:(a1:(pts.El pts.var A1) ->
         a2:(pts.El pts.var A2) -> __:(pts.El pts.var (lt (f a1 a2) n)) -> pts.El pts.var (P a1 a2)) ->
     a1:(pts.El pts.var A1) ->
     a2:(pts.El pts.var A2) ->
     __1:(pts.El pts.var (matita_basics_logic.eq nat (f a1 a2) n)) -> pts.El pts.var (P a1 a2)) =>
  n:(pts.El pts.var nat) =>
  nat_elim1
    n
    (__:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       A1
       (a1:(pts.El pts.var A1) =>
        pts.Prod
          pts.var
          pts.var
          A2
          (a2:(pts.El pts.var A2) =>
           pts.Prod
             pts.var
             pts.var
             (matita_basics_logic.eq nat (f a1 a2) __)
             (__1:(pts.El pts.var (matita_basics_logic.eq nat (f a1 a2) __)) => P a1 a2))))
    (n0:(pts.El pts.var nat) =>
     auto:(p:(pts.El pts.var nat) ->
           __:(pts.El pts.var (lt p n0)) ->
           a1:(pts.El pts.var A1) ->
           a2:(pts.El pts.var A2) ->
           __1:(pts.El pts.var (matita_basics_logic.eq nat (f a1 a2) p)) ->
           pts.El pts.var (P a1 a2)) =>
     a1:(pts.El pts.var A1) =>
     a2:(pts.El pts.var A2) =>
     auto':(pts.El pts.var (matita_basics_logic.eq nat (f a1 a2) n0)) =>
     H
       n0
       (a10:(pts.El pts.var A1) =>
        a20:(pts.El pts.var A2) =>
        auto'':(pts.El pts.var (lt (f a10 a20) n0)) =>
        auto (f a10 a20) auto'' a10 a20 (matita_basics_logic.refl nat (f a10 a20)))
       a1
       a2
       (matita_basics_logic.rewrite_r
          nat
          n0
          (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ n0)
          (matita_basics_logic.refl nat n0)
          (f a1 a2)
          auto')).

def f2_ind :
  A1:(pts.U pts.var) ->
  A2:(pts.U pts.var) ->
  f:(__:(pts.El pts.var A1) -> __1:(pts.El pts.var A2) -> pts.El pts.var nat) ->
  P:(pts.El pts.var (matita_basics_relations.relation2 A1 A2)) ->
  __:(n:(pts.El pts.var nat) ->
      __:(a1:(pts.El pts.var A1) ->
          a2:(pts.El pts.var A2) -> __:(pts.El pts.var (lt (f a1 a2) n)) -> pts.El pts.var (P a1 a2)) ->
      a1:(pts.El pts.var A1) ->
      a2:(pts.El pts.var A2) ->
      __1:(pts.El pts.var (matita_basics_logic.eq nat (f a1 a2) n)) -> pts.El pts.var (P a1 a2)) ->
  a1:(pts.El pts.var A1) -> a2:(pts.El pts.var A2) -> pts.El pts.var (P a1 a2)
  :=
  A1:(pts.U pts.var) =>
  A2:(pts.U pts.var) =>
  f:(__:(pts.El pts.var A1) -> __1:(pts.El pts.var A2) -> pts.El pts.var nat) =>
  P:(pts.El pts.var (matita_basics_relations.relation2 A1 A2)) =>
  H:(n:(pts.El pts.var nat) ->
     __:(a1:(pts.El pts.var A1) ->
         a2:(pts.El pts.var A2) -> __:(pts.El pts.var (lt (f a1 a2) n)) -> pts.El pts.var (P a1 a2)) ->
     a1:(pts.El pts.var A1) ->
     a2:(pts.El pts.var A2) ->
     __1:(pts.El pts.var (matita_basics_logic.eq nat (f a1 a2) n)) -> pts.El pts.var (P a1 a2)) =>
  a1:(pts.El pts.var A1) =>
  a2:(pts.El pts.var A2) =>
  f2_ind_aux A1 A2 f P H (f a1 a2) a1 a2 (matita_basics_logic.refl nat (f a1 a2)).

def f3_ind_aux :
  A1:(pts.U pts.var) ->
  A2:(pts.U pts.var) ->
  A3:(pts.U pts.var) ->
  f:(__:(pts.El pts.var A1) -> __1:(pts.El pts.var A2) -> __2:(pts.El pts.var A3) -> pts.El pts.var nat) ->
  P:(pts.El pts.var (matita_basics_relations.relation3 A1 A2 A3)) ->
  __:(n:(pts.El pts.var nat) ->
      __:(a1:(pts.El pts.var A1) ->
          a2:(pts.El pts.var A2) ->
          a3:(pts.El pts.var A3) -> __:(pts.El pts.var (lt (f a1 a2 a3) n)) -> pts.El pts.var (P a1 a2 a3)) ->
      a1:(pts.El pts.var A1) ->
      a2:(pts.El pts.var A2) ->
      a3:(pts.El pts.var A3) ->
      __1:(pts.El pts.var (matita_basics_logic.eq nat (f a1 a2 a3) n)) -> pts.El pts.var (P a1 a2 a3)) ->
  n:(pts.El pts.var nat) ->
  a1:(pts.El pts.var A1) ->
  a2:(pts.El pts.var A2) ->
  a3:(pts.El pts.var A3) ->
  __1:(pts.El pts.var (matita_basics_logic.eq nat (f a1 a2 a3) n)) -> pts.El pts.var (P a1 a2 a3)
  :=
  A1:(pts.U pts.var) =>
  A2:(pts.U pts.var) =>
  A3:(pts.U pts.var) =>
  f:(__:(pts.El pts.var A1) ->
     __1:(pts.El pts.var A2) -> __2:(pts.El pts.var A3) -> pts.El pts.var nat) =>
  P:(pts.El pts.var (matita_basics_relations.relation3 A1 A2 A3)) =>
  H:(n:(pts.El pts.var nat) ->
     __:(a1:(pts.El pts.var A1) ->
         a2:(pts.El pts.var A2) ->
         a3:(pts.El pts.var A3) ->
         __:(pts.El pts.var (lt (f a1 a2 a3) n)) -> pts.El pts.var (P a1 a2 a3)) ->
     a1:(pts.El pts.var A1) ->
     a2:(pts.El pts.var A2) ->
     a3:(pts.El pts.var A3) ->
     __1:(pts.El pts.var (matita_basics_logic.eq nat (f a1 a2 a3) n)) ->
     pts.El pts.var (P a1 a2 a3)) =>
  n:(pts.El pts.var nat) =>
  nat_elim1
    n
    (__:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       A1
       (a1:(pts.El pts.var A1) =>
        pts.Prod
          pts.var
          pts.var
          A2
          (a2:(pts.El pts.var A2) =>
           pts.Prod
             pts.var
             pts.var
             A3
             (a3:(pts.El pts.var A3) =>
              pts.Prod
                pts.var
                pts.var
                (matita_basics_logic.eq nat (f a1 a2 a3) __)
                (__1:(pts.El pts.var (matita_basics_logic.eq nat (f a1 a2 a3) __)) => P a1 a2 a3)))))
    (n0:(pts.El pts.var nat) =>
     auto:(p:(pts.El pts.var nat) ->
           __:(pts.El pts.var (lt p n0)) ->
           a1:(pts.El pts.var A1) ->
           a2:(pts.El pts.var A2) ->
           a3:(pts.El pts.var A3) ->
           __1:(pts.El pts.var (matita_basics_logic.eq nat (f a1 a2 a3) p)) ->
           pts.El pts.var (P a1 a2 a3)) =>
     a1:(pts.El pts.var A1) =>
     a2:(pts.El pts.var A2) =>
     a3:(pts.El pts.var A3) =>
     auto':(pts.El pts.var (matita_basics_logic.eq nat (f a1 a2 a3) n0)) =>
     H
       n0
       (a10:(pts.El pts.var A1) =>
        a20:(pts.El pts.var A2) =>
        a30:(pts.El pts.var A3) =>
        auto'':(pts.El pts.var (lt (f a10 a20 a30) n0)) =>
        auto (f a10 a20 a30) auto'' a10 a20 a30 (matita_basics_logic.refl nat (f a10 a20 a30)))
       a1
       a2
       a3
       (matita_basics_logic.rewrite_r
          nat
          n0
          (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ n0)
          (matita_basics_logic.refl nat n0)
          (f a1 a2 a3)
          auto')).

def f3_ind :
  A1:(pts.U pts.var) ->
  A2:(pts.U pts.var) ->
  A3:(pts.U pts.var) ->
  f:(__:(pts.El pts.var A1) -> __1:(pts.El pts.var A2) -> __2:(pts.El pts.var A3) -> pts.El pts.var nat) ->
  P:(pts.El pts.var (matita_basics_relations.relation3 A1 A2 A3)) ->
  __:(n:(pts.El pts.var nat) ->
      __:(a1:(pts.El pts.var A1) ->
          a2:(pts.El pts.var A2) ->
          a3:(pts.El pts.var A3) -> __:(pts.El pts.var (lt (f a1 a2 a3) n)) -> pts.El pts.var (P a1 a2 a3)) ->
      a1:(pts.El pts.var A1) ->
      a2:(pts.El pts.var A2) ->
      a3:(pts.El pts.var A3) ->
      __1:(pts.El pts.var (matita_basics_logic.eq nat (f a1 a2 a3) n)) -> pts.El pts.var (P a1 a2 a3)) ->
  a1:(pts.El pts.var A1) ->
  a2:(pts.El pts.var A2) -> a3:(pts.El pts.var A3) -> pts.El pts.var (P a1 a2 a3)
  :=
  A1:(pts.U pts.var) =>
  A2:(pts.U pts.var) =>
  A3:(pts.U pts.var) =>
  f:(__:(pts.El pts.var A1) ->
     __1:(pts.El pts.var A2) -> __2:(pts.El pts.var A3) -> pts.El pts.var nat) =>
  P:(pts.El pts.var (matita_basics_relations.relation3 A1 A2 A3)) =>
  H:(n:(pts.El pts.var nat) ->
     __:(a1:(pts.El pts.var A1) ->
         a2:(pts.El pts.var A2) ->
         a3:(pts.El pts.var A3) ->
         __:(pts.El pts.var (lt (f a1 a2 a3) n)) -> pts.El pts.var (P a1 a2 a3)) ->
     a1:(pts.El pts.var A1) ->
     a2:(pts.El pts.var A2) ->
     a3:(pts.El pts.var A3) ->
     __1:(pts.El pts.var (matita_basics_logic.eq nat (f a1 a2 a3) n)) ->
     pts.El pts.var (P a1 a2 a3)) =>
  a1:(pts.El pts.var A1) =>
  a2:(pts.El pts.var A2) =>
  a3:(pts.El pts.var A3) =>
  f3_ind_aux A1 A2 A3 f P H (f a1 a2 a3) a1 a2 a3 (matita_basics_logic.refl nat (f a1 a2 a3)).

def lt_to_not_eq :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (lt n m)) ->
  pts.El pts.var (matita_basics_logic.Not (matita_basics_logic.eq nat n m))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  H:(pts.El pts.var (lt n m)) =>
  matita_basics_logic.not_to_not
    (matita_basics_logic.eq nat n m)
    matita_basics_logic.False
    (auto:(pts.El pts.var (matita_basics_logic.eq nat n m)) =>
     matita_basics_logic.absurd
       (le (S n) n)
       (matita_basics_logic.eq_coerc
          (le (S n) m)
          (le (S n) n)
          H
          (matita_basics_logic.rewrite_l
             nat
             n
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq (pts.u pts.var) (le (S n) __) (le (S n) n))
             (matita_basics_logic.refl (pts.u pts.var) (le (S n) n))
             m
             auto))
       (not_le_Sn_n n))
    (matita_basics_logic.nmk
       matita_basics_logic.False
       (auto:(pts.El pts.var matita_basics_logic.False) => auto)).

def le_n_O_to_eq :
  n:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le n O)) -> pts.El pts.var (matita_basics_logic.eq nat O n)
  :=
  n:(pts.El pts.var nat) =>
  match_nat
    pts.var
    (__:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       (le __ O)
       (__1:(pts.El pts.var (le __ O)) => matita_basics_logic.eq nat O __))
    (auto:(pts.El pts.var (le O O)) => matita_basics_logic.refl nat O)
    (a:(pts.El pts.var nat) =>
     abs:(pts.El pts.var (le (S a) O)) =>
     matita_basics_logic.False_ind
       (_x_66:(pts.El pts.var matita_basics_logic.False) => matita_basics_logic.eq nat O (S a))
       (matita_basics_logic.absurd (le (S a) O) abs (not_le_Sn_O a)))
    n.

def le_to_le_to_eq :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le n m)) ->
  __1:(pts.El pts.var (le m n)) -> pts.El pts.var (matita_basics_logic.eq nat n m)
  :=
  nat_elim2
    (__:(pts.El pts.var nat) =>
     _0:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       (le __ _0)
       (__1:(pts.El pts.var (le __ _0)) =>
        pts.Prod
          pts.var
          pts.var
          (le _0 __)
          (__2:(pts.El pts.var (le _0 __)) => matita_basics_logic.eq nat __ _0)))
    (n:(pts.El pts.var nat) =>
     auto:(pts.El pts.var (le O n)) =>
     auto':(pts.El pts.var (le n O)) =>
     matita_basics_logic.sym_eq
       nat
       n
       O
       (matita_basics_logic.sym_eq
          nat
          O
          n
          (matita_basics_logic.eq_coerc
             (matita_basics_logic.eq nat O n)
             (matita_basics_logic.eq nat O n)
             (le_n_O_to_eq n auto')
             (matita_basics_logic.refl (pts.u pts.var) (matita_basics_logic.eq nat O n)))))
    (n:(pts.El pts.var nat) =>
     auto:(pts.El pts.var (le (S n) O)) =>
     auto':(pts.El pts.var (le O (S n))) =>
     matita_basics_logic.sym_eq nat O (S n) (le_n_O_to_eq (S n) auto))
    (n:(pts.El pts.var nat) =>
     m:(pts.El pts.var nat) =>
     auto:(__:(pts.El pts.var (le n m)) ->
           __1:(pts.El pts.var (le m n)) -> pts.El pts.var (matita_basics_logic.eq nat n m)) =>
     auto':(pts.El pts.var (le (S n) (S m))) =>
     auto'':(pts.El pts.var (le (S m) (S n))) =>
     matita_basics_logic.eq_f
       nat
       nat
       S
       n
       m
       (auto
          (matita_basics_logic.eq_coerc
             (le (pred (S n)) (pred (S m)))
             (le n m)
             (monotonic_pred (S n) (S m) auto')
             (matita_basics_logic.rewrite_l
                nat
                n
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq (pts.u pts.var) (le __ (pred (S m))) (le n m))
                (matita_basics_logic.rewrite_l
                   nat
                   m
                   (__:(pts.El pts.var nat) =>
                    matita_basics_logic.eq (pts.u pts.var) (le n __) (le n m))
                   (matita_basics_logic.refl (pts.u pts.var) (le n m))
                   (pred (S m))
                   (pred_Sn m))
                (pred (S n))
                (pred_Sn n)))
          (matita_basics_logic.eq_coerc
             (le (pred (S m)) (pred (S n)))
             (le m n)
             (monotonic_pred (S m) (S n) auto'')
             (matita_basics_logic.rewrite_l
                nat
                m
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq (pts.u pts.var) (le __ (pred (S n))) (le m n))
                (matita_basics_logic.rewrite_l
                   nat
                   n
                   (__:(pts.El pts.var nat) =>
                    matita_basics_logic.eq (pts.u pts.var) (le m __) (le m n))
                   (matita_basics_logic.refl (pts.u pts.var) (le m n))
                   (pred (S n))
                   (pred_Sn n))
                (pred (S m))
                (pred_Sn m))))).

def increasing_to_injective :
  f:(__:(pts.El pts.var nat) -> pts.El pts.var nat) ->
  __:(pts.El pts.var (increasing f)) ->
  pts.El pts.var (matita_basics_relations.{|injective|} nat nat f)
  :=
  f:(__:(pts.El pts.var nat) -> pts.El pts.var nat) =>
  incr:(pts.El pts.var (increasing f)) =>
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  matita_basics_logic.match_Or
    (le n m)
    (matita_basics_logic.Not (le n m))
    pts.var
    (__:(pts.El pts.var (matita_basics_logic.Or (le n m) (matita_basics_logic.Not (le n m)))) =>
     pts.Prod
       pts.var
       pts.var
       (matita_basics_logic.eq nat (f n) (f m))
       (__1:(pts.El pts.var (matita_basics_logic.eq nat (f n) (f m))) =>
        matita_basics_logic.eq nat n m))
    (lenm:(pts.El pts.var (le n m)) =>
     matita_basics_logic.match_Or
       (lt n m)
       (matita_basics_logic.eq nat n m)
       pts.var
       (__:(pts.El pts.var (matita_basics_logic.Or (lt n m) (matita_basics_logic.eq nat n m))) =>
        pts.Prod
          pts.var
          pts.var
          (matita_basics_logic.eq nat (f n) (f m))
          (__1:(pts.El pts.var (matita_basics_logic.eq nat (f n) (f m))) =>
           matita_basics_logic.eq nat n m))
       (lenm0:(pts.El pts.var (lt n m)) =>
        eqf:(pts.El pts.var (matita_basics_logic.eq nat (f n) (f m))) =>
        matita_basics_logic.False_ind
          (_x_66:(pts.El pts.var matita_basics_logic.False) => matita_basics_logic.eq nat n m)
          (matita_basics_logic.absurd
             (matita_basics_logic.eq nat (f n) (f m))
             eqf
             (lt_to_not_eq (f n) (f m) (increasing_to_monotonic f incr n m lenm0))))
       (auto:(pts.El pts.var (matita_basics_logic.eq nat n m)) =>
        auto':(pts.El pts.var (matita_basics_logic.eq nat (f n) (f m))) =>
        matita_basics_logic.rewrite_l
          nat
          n
          (__:(pts.El pts.var nat) => matita_basics_logic.eq nat n __)
          (matita_basics_logic.refl nat n)
          m
          auto)
       (le_to_or_lt_eq n m lenm))
    (nlenm:(pts.El pts.var (matita_basics_logic.Not (le n m))) =>
     eqf:(pts.El pts.var (matita_basics_logic.eq nat (f n) (f m))) =>
     matita_basics_logic.False_ind
       (_x_66:(pts.El pts.var matita_basics_logic.False) => matita_basics_logic.eq nat n m)
       (matita_basics_logic.absurd
          (matita_basics_logic.eq nat (f n) (f m))
          eqf
          (matita_basics_logic.sym_not_eq
             nat
             (f m)
             (f n)
             (lt_to_not_eq
                (f m)
                (f n)
                (increasing_to_monotonic f incr m n (not_le_to_lt n m nlenm))))))
    (decidable_le n m).

def minus_Sn_m :
  m:(pts.El pts.var nat) ->
  n:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le m n)) ->
  pts.El pts.var (matita_basics_logic.eq nat (minus (S n) m) (S (minus n m)))
  :=
  nat_elim2
    (__:(pts.El pts.var nat) =>
     _0:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       (le __ _0)
       (__1:(pts.El pts.var (le __ _0)) =>
        matita_basics_logic.eq nat (minus (S _0) __) (S (minus _0 __))))
    (n:(pts.El pts.var nat) =>
     auto:(pts.El pts.var (le O n)) =>
     matita_basics_logic.rewrite_l
       nat
       (S n)
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (S (minus n O)))
       (matita_basics_logic.rewrite_l
          nat
          n
          (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (S n) (S __))
          (matita_basics_logic.refl nat (S n))
          (minus n O)
          (minus_n_O n))
       (minus (S n) O)
       (minus_n_O (S n)))
    (n:(pts.El pts.var nat) =>
     abs:(pts.El pts.var (le (S n) O)) =>
     matita_basics_logic.False_ind
       (_x_66:(pts.El pts.var matita_basics_logic.False) =>
        matita_basics_logic.eq nat (minus (S O) (S n)) (S (minus O (S n))))
       (matita_basics_logic.absurd (le (S n) O) abs (not_le_Sn_O n)))
    (n:(pts.El pts.var nat) =>
     m:(pts.El pts.var nat) =>
     Hind:(__:(pts.El pts.var (le n m)) ->
           pts.El pts.var (matita_basics_logic.eq nat (minus (S m) n) (S (minus m n)))) =>
     c:(pts.El pts.var (le (S n) (S m))) =>
     matita_basics_logic.eq_coerc
       (matita_basics_logic.eq nat (minus (S m) n) (S (minus m n)))
       (matita_basics_logic.eq nat (minus (S (S m)) (S n)) (S (minus (S m) (S n))))
       (Hind
          (matita_basics_logic.eq_coerc
             (le (pred (S n)) (pred (S m)))
             (le n m)
             (monotonic_pred (S n) (S m) c)
             (matita_basics_logic.rewrite_l
                nat
                n
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq (pts.u pts.var) (le __ (pred (S m))) (le n m))
                (matita_basics_logic.rewrite_l
                   nat
                   m
                   (__:(pts.El pts.var nat) =>
                    matita_basics_logic.eq (pts.u pts.var) (le n __) (le n m))
                   (matita_basics_logic.refl (pts.u pts.var) (le n m))
                   (pred (S m))
                   (pred_Sn m))
                (pred (S n))
                (pred_Sn n))))
       (matita_basics_logic.rewrite_r
          nat
          (minus (S m) n)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq
             (pts.u pts.var)
             (matita_basics_logic.eq nat (minus (S m) n) (S (minus m n)))
             (matita_basics_logic.eq nat __ (S (minus (S m) (S n)))))
          (matita_basics_logic.rewrite_r
             nat
             (minus m n)
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq
                (pts.u pts.var)
                (matita_basics_logic.eq nat (minus (S m) n) (S (minus m n)))
                (matita_basics_logic.eq nat (minus (S m) n) (S __)))
             (matita_basics_logic.refl
                (pts.u pts.var)
                (matita_basics_logic.eq nat (minus (S m) n) (S (minus m n))))
             (minus (S m) (S n))
             (minus_S_S m n))
          (minus (S (S m)) (S n))
          (minus_S_S (S m) n))).

def plus_minus :
  m:(pts.El pts.var nat) ->
  n:(pts.El pts.var nat) ->
  p:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le m n)) ->
  pts.El pts.var (matita_basics_logic.eq nat (plus (minus n m) p) (minus (plus n p) m))
  :=
  nat_elim2
    (__:(pts.El pts.var nat) =>
     _0:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       nat
       (p:(pts.El pts.var nat) =>
        pts.Prod
          pts.var
          pts.var
          (le __ _0)
          (__1:(pts.El pts.var (le __ _0)) =>
           matita_basics_logic.eq nat (plus (minus _0 __) p) (minus (plus _0 p) __))))
    (n:(pts.El pts.var nat) =>
     p:(pts.El pts.var nat) =>
     auto:(pts.El pts.var (le O n)) =>
     matita_basics_logic.rewrite_l
       nat
       n
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (plus __ p) (minus (plus n p) O))
       (matita_basics_logic.rewrite_l
          nat
          (plus n p)
          (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (plus n p) __)
          (matita_basics_logic.refl nat (plus n p))
          (minus (plus n p) O)
          (minus_n_O (plus n p)))
       (minus n O)
       (minus_n_O n))
    (n:(pts.El pts.var nat) =>
     p:(pts.El pts.var nat) =>
     abs:(pts.El pts.var (le (S n) O)) =>
     matita_basics_logic.False_ind
       (_x_66:(pts.El pts.var matita_basics_logic.False) =>
        matita_basics_logic.eq nat (plus (minus O (S n)) p) (minus (plus O p) (S n)))
       (matita_basics_logic.absurd (le (S n) O) abs (not_le_Sn_O n)))
    (n:(pts.El pts.var nat) =>
     m:(pts.El pts.var nat) =>
     auto:(p:(pts.El pts.var nat) ->
           __:(pts.El pts.var (le n m)) ->
           pts.El pts.var (matita_basics_logic.eq nat (plus (minus m n) p) (minus (plus m p) n))) =>
     p:(pts.El pts.var nat) =>
     auto':(pts.El pts.var (le (S n) (S m))) =>
     auto
       p
       (matita_basics_logic.eq_coerc
          (le (pred (S n)) (pred (S m)))
          (le n m)
          (monotonic_pred (S n) (S m) auto')
          (matita_basics_logic.rewrite_l
             nat
             n
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq (pts.u pts.var) (le __ (pred (S m))) (le n m))
             (matita_basics_logic.rewrite_l
                nat
                m
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq (pts.u pts.var) (le n __) (le n m))
                (matita_basics_logic.refl (pts.u pts.var) (le n m))
                (pred (S m))
                (pred_Sn m))
             (pred (S n))
             (pred_Sn n)))).

def minus_plus_m_m :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) -> pts.El pts.var (matita_basics_logic.eq nat n (minus (plus n m) m))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  matita_basics_logic.eq_coerc
    (matita_basics_logic.eq nat (plus (minus m m) n) (minus (plus m n) m))
    (matita_basics_logic.eq nat n (minus (plus n m) m))
    (plus_minus m m n (le_n m))
    (matita_basics_logic.rewrite_l
       nat
       O
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq
          (pts.u pts.var)
          (matita_basics_logic.eq nat (plus __ n) (minus (plus m n) m))
          (matita_basics_logic.eq nat n (minus (plus n m) m)))
       (matita_basics_logic.rewrite_l
          nat
          n
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq
             (pts.u pts.var)
             (matita_basics_logic.eq nat __ (minus (plus m n) m))
             (matita_basics_logic.eq nat n (minus (plus n m) m)))
          (matita_basics_logic.rewrite_r
             nat
             (plus n m)
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq
                (pts.u pts.var)
                (matita_basics_logic.eq nat n (minus __ m))
                (matita_basics_logic.eq nat n (minus (plus n m) m)))
             (matita_basics_logic.refl
                (pts.u pts.var)
                (matita_basics_logic.eq nat n (minus (plus n m) m)))
             (plus m n)
             (commutative_plus m n))
          (plus O n)
          (plus_O_n n))
       (minus m m)
       (minus_n_n m)).

def plus_minus_m_m :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le m n)) -> pts.El pts.var (matita_basics_logic.eq nat n (plus (minus n m) m))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  lemn:(pts.El pts.var (le m n)) =>
  matita_basics_logic.sym_eq
    nat
    (plus (minus n m) m)
    n
    (matita_basics_logic.eq_coerc
       (matita_basics_logic.eq nat (plus (minus n m) m) (minus (plus n m) m))
       (matita_basics_logic.eq nat (plus (minus n m) m) n)
       (plus_minus m n m lemn)
       (matita_basics_logic.rewrite_r
          nat
          (plus m (minus n m))
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq
             (pts.u pts.var)
             (matita_basics_logic.eq nat (plus (minus n m) m) (minus (plus n m) m))
             (matita_basics_logic.eq nat __ n))
          (matita_basics_logic.rewrite_r
             nat
             (plus m (minus n m))
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq
                (pts.u pts.var)
                (matita_basics_logic.eq nat __ (minus (plus n m) m))
                (matita_basics_logic.eq nat (plus m (minus n m)) n))
             (matita_basics_logic.rewrite_l
                nat
                n
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq
                   (pts.u pts.var)
                   (matita_basics_logic.eq nat (plus m (minus n m)) __)
                   (matita_basics_logic.eq nat (plus m (minus n m)) n))
                (matita_basics_logic.refl
                   (pts.u pts.var)
                   (matita_basics_logic.eq nat (plus m (minus n m)) n))
                (minus (plus n m) m)
                (minus_plus_m_m n m))
             (plus (minus n m) m)
             (commutative_plus (minus n m) m))
          (plus (minus n m) m)
          (commutative_plus (minus n m) m))).

def minus_to_plus :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  p:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le m n)) ->
  __1:(pts.El pts.var (matita_basics_logic.eq nat (minus n m) p)) ->
  pts.El pts.var (matita_basics_logic.eq nat n (plus m p))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  p:(pts.El pts.var nat) =>
  lemn:(pts.El pts.var (le m n)) =>
  eqp:(pts.El pts.var (matita_basics_logic.eq nat (minus n m) p)) =>
  matita_basics_logic.eq_coerc
    (matita_basics_logic.eq nat n (plus (minus n m) m))
    (matita_basics_logic.eq nat n (plus m p))
    (plus_minus_m_m n m lemn)
    (matita_basics_logic.rewrite_r
       nat
       (plus m (minus n m))
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq
          (pts.u pts.var)
          (matita_basics_logic.eq nat n __)
          (matita_basics_logic.eq nat n (plus m p)))
       (matita_basics_logic.rewrite_r
          nat
          p
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq
             (pts.u pts.var)
             (matita_basics_logic.eq nat n (plus m __))
             (matita_basics_logic.eq nat n (plus m p)))
          (matita_basics_logic.refl (pts.u pts.var) (matita_basics_logic.eq nat n (plus m p)))
          (minus n m)
          eqp)
       (plus (minus n m) m)
       (commutative_plus (minus n m) m)).

def plus_to_minus :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  p:(pts.El pts.var nat) ->
  __:(pts.El pts.var (matita_basics_logic.eq nat n (plus m p))) ->
  pts.El pts.var (matita_basics_logic.eq nat (minus n m) p)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  p:(pts.El pts.var nat) =>
  eqp:(pts.El pts.var (matita_basics_logic.eq nat n (plus m p))) =>
  matita_basics_logic.sym_eq
    nat
    p
    (minus n m)
    (matita_basics_logic.eq_coerc
       (matita_basics_logic.eq nat p (minus (plus p m) m))
       (matita_basics_logic.eq nat p (minus n m))
       (minus_plus_m_m p m)
       (matita_basics_logic.rewrite_r
          nat
          (plus m p)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq
             (pts.u pts.var)
             (matita_basics_logic.eq nat p (minus __ m))
             (matita_basics_logic.eq nat p (minus n m)))
          (matita_basics_logic.rewrite_l
             nat
             n
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq
                (pts.u pts.var)
                (matita_basics_logic.eq nat p (minus __ m))
                (matita_basics_logic.eq nat p (minus n m)))
             (matita_basics_logic.refl (pts.u pts.var) (matita_basics_logic.eq nat p (minus n m)))
             (plus m p)
             eqp)
          (plus p m)
          (commutative_plus p m))).

def minus_pred_pred :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (lt O n)) ->
  __1:(pts.El pts.var (lt O m)) ->
  pts.El pts.var (matita_basics_logic.eq nat (minus (pred n) (pred m)) (minus n m))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  posn:(pts.El pts.var (lt O n)) =>
  posm:(pts.El pts.var (lt O m)) =>
  lt_O_n_elim
    n
    posn
    (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (minus (pred __) (pred m)) (minus __ m))
    (lt_O_n_elim
       m
       posm
       (__:(pts.El pts.var nat) =>
        pts.Prod
          pts.var
          pts.var
          nat
          (m0:(pts.El pts.var nat) =>
           matita_basics_logic.eq nat (minus (pred (S m0)) (pred __)) (minus (S m0) __)))
       (m0:(pts.El pts.var nat) =>
        m00:(pts.El pts.var nat) =>
        matita_basics_logic.rewrite_l
          nat
          m00
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq nat (minus __ (pred (S m0))) (minus (S m00) (S m0)))
          (matita_basics_logic.rewrite_l
             nat
             m0
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq nat (minus m00 __) (minus (S m00) (S m0)))
             (matita_basics_logic.rewrite_r
                nat
                (minus m00 m0)
                (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (minus m00 m0) __)
                (matita_basics_logic.refl nat (minus m00 m0))
                (minus (S m00) (S m0))
                (minus_S_S m00 m0))
             (pred (S m0))
             (pred_Sn m0))
          (pred (S m00))
          (pred_Sn m00))).

def plus_minus_associative :
  x:(pts.El pts.var nat) ->
  y:(pts.El pts.var nat) ->
  z:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le z y)) ->
  pts.El pts.var (matita_basics_logic.eq nat (plus x (minus y z)) (minus (plus x y) z))
  :=
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  z:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (le z y)) =>
  matita_basics_logic.eq_coerc
    (matita_basics_logic.eq nat (plus (minus y z) x) (minus (plus y x) z))
    (matita_basics_logic.eq nat (plus x (minus y z)) (minus (plus x y) z))
    (plus_minus z y x auto)
    (matita_basics_logic.rewrite_r
       nat
       (plus x (minus y z))
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq
          (pts.u pts.var)
          (matita_basics_logic.eq nat __ (minus (plus y x) z))
          (matita_basics_logic.eq nat (plus x (minus y z)) (minus (plus x y) z)))
       (matita_basics_logic.rewrite_r
          nat
          (plus x y)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq
             (pts.u pts.var)
             (matita_basics_logic.eq nat (plus x (minus y z)) (minus __ z))
             (matita_basics_logic.eq nat (plus x (minus y z)) (minus (plus x y) z)))
          (matita_basics_logic.refl
             (pts.u pts.var)
             (matita_basics_logic.eq nat (plus x (minus y z)) (minus (plus x y) z)))
          (plus y x)
          (commutative_plus y x))
       (plus (minus y z) x)
       (commutative_plus (minus y z) x)).

def le_n_fn :
  f:(__:(pts.El pts.var nat) -> pts.El pts.var nat) ->
  __:(pts.El pts.var (increasing f)) -> n:(pts.El pts.var nat) -> pts.El pts.var (le n (f n))
  :=
  f:(__:(pts.El pts.var nat) -> pts.El pts.var nat) =>
  incr:(pts.El pts.var (increasing f)) =>
  n:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) => le _x_365 (f _x_365))
    (le_O_n (f O))
    (x_366:(pts.El pts.var nat) =>
     _x_368:(pts.El pts.var (le x_366 (f x_366))) =>
     le_to_lt_to_lt x_366 (f x_366) (f (S x_366)) _x_368 (incr x_366))
    n.

def monotonic_le_minus_l :
  p:(pts.El pts.var nat) ->
  q:(pts.El pts.var nat) ->
  n:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le q p)) -> pts.El pts.var (le (minus q n) (minus p n))
  :=
  nat_elim2
    (__:(pts.El pts.var nat) =>
     _0:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       nat
       (n:(pts.El pts.var nat) =>
        pts.Prod
          pts.var
          pts.var
          (le _0 __)
          (__1:(pts.El pts.var (le _0 __)) => le (minus _0 n) (minus __ n))))
    (p:(pts.El pts.var nat) =>
     q:(pts.El pts.var nat) =>
     lePO:(pts.El pts.var (le p O)) =>
     le_n_O_elim p lePO (__:(pts.El pts.var nat) => le (minus __ q) (minus O q)) (le_n (minus O q)))
    (p:(pts.El pts.var nat) =>
     q:(pts.El pts.var nat) =>
     auto:(pts.El pts.var (le O (S p))) =>
     le_plus_minus_m_m
       (minus O q)
       (match_nat
          pts.var
          (__:(pts.El pts.var nat) => nat)
          (S p)
          (q0:(pts.El pts.var nat) => minus p q0)
          q))
    (p:(pts.El pts.var nat) =>
     q:(pts.El pts.var nat) =>
     Hind:(n0:(pts.El pts.var nat) ->
           __:(pts.El pts.var (le q p)) -> pts.El pts.var (le (minus q n0) (minus p n0))) =>
     n:(pts.El pts.var nat) =>
     match_nat
       pts.var
       (__:(pts.El pts.var nat) =>
        pts.Prod
          pts.var
          pts.var
          (le (S q) (S p))
          (__1:(pts.El pts.var (le (S q) (S p))) => le (minus (S q) __) (minus (S p) __)))
       (auto:(pts.El pts.var (le (S q) (S p))) => auto)
       (a:(pts.El pts.var nat) =>
        leSS:(pts.El pts.var (le (S q) (S p))) =>
        Hind
          a
          (matita_basics_logic.eq_coerc
             (le (pred (S q)) (pred (S p)))
             (le q p)
             (monotonic_pred (S q) (S p) leSS)
             (matita_basics_logic.rewrite_l
                nat
                q
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq (pts.u pts.var) (le __ (pred (S p))) (le q p))
                (matita_basics_logic.rewrite_l
                   nat
                   p
                   (__:(pts.El pts.var nat) =>
                    matita_basics_logic.eq (pts.u pts.var) (le q __) (le q p))
                   (matita_basics_logic.refl (pts.u pts.var) (le q p))
                   (pred (S p))
                   (pred_Sn p))
                (pred (S q))
                (pred_Sn q))))
       n).

def le_minus_to_plus :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  p:(pts.El pts.var nat) -> __:(pts.El pts.var (le (minus n m) p)) -> pts.El pts.var (le n (plus p m))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  p:(pts.El pts.var nat) =>
  lep:(pts.El pts.var (le (minus n m) p)) =>
  transitive_le
    n
    (plus (minus n m) m)
    (plus p m)
    (le_plus_minus_m_m n m)
    (monotonic_le_plus_l m (minus n m) p lep).

def le_minus_to_plus_r :
  a:(pts.El pts.var nat) ->
  b:(pts.El pts.var nat) ->
  c:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le c b)) ->
  __1:(pts.El pts.var (le a (minus b c))) -> pts.El pts.var (le (plus a c) b)
  :=
  a:(pts.El pts.var nat) =>
  b:(pts.El pts.var nat) =>
  c:(pts.El pts.var nat) =>
  Hlecb:(pts.El pts.var (le c b)) =>
  H:(pts.El pts.var (le a (minus b c))) =>
  matita_basics_logic.eq_ind_r
    nat
    (plus (minus b c) c)
    (x:(pts.El pts.var nat) =>
     __:(pts.El pts.var (matita_basics_logic.eq nat x (plus (minus b c) c))) => le (plus a c) x)
    (monotonic_le_plus_l c a (minus b c) H)
    b
    (plus_minus_m_m b c Hlecb).

def le_plus_to_minus :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  p:(pts.El pts.var nat) -> __:(pts.El pts.var (le n (plus p m))) -> pts.El pts.var (le (minus n m) p)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  p:(pts.El pts.var nat) =>
  lep:(pts.El pts.var (le n (plus p m))) =>
  matita_basics_logic.eq_coerc
    (le (minus n m) (minus (plus p m) m))
    (le (minus n m) p)
    (monotonic_le_minus_l (plus p m) n m lep)
    (matita_basics_logic.rewrite_l
       nat
       p
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq (pts.u pts.var) (le (minus n m) __) (le (minus n m) p))
       (matita_basics_logic.refl (pts.u pts.var) (le (minus n m) p))
       (minus (plus p m) m)
       (minus_plus_m_m p m)).

def monotonic_le_minus_r :
  p:(pts.El pts.var nat) ->
  q:(pts.El pts.var nat) ->
  n:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le q p)) -> pts.El pts.var (le (minus n p) (minus n q))
  :=
  p:(pts.El pts.var nat) =>
  q:(pts.El pts.var nat) =>
  n:(pts.El pts.var nat) =>
  lepq:(pts.El pts.var (le q p)) =>
  le_plus_to_minus
    n
    p
    (minus n q)
    (transitive_le
       n
       (plus (minus n q) q)
       (plus (minus n q) p)
       (le_plus_minus_m_m n q)
       (monotonic_le_plus_r (minus n q) q p lepq)).

def increasing_to_le :
  f:(__:(pts.El pts.var nat) -> pts.El pts.var nat) ->
  __:(pts.El pts.var (increasing f)) ->
  m:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_logic.ex nat (i:(pts.El pts.var nat) => le m (f i)))
  :=
  f:(__:(pts.El pts.var nat) -> pts.El pts.var nat) =>
  incr:(pts.El pts.var (increasing f)) =>
  m:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) =>
     matita_basics_logic.ex nat (i:(pts.El pts.var nat) => le _x_365 (f i)))
    (matita_basics_logic.ex_intro
       nat
       (i:(pts.El pts.var nat) => le O (f i))
       m
       (matita_basics_logic.eq_coerc
          (le O (plus (f m) O))
          (le O (f m))
          (le_plus_n (f m) O)
          (matita_basics_logic.rewrite_l
             nat
             (f m)
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq (pts.u pts.var) (le O __) (le O (f m)))
             (matita_basics_logic.refl (pts.u pts.var) (le O (f m)))
             (plus (f m) O)
             (plus_n_O (f m)))))
    (n:(pts.El pts.var nat) =>
     _clearme:(pts.El pts.var (matita_basics_logic.ex nat (i:(pts.El pts.var nat) => le n (f i)))) =>
     matita_basics_logic.match_ex
       nat
       (i:(pts.El pts.var nat) => le n (f i))
       pts.var
       (__:(pts.El pts.var (matita_basics_logic.ex nat (i:(pts.El pts.var nat) => le n (f i)))) =>
        matita_basics_logic.ex nat (i:(pts.El pts.var nat) => le (S n) (f i)))
       (a:(pts.El pts.var nat) =>
        lenfa:(pts.El pts.var (le n (f a))) =>
        matita_basics_logic.ex_intro
          nat
          (i:(pts.El pts.var nat) => le (S n) (f i))
          (S a)
          (le_to_lt_to_lt n (f a) (f (S a)) lenfa (incr a)))
       _clearme)
    m.

def minus_le :
  x:(pts.El pts.var nat) -> y:(pts.El pts.var nat) -> pts.El pts.var (le (minus x y) x)
  :=
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  matita_basics_logic.eq_coerc
    (le (minus x y) (minus (plus x y) y))
    (le (minus x y) x)
    (monotonic_le_minus_l (plus x y) x y (le_plus_n_r y x))
    (matita_basics_logic.rewrite_l
       nat
       x
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq (pts.u pts.var) (le (minus x y) __) (le (minus x y) x))
       (matita_basics_logic.refl (pts.u pts.var) (le (minus x y) x))
       (minus (plus x y) y)
       (minus_plus_m_m x y)).

def not_eq_to_le_to_lt :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (matita_basics_logic.Not (matita_basics_logic.eq nat n m))) ->
  __1:(pts.El pts.var (le n m)) -> pts.El pts.var (lt n m)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  Hneq:(pts.El pts.var (matita_basics_logic.Not (matita_basics_logic.eq nat n m))) =>
  Hle:(pts.El pts.var (le n m)) =>
  matita_basics_logic.match_Or
    (lt n m)
    (matita_basics_logic.eq nat n m)
    pts.var
    (__:(pts.El pts.var (matita_basics_logic.Or (lt n m) (matita_basics_logic.eq nat n m))) => lt n m)
    (auto:(pts.El pts.var (lt n m)) => auto)
    (Heq:(pts.El pts.var (matita_basics_logic.eq nat n m)) =>
     not_le_to_lt
       m
       n
       (matita_basics_logic.not_to_not
          (le m n)
          (matita_basics_logic.eq nat n m)
          (auto:(pts.El pts.var (le m n)) =>
           matita_basics_logic.rewrite_l
             nat
             n
             (__:(pts.El pts.var nat) => matita_basics_logic.eq nat n __)
             (matita_basics_logic.refl nat n)
             m
             Heq)
          Hneq))
    (le_to_or_lt_eq n m Hle).

def lt_times_n_to_lt_l :
  n:(pts.El pts.var nat) ->
  p:(pts.El pts.var nat) ->
  q:(pts.El pts.var nat) ->
  __:(pts.El pts.var (lt (times p n) (times q n))) -> pts.El pts.var (lt p q)
  :=
  n:(pts.El pts.var nat) =>
  p:(pts.El pts.var nat) =>
  q:(pts.El pts.var nat) =>
  Hlt:(pts.El pts.var (lt (times p n) (times q n))) =>
  matita_basics_logic.Or_ind
    (lt p q)
    (matita_basics_logic.Not (lt p q))
    (_x_170:(pts.El pts.var (matita_basics_logic.Or (lt p q) (matita_basics_logic.Not (lt p q)))) =>
     lt p q)
    (_x_171:(pts.El pts.var (lt p q)) => _x_171)
    (nltpq:(pts.El pts.var (matita_basics_logic.Not (lt p q))) =>
     matita_basics_logic.False_ind
       (_x_66:(pts.El pts.var matita_basics_logic.False) => lt p q)
       (matita_basics_logic.absurd
          (le (times q n) (times p n))
          (matita_basics_logic.eq_coerc
             (le (times n q) (times n p))
             (le (times q n) (times p n))
             (monotonic_le_times_r n q p (not_lt_to_le p q nltpq))
             (matita_basics_logic.rewrite_r
                nat
                (times n q)
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq
                   (pts.u pts.var)
                   (le (times n q) (times n p))
                   (le __ (times p n)))
                (matita_basics_logic.rewrite_r
                   nat
                   (times n p)
                   (__:(pts.El pts.var nat) =>
                    matita_basics_logic.eq
                      (pts.u pts.var)
                      (le (times n q) (times n p))
                      (le (times n q) __))
                   (matita_basics_logic.refl (pts.u pts.var) (le (times n q) (times n p)))
                   (times p n)
                   (commutative_times p n))
                (times q n)
                (commutative_times q n)))
          (lt_to_not_le (times p n) (times q n) Hlt)))
    (decidable_lt p q).

def lt_times_n_to_lt_r :
  n:(pts.El pts.var nat) ->
  p:(pts.El pts.var nat) ->
  q:(pts.El pts.var nat) ->
  __:(pts.El pts.var (lt (times n p) (times n q))) -> pts.El pts.var (lt p q)
  :=
  n:(pts.El pts.var nat) =>
  p:(pts.El pts.var nat) =>
  q:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (lt (times n p) (times n q))) =>
  lt_times_n_to_lt_l
    n
    p
    q
    (matita_basics_logic.eq_coerc
       (lt (times n p) (times n q))
       (lt (times p n) (times q n))
       auto
       (matita_basics_logic.rewrite_r
          nat
          (times p n)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq (pts.u pts.var) (lt __ (times n q)) (lt (times p n) (times q n)))
          (matita_basics_logic.rewrite_r
             nat
             (times q n)
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq
                (pts.u pts.var)
                (lt (times p n) __)
                (lt (times p n) (times q n)))
             (matita_basics_logic.refl (pts.u pts.var) (lt (times p n) (times q n)))
             (times n q)
             (commutative_times n q))
          (times n p)
          (commutative_times n p))).

def lt_minus_to_plus :
  a:(pts.El pts.var nat) ->
  b:(pts.El pts.var nat) ->
  c:(pts.El pts.var nat) -> __:(pts.El pts.var (lt (minus a b) c)) -> pts.El pts.var (lt a (plus c b))
  :=
  a:(pts.El pts.var nat) =>
  b:(pts.El pts.var nat) =>
  c:(pts.El pts.var nat) =>
  H:(pts.El pts.var (lt (minus a b) c)) =>
  not_le_to_lt
    (plus c b)
    a
    (matita_basics_logic.not_to_not
       (le (plus c b) a)
       (le c (minus a b))
       (auto:(pts.El pts.var (le (plus c b) a)) => le_plus_to_minus_r c b a auto)
       (lt_to_not_le (minus a b) c H)).

def lt_minus_to_plus_r :
  a:(pts.El pts.var nat) ->
  b:(pts.El pts.var nat) ->
  c:(pts.El pts.var nat) -> __:(pts.El pts.var (lt a (minus b c))) -> pts.El pts.var (lt (plus a c) b)
  :=
  a:(pts.El pts.var nat) =>
  b:(pts.El pts.var nat) =>
  c:(pts.El pts.var nat) =>
  H:(pts.El pts.var (lt a (minus b c))) =>
  not_le_to_lt
    b
    (plus a c)
    (matita_basics_logic.not_to_not
       (le b (plus a c))
       (le (minus b c) a)
       (le_plus_to_minus b c a)
       (lt_to_not_le a (minus b c) H)).

def lt_plus_to_minus :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  p:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le m n)) ->
  __1:(pts.El pts.var (lt n (plus p m))) -> pts.El pts.var (lt (minus n m) p)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  p:(pts.El pts.var nat) =>
  lenm:(pts.El pts.var (le m n)) =>
  H:(pts.El pts.var (lt n (plus p m))) =>
  matita_basics_logic.eq_ind
    nat
    (minus (S n) m)
    (x_1:(pts.El pts.var nat) =>
     _x_2:(pts.El pts.var (matita_basics_logic.eq nat (minus (S n) m) x_1)) => le x_1 p)
    (le_plus_to_minus (S n) m p H)
    (S (minus n m))
    (minus_Sn_m m n lenm).

def monotonic_lt_minus_l :
  p:(pts.El pts.var nat) ->
  q:(pts.El pts.var nat) ->
  n:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le n q)) ->
  __1:(pts.El pts.var (lt q p)) -> pts.El pts.var (lt (minus q n) (minus p n))
  :=
  p:(pts.El pts.var nat) =>
  q:(pts.El pts.var nat) =>
  n:(pts.El pts.var nat) =>
  H1:(pts.El pts.var (le n q)) =>
  H2:(pts.El pts.var (lt q p)) =>
  lt_plus_to_minus_r
    (minus q n)
    n
    p
    (matita_basics_logic.eq_ind
       nat
       q
       (x_1:(pts.El pts.var nat) =>
        _x_2:(pts.El pts.var (matita_basics_logic.eq nat q x_1)) => lt x_1 p)
       H2
       (plus (minus q n) n)
       (plus_minus_m_m q n H1)).

def discr_minus_x_xy :
  x:(pts.El pts.var nat) ->
  y:(pts.El pts.var nat) ->
  __:(pts.El pts.var (matita_basics_logic.eq nat x (minus x y))) ->
  pts.El
    pts.var
    (matita_basics_logic.Or (matita_basics_logic.eq nat x O) (matita_basics_logic.eq nat y O))
  :=
  _clearme:(pts.El pts.var nat) =>
  match_nat
    pts.var
    (__:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       nat
       (y:(pts.El pts.var nat) =>
        pts.Prod
          pts.var
          pts.var
          (matita_basics_logic.eq nat __ (minus __ y))
          (__1:(pts.El pts.var (matita_basics_logic.eq nat __ (minus __ y))) =>
           matita_basics_logic.Or
             (matita_basics_logic.eq nat __ O)
             (matita_basics_logic.eq nat y O))))
    (y:(pts.El pts.var nat) =>
     auto:(pts.El pts.var (matita_basics_logic.eq nat O (minus O y))) =>
     matita_basics_logic.or_introl
       (matita_basics_logic.eq nat O O)
       (matita_basics_logic.eq nat y O)
       (matita_basics_logic.refl nat O))
    (x:(pts.El pts.var nat) =>
     _clearme0:(pts.El pts.var nat) =>
     match_nat
       pts.var
       (__:(pts.El pts.var nat) =>
        pts.Prod
          pts.var
          pts.var
          (matita_basics_logic.eq nat (S x) (minus (S x) __))
          (__1:(pts.El pts.var (matita_basics_logic.eq nat (S x) (minus (S x) __))) =>
           matita_basics_logic.Or
             (matita_basics_logic.eq nat (S x) O)
             (matita_basics_logic.eq nat __ O)))
       (auto:(pts.El pts.var (matita_basics_logic.eq nat (S x) (minus (S x) O))) =>
        matita_basics_relations.RC_reflexive
          nat
          (__:(pts.El pts.var nat) => _0:(pts.El pts.var nat) => matita_basics_logic.eq nat (S x) O)
          O)
       (y:(pts.El pts.var nat) =>
        H:(pts.El pts.var (matita_basics_logic.eq nat (S x) (minus x y))) =>
        matita_basics_logic.eq_ind
          nat
          (S x)
          (x_1:(pts.El pts.var nat) =>
           _x_2:(pts.El pts.var (matita_basics_logic.eq nat (S x) x_1)) =>
           pts.Prod
             pts.var
             pts.var
             (le x_1 x)
             (__:(pts.El pts.var (le x_1 x)) =>
              matita_basics_logic.Or
                (matita_basics_logic.eq nat (S x) O)
                (matita_basics_logic.eq nat (S y) O)))
          (H0:(pts.El pts.var (le (S x) x)) =>
           matita_basics_logic.Not_ind
             (le (S x) x)
             (_x_79:(pts.El pts.var (matita_basics_logic.Not (le (S x) x))) =>
              matita_basics_logic.Or
                (matita_basics_logic.eq nat (S x) O)
                (matita_basics_logic.eq nat (S y) O))
             (H00:(__:(pts.El pts.var (le (S x) x)) -> pts.El pts.var matita_basics_logic.False) =>
              matita_basics_logic.False_ind
                (_x_66:(pts.El pts.var matita_basics_logic.False) =>
                 matita_basics_logic.Or
                   (matita_basics_logic.eq nat (S x) O)
                   (matita_basics_logic.eq nat (S y) O))
                (H00 H0))
             (not_le_Sn_n x))
          (minus x y)
          H
          (minus_le x y))
       _clearme0)
    _clearme.

def plus_le_0 :
  x:(pts.El pts.var nat) ->
  y:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le (plus x y) O)) ->
  pts.El
    pts.var
    (matita_basics_logic.And (matita_basics_logic.eq nat x O) (matita_basics_logic.eq nat y O))
  :=
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  H:(pts.El pts.var (le (plus x y) O)) =>
  matita_basics_logic.And_ind
    (le x (minus O y))
    (le y O)
    (_x_118:(pts.El pts.var (matita_basics_logic.And (le x (minus O y)) (le y O))) =>
     matita_basics_logic.And (matita_basics_logic.eq nat x O) (matita_basics_logic.eq nat y O))
    (H1:(pts.El pts.var (le x (minus O y))) =>
     H2:(pts.El pts.var (le y O)) =>
     matita_basics_logic.conj
       (matita_basics_logic.eq nat x O)
       (matita_basics_logic.eq nat y O)
       (matita_basics_logic.sym_eq
          nat
          O
          x
          (matita_basics_logic.eq_coerc
             (matita_basics_logic.eq nat O x)
             (matita_basics_logic.eq nat O x)
             (le_n_O_to_eq x H1)
             (matita_basics_logic.refl (pts.u pts.var) (matita_basics_logic.eq nat O x))))
       (matita_basics_logic.sym_eq
          nat
          O
          y
          (matita_basics_logic.eq_coerc
             (matita_basics_logic.eq nat O y)
             (matita_basics_logic.eq nat O y)
             (le_n_O_to_eq y H2)
             (matita_basics_logic.refl (pts.u pts.var) (matita_basics_logic.eq nat O y)))))
    (le_inv_plus_l x y O H).

def eq_minus_O :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le n m)) -> pts.El pts.var (matita_basics_logic.eq nat (minus n m) O)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  lenm:(pts.El pts.var (le n m)) =>
  le_n_O_elim
    (minus n m)
    (matita_basics_logic.eq_coerc
       (le (minus n m) (minus n n))
       (le (minus n m) O)
       (monotonic_le_minus_r m n n lenm)
       (matita_basics_logic.rewrite_l
          nat
          O
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq (pts.u pts.var) (le (minus n m) __) (le (minus n m) O))
          (matita_basics_logic.refl (pts.u pts.var) (le (minus n m) O))
          (minus n n)
          (minus_n_n n)))
    (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ O)
    (matita_basics_logic.refl nat O).

def distributive_times_minus :
  pts.El pts.var (matita_basics_relations.distributive nat times minus)
  :=
  a:(pts.El pts.var nat) =>
  b:(pts.El pts.var nat) =>
  c:(pts.El pts.var nat) =>
  matita_basics_logic.match_Or
    (lt b c)
    (matita_basics_logic.Not (lt b c))
    pts.var
    (__:(pts.El pts.var (matita_basics_logic.Or (lt b c) (matita_basics_logic.Not (lt b c)))) =>
     matita_basics_logic.eq nat (times a (minus b c)) (minus (times a b) (times a c)))
    (Hbc:(pts.El pts.var (lt b c)) =>
     matita_basics_logic.eq_ind_r
       nat
       O
       (x:(pts.El pts.var nat) =>
        __:(pts.El pts.var (matita_basics_logic.eq nat x O)) =>
        matita_basics_logic.eq nat (times a x) (minus (times a b) (times a c)))
       (matita_basics_logic.eq_ind_r
          nat
          O
          (x:(pts.El pts.var nat) =>
           __:(pts.El pts.var (matita_basics_logic.eq nat x O)) =>
           matita_basics_logic.eq nat (times a O) x)
          (matita_basics_logic.rewrite_l
             nat
             O
             (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ O)
             (matita_basics_logic.refl nat O)
             (times a O)
             (times_n_O a))
          (minus (times a b) (times a c))
          (eq_minus_O (times a b) (times a c) (monotonic_le_times_r a b c (lt_to_le b c Hbc))))
       (minus b c)
       (eq_minus_O b c (lt_to_le b c Hbc)))
    (Hbc:(pts.El pts.var (matita_basics_logic.Not (lt b c))) =>
     matita_basics_logic.sym_eq
       nat
       (minus (times a b) (times a c))
       (times a (minus b c))
       (matita_basics_logic.eq_coerc
          (matita_basics_logic.eq nat (minus (times a b) (times a c)) (times a (minus b c)))
          (matita_basics_logic.eq nat (minus (times a b) (times a c)) (times a (minus b c)))
          (plus_to_minus
             (times a b)
             (times a c)
             (times a (minus b c))
             (matita_basics_logic.eq_ind
                nat
                (times a (plus c (minus b c)))
                (x_1:(pts.El pts.var nat) =>
                 _x_2:(pts.El
                         pts.var
                         (matita_basics_logic.eq nat (times a (plus c (minus b c))) x_1)) =>
                 matita_basics_logic.eq nat (times a b) x_1)
                (matita_basics_logic.eq_f
                   nat
                   nat
                   (times a)
                   b
                   (plus c (minus b c))
                   (matita_basics_logic.eq_coerc
                      (matita_basics_logic.eq nat b (plus (minus b c) c))
                      (matita_basics_logic.eq nat b (plus c (minus b c)))
                      (plus_minus_m_m b c (not_lt_to_le b c Hbc))
                      (matita_basics_logic.rewrite_r
                         nat
                         (plus c (minus b c))
                         (__:(pts.El pts.var nat) =>
                          matita_basics_logic.eq
                            (pts.u pts.var)
                            (matita_basics_logic.eq nat b __)
                            (matita_basics_logic.eq nat b (plus c (minus b c))))
                         (matita_basics_logic.refl
                            (pts.u pts.var)
                            (matita_basics_logic.eq nat b (plus c (minus b c))))
                         (plus (minus b c) c)
                         (commutative_plus (minus b c) c))))
                (plus (times a c) (times a (minus b c)))
                (distributive_times_plus a c (minus b c))))
          (matita_basics_logic.refl
             (pts.u pts.var)
             (matita_basics_logic.eq nat (minus (times a b) (times a c)) (times a (minus b c))))))
    (decidable_lt b c).

def minus_plus :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  p:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_logic.eq nat (minus (minus n m) p) (minus n (plus m p)))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  p:(pts.El pts.var nat) =>
  matita_basics_logic.match_Or
    (le (plus m p) n)
    (matita_basics_logic.Not (le (plus m p) n))
    pts.var
    (__:(pts.El
           pts.var
           (matita_basics_logic.Or (le (plus m p) n) (matita_basics_logic.Not (le (plus m p) n)))) =>
     matita_basics_logic.eq nat (minus (minus n m) p) (minus n (plus m p)))
    (Hlt:(pts.El pts.var (le (plus m p) n)) =>
     plus_to_minus
       (minus n m)
       p
       (minus n (plus m p))
       (plus_to_minus
          n
          m
          (plus p (minus n (plus m p)))
          (matita_basics_logic.eq_ind
             nat
             (plus (plus m p) (minus n (plus m p)))
             (x_1:(pts.El pts.var nat) =>
              _x_2:(pts.El
                      pts.var
                      (matita_basics_logic.eq nat (plus (plus m p) (minus n (plus m p))) x_1)) =>
              matita_basics_logic.eq nat n x_1)
             (minus_to_plus
                n
                (plus m p)
                (minus n (plus m p))
                Hlt
                (matita_basics_logic.refl nat (minus n (plus m p))))
             (plus m (plus p (minus n (plus m p))))
             (associative_plus m p (minus n (plus m p))))))
    (Hlt:(pts.El pts.var (matita_basics_logic.Not (le (plus m p) n))) =>
     matita_basics_logic.eq_ind_r
       nat
       O
       (x:(pts.El pts.var nat) =>
        __:(pts.El pts.var (matita_basics_logic.eq nat x O)) =>
        matita_basics_logic.eq nat x (minus n (plus m p)))
       (matita_basics_logic.sym_eq
          nat
          (minus n (plus m p))
          O
          (matita_basics_logic.eq_coerc
             (matita_basics_logic.eq nat (minus n (plus m p)) O)
             (matita_basics_logic.eq nat (minus n (plus m p)) O)
             (eq_minus_O
                n
                (plus m p)
                (transitive_le n (S n) (plus m p) (le_n_Sn n) (not_le_to_lt (plus m p) n Hlt)))
             (matita_basics_logic.refl
                (pts.u pts.var)
                (matita_basics_logic.eq nat (minus n (plus m p)) O))))
       (minus (minus n m) p)
       (eq_minus_O
          (minus n m)
          p
          (matita_basics_logic.eq_coerc
             (le (minus n m) (minus (plus p m) m))
             (le (minus n m) p)
             (monotonic_le_minus_l
                (plus p m)
                n
                m
                (matita_basics_logic.eq_coerc
                   (le n (plus m p))
                   (le n (plus p m))
                   (transitive_le n (S n) (plus m p) (le_n_Sn n) (not_le_to_lt (plus m p) n Hlt))
                   (matita_basics_logic.rewrite_r
                      nat
                      (plus m p)
                      (__:(pts.El pts.var nat) =>
                       matita_basics_logic.eq (pts.u pts.var) (le n (plus m p)) (le n __))
                      (matita_basics_logic.refl (pts.u pts.var) (le n (plus m p)))
                      (plus p m)
                      (commutative_plus p m))))
             (matita_basics_logic.rewrite_l
                nat
                p
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq (pts.u pts.var) (le (minus n m) __) (le (minus n m) p))
                (matita_basics_logic.refl (pts.u pts.var) (le (minus n m) p))
                (minus (plus p m) m)
                (minus_plus_m_m p m)))))
    (decidable_le (plus m p) n).

def minus_minus :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  p:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le p m)) ->
  __1:(pts.El pts.var (le m n)) ->
  pts.El pts.var (matita_basics_logic.eq nat (plus p (minus n m)) (minus n (minus m p)))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  p:(pts.El pts.var nat) =>
  lepm:(pts.El pts.var (le p m)) =>
  lemn:(pts.El pts.var (le m n)) =>
  matita_basics_logic.sym_eq
    nat
    (minus n (minus m p))
    (plus p (minus n m))
    (plus_to_minus
       n
       (minus m p)
       (plus p (minus n m))
       (matita_basics_logic.eq_ind
          nat
          (plus (plus (minus m p) p) (minus n m))
          (x_1:(pts.El pts.var nat) =>
           _x_2:(pts.El
                   pts.var
                   (matita_basics_logic.eq nat (plus (plus (minus m p) p) (minus n m)) x_1)) =>
           matita_basics_logic.eq nat n x_1)
          (matita_basics_logic.eq_ind
             nat
             m
             (x_1:(pts.El pts.var nat) =>
              _x_2:(pts.El pts.var (matita_basics_logic.eq nat m x_1)) =>
              matita_basics_logic.eq nat n (plus x_1 (minus n m)))
             (matita_basics_logic.eq_ind
                nat
                (plus (minus n m) m)
                (x_1:(pts.El pts.var nat) =>
                 _x_2:(pts.El pts.var (matita_basics_logic.eq nat (plus (minus n m) m) x_1)) =>
                 matita_basics_logic.eq nat n x_1)
                (matita_basics_logic.eq_ind
                   nat
                   n
                   (x_1:(pts.El pts.var nat) =>
                    _x_2:(pts.El pts.var (matita_basics_logic.eq nat n x_1)) =>
                    matita_basics_logic.eq nat n x_1)
                   (matita_basics_logic.refl nat n)
                   (plus (minus n m) m)
                   (plus_minus_m_m n m lemn))
                (plus m (minus n m))
                (commutative_plus (minus n m) m))
             (plus (minus m p) p)
             (plus_minus_m_m m p lepm))
          (plus (minus m p) (plus p (minus n m)))
          (associative_plus (minus m p) p (minus n m)))).

def minus_minus_associative :
  x:(pts.El pts.var nat) ->
  y:(pts.El pts.var nat) ->
  z:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le z y)) ->
  __1:(pts.El pts.var (le y x)) ->
  pts.El pts.var (matita_basics_logic.eq nat (minus x (minus y z)) (plus (minus x y) z))
  :=
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  z:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (le z y)) =>
  auto':(pts.El pts.var (le y x)) =>
  matita_basics_logic.sym_eq
    nat
    (plus (minus x y) z)
    (minus x (minus y z))
    (matita_basics_logic.eq_coerc
       (matita_basics_logic.eq nat (plus z (minus x y)) (minus x (minus y z)))
       (matita_basics_logic.eq nat (plus (minus x y) z) (minus x (minus y z)))
       (minus_minus x y z auto auto')
       (matita_basics_logic.rewrite_r
          nat
          (plus z (minus x y))
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq
             (pts.u pts.var)
             (matita_basics_logic.eq nat (plus z (minus x y)) (minus x (minus y z)))
             (matita_basics_logic.eq nat __ (minus x (minus y z))))
          (matita_basics_logic.refl
             (pts.u pts.var)
             (matita_basics_logic.eq nat (plus z (minus x y)) (minus x (minus y z))))
          (plus (minus x y) z)
          (commutative_plus (minus x y) z))).

def minus_minus_comm :
  a:(pts.El pts.var nat) ->
  b:(pts.El pts.var nat) ->
  c:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_logic.eq nat (minus (minus a b) c) (minus (minus a c) b))
  :=
  a:(pts.El pts.var nat) =>
  b:(pts.El pts.var nat) =>
  c:(pts.El pts.var nat) =>
  le_to_le_to_eq
    (minus (minus a b) c)
    (minus (minus a c) b)
    (matita_basics_logic.eq_coerc
       (le (minus (minus a b) c) (minus (plus (minus (minus a c) b) c) c))
       (le (minus (minus a b) c) (minus (minus a c) b))
       (monotonic_le_minus_l
          (plus (minus (minus a c) b) c)
          (minus a b)
          c
          (matita_basics_logic.eq_coerc
             (le (minus a b) (plus (minus (minus a b) c) c))
             (le (minus a b) (plus (minus (minus a c) b) c))
             (le_plus_minus_m_m (minus a b) c)
             (matita_basics_logic.rewrite_r
                nat
                (minus a (plus b c))
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq
                   (pts.u pts.var)
                   (le (minus a b) (plus __ c))
                   (le (minus a b) (plus (minus (minus a c) b) c)))
                (matita_basics_logic.rewrite_r
                   nat
                   (plus c (minus a (plus b c)))
                   (__:(pts.El pts.var nat) =>
                    matita_basics_logic.eq
                      (pts.u pts.var)
                      (le (minus a b) __)
                      (le (minus a b) (plus (minus (minus a c) b) c)))
                   (matita_basics_logic.rewrite_r
                      nat
                      (plus c (minus (minus a c) b))
                      (__:(pts.El pts.var nat) =>
                       matita_basics_logic.eq
                         (pts.u pts.var)
                         (le (minus a b) (plus c (minus a (plus b c))))
                         (le (minus a b) __))
                      (matita_basics_logic.rewrite_l
                         nat
                         (minus (minus a c) b)
                         (__:(pts.El pts.var nat) =>
                          matita_basics_logic.eq
                            (pts.u pts.var)
                            (le (minus a b) (plus c __))
                            (le (minus a b) (plus c (minus (minus a c) b))))
                         (matita_basics_logic.refl
                            (pts.u pts.var)
                            (le (minus a b) (plus c (minus (minus a c) b))))
                         (minus a (plus b c))
                         (matita_basics_logic.rewrite_l
                            nat
                            (plus c b)
                            (__:(pts.El pts.var nat) =>
                             matita_basics_logic.eq nat (minus (minus a c) b) (minus a __))
                            (minus_plus a c b)
                            (plus b c)
                            (commutative_plus c b)))
                      (plus (minus (minus a c) b) c)
                      (commutative_plus (minus (minus a c) b) c))
                   (plus (minus a (plus b c)) c)
                   (commutative_plus (minus a (plus b c)) c))
                (minus (minus a b) c)
                (minus_plus a b c))))
       (matita_basics_logic.rewrite_l
          nat
          (minus (minus a c) b)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq
             (pts.u pts.var)
             (le (minus (minus a b) c) __)
             (le (minus (minus a b) c) (minus (minus a c) b)))
          (matita_basics_logic.refl
             (pts.u pts.var)
             (le (minus (minus a b) c) (minus (minus a c) b)))
          (minus (plus (minus (minus a c) b) c) c)
          (minus_plus_m_m (minus (minus a c) b) c)))
    (matita_basics_logic.eq_coerc
       (le (minus (minus a c) b) (minus (plus (minus (minus a b) c) b) b))
       (le (minus (minus a c) b) (minus (minus a b) c))
       (monotonic_le_minus_l
          (plus (minus (minus a b) c) b)
          (minus a c)
          b
          (matita_basics_logic.eq_coerc
             (le (minus a c) (plus (minus (minus a c) b) b))
             (le (minus a c) (plus (minus (minus a b) c) b))
             (le_plus_minus_m_m (minus a c) b)
             (matita_basics_logic.rewrite_r
                nat
                (minus a (plus c b))
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq
                   (pts.u pts.var)
                   (le (minus a c) (plus __ b))
                   (le (minus a c) (plus (minus (minus a b) c) b)))
                (matita_basics_logic.rewrite_r
                   nat
                   (plus b (minus a (plus c b)))
                   (__:(pts.El pts.var nat) =>
                    matita_basics_logic.eq
                      (pts.u pts.var)
                      (le (minus a c) __)
                      (le (minus a c) (plus (minus (minus a b) c) b)))
                   (matita_basics_logic.rewrite_r
                      nat
                      (plus b (minus (minus a b) c))
                      (__:(pts.El pts.var nat) =>
                       matita_basics_logic.eq
                         (pts.u pts.var)
                         (le (minus a c) (plus b (minus a (plus c b))))
                         (le (minus a c) __))
                      (matita_basics_logic.rewrite_l
                         nat
                         (minus (minus a b) c)
                         (__:(pts.El pts.var nat) =>
                          matita_basics_logic.eq
                            (pts.u pts.var)
                            (le (minus a c) (plus b __))
                            (le (minus a c) (plus b (minus (minus a b) c))))
                         (matita_basics_logic.refl
                            (pts.u pts.var)
                            (le (minus a c) (plus b (minus (minus a b) c))))
                         (minus a (plus c b))
                         (matita_basics_logic.rewrite_l
                            nat
                            (plus b c)
                            (__:(pts.El pts.var nat) =>
                             matita_basics_logic.eq nat (minus (minus a b) c) (minus a __))
                            (minus_plus a b c)
                            (plus c b)
                            (commutative_plus b c)))
                      (plus (minus (minus a b) c) b)
                      (commutative_plus (minus (minus a b) c) b))
                   (plus (minus a (plus c b)) b)
                   (commutative_plus (minus a (plus c b)) b))
                (minus (minus a c) b)
                (minus_plus a c b))))
       (matita_basics_logic.rewrite_l
          nat
          (minus (minus a b) c)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq
             (pts.u pts.var)
             (le (minus (minus a c) b) __)
             (le (minus (minus a c) b) (minus (minus a b) c)))
          (matita_basics_logic.refl
             (pts.u pts.var)
             (le (minus (minus a c) b) (minus (minus a b) c)))
          (minus (plus (minus (minus a b) c) b) b)
          (minus_plus_m_m (minus (minus a b) c) b))).

def minus_le_minus_minus_comm :
  b:(pts.El pts.var nat) ->
  c:(pts.El pts.var nat) ->
  a:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le c b)) ->
  pts.El pts.var (matita_basics_logic.eq nat (minus a (minus b c)) (minus (plus a c) b))
  :=
  b:(pts.El pts.var nat) =>
  c:(pts.El pts.var nat) =>
  a:(pts.El pts.var nat) =>
  H:(pts.El pts.var (le c b)) =>
  matita_basics_logic.eq_ind_r
    nat
    (plus (minus b c) c)
    (x:(pts.El pts.var nat) =>
     __:(pts.El pts.var (matita_basics_logic.eq nat x (plus (minus b c) c))) =>
     matita_basics_logic.eq nat (minus a (minus b c)) (minus (plus a c) x))
    (matita_basics_logic.rewrite_r
       nat
       (plus c a)
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq nat (minus a (minus b c)) (minus __ (plus (minus b c) c)))
       (matita_basics_logic.rewrite_r
          nat
          (plus c (minus b c))
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq nat (minus a (minus b c)) (minus (plus c a) __))
          (matita_basics_logic.rewrite_l
             nat
             (minus (minus (plus c a) c) (minus b c))
             (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (minus a (minus b c)) __)
             (matita_basics_logic.rewrite_r
                nat
                (minus (plus c a) c)
                (__:(pts.El pts.var nat) =>
                 matita_basics_logic.eq
                   nat
                   (minus __ (minus b c))
                   (minus (minus (plus c a) c) (minus b c)))
                (matita_basics_logic.refl nat (minus (minus (plus c a) c) (minus b c)))
                a
                (matita_basics_logic.rewrite_l
                   nat
                   (plus a c)
                   (__:(pts.El pts.var nat) => matita_basics_logic.eq nat a (minus __ c))
                   (minus_plus_m_m a c)
                   (plus c a)
                   (commutative_plus a c)))
             (minus (plus c a) (plus c (minus b c)))
             (minus_plus (plus c a) c (minus b c)))
          (plus (minus b c) c)
          (commutative_plus (minus b c) c))
       (plus a c)
       (commutative_plus a c))
    b
    (plus_minus_m_m b c H).

def minus_minus_m_m :
  m:(pts.El pts.var nat) ->
  n:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le n m)) -> pts.El pts.var (matita_basics_logic.eq nat (minus m (minus m n)) n)
  :=
  m:(pts.El pts.var nat) =>
  n:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (le n m)) =>
  matita_basics_logic.eq_coerc
    (matita_basics_logic.eq nat (minus m (minus m n)) (minus (plus m n) m))
    (matita_basics_logic.eq nat (minus m (minus m n)) n)
    (minus_le_minus_minus_comm m n m auto)
    (matita_basics_logic.rewrite_r
       nat
       (plus n m)
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq
          (pts.u pts.var)
          (matita_basics_logic.eq nat (minus m (minus m n)) (minus __ m))
          (matita_basics_logic.eq nat (minus m (minus m n)) n))
       (matita_basics_logic.rewrite_l
          nat
          n
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq
             (pts.u pts.var)
             (matita_basics_logic.eq nat (minus m (minus m n)) __)
             (matita_basics_logic.eq nat (minus m (minus m n)) n))
          (matita_basics_logic.refl
             (pts.u pts.var)
             (matita_basics_logic.eq nat (minus m (minus m n)) n))
          (minus (plus n m) m)
          (minus_plus_m_m n m))
       (plus m n)
       (commutative_plus m n)).

def minus_plus_plus_l :
  x:(pts.El pts.var nat) ->
  y:(pts.El pts.var nat) ->
  h:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_logic.eq nat (minus (plus x h) (plus y h)) (minus x y))
  :=
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  h:(pts.El pts.var nat) =>
  matita_basics_logic.rewrite_l
    nat
    (minus (minus (plus x h) y) h)
    (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (minus x y))
    (matita_basics_logic.rewrite_r
       nat
       (minus x y)
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (minus x y))
       (matita_basics_logic.refl nat (minus x y))
       (minus (minus (plus x h) y) h)
       (matita_basics_logic.rewrite_r
          nat
          (minus (plus x h) h)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq nat (minus (minus (plus x h) y) h) (minus __ y))
          (minus_minus_comm (plus x h) y h)
          x
          (minus_plus_m_m x h)))
    (minus (plus x h) (plus y h))
    (minus_plus (plus x h) y h).

def plus_minus_plus_plus_l :
  z:(pts.El pts.var nat) ->
  x:(pts.El pts.var nat) ->
  y:(pts.El pts.var nat) ->
  h:(pts.El pts.var nat) ->
  pts.El
    pts.var
    (matita_basics_logic.eq nat (minus (plus z (plus x h)) (plus y h)) (minus (plus z x) y))
  :=
  z:(pts.El pts.var nat) =>
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  h:(pts.El pts.var nat) =>
  matita_basics_logic.rewrite_r
    nat
    (minus (plus z x) y)
    (__:(pts.El pts.var nat) => matita_basics_logic.eq nat __ (minus (plus z x) y))
    (matita_basics_logic.refl nat (minus (plus z x) y))
    (minus (plus z (plus x h)) (plus y h))
    (matita_basics_logic.rewrite_l
       nat
       (plus (plus z x) h)
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq nat (minus __ (plus y h)) (minus (plus z x) y))
       (minus_plus_plus_l (plus z x) y h)
       (plus z (plus x h))
       (associative_plus z x h)).

def minus_plus_minus_l :
  x:(pts.El pts.var nat) ->
  y:(pts.El pts.var nat) ->
  z:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le y z)) ->
  pts.El pts.var (matita_basics_logic.eq nat (minus (plus z x) (minus z y)) (plus x y))
  :=
  x:(pts.El pts.var nat) =>
  y:(pts.El pts.var nat) =>
  z:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (le y z)) =>
  matita_basics_logic.eq_coerc
    (matita_basics_logic.eq nat (minus (plus x z) (minus z y)) (plus (minus (plus x z) z) y))
    (matita_basics_logic.eq nat (minus (plus z x) (minus z y)) (plus x y))
    (minus_minus_associative
       (plus x z)
       z
       y
       auto
       (matita_basics_logic.eq_coerc
          (le z (plus z x))
          (le z (plus x z))
          (le_plus_n_r x z)
          (matita_basics_logic.rewrite_r
             nat
             (plus x z)
             (__:(pts.El pts.var nat) =>
              matita_basics_logic.eq (pts.u pts.var) (le z __) (le z (plus x z)))
             (matita_basics_logic.refl (pts.u pts.var) (le z (plus x z)))
             (plus z x)
             (commutative_plus z x))))
    (matita_basics_logic.rewrite_r
       nat
       (plus x z)
       (__:(pts.El pts.var nat) =>
        matita_basics_logic.eq
          (pts.u pts.var)
          (matita_basics_logic.eq nat (minus (plus x z) (minus z y)) (plus (minus (plus x z) z) y))
          (matita_basics_logic.eq nat (minus __ (minus z y)) (plus x y)))
       (matita_basics_logic.rewrite_l
          nat
          x
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq
             (pts.u pts.var)
             (matita_basics_logic.eq nat (minus (plus x z) (minus z y)) (plus __ y))
             (matita_basics_logic.eq nat (minus (plus x z) (minus z y)) (plus x y)))
          (matita_basics_logic.refl
             (pts.u pts.var)
             (matita_basics_logic.eq nat (minus (plus x z) (minus z y)) (plus x y)))
          (minus (plus x z) z)
          (minus_plus_m_m x z))
       (plus z x)
       (commutative_plus z x)).

def le_fwd_plus_plus_ge :
  m1:(pts.El pts.var nat) ->
  m2:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le m2 m1)) ->
  n1:(pts.El pts.var nat) ->
  n2:(pts.El pts.var nat) ->
  __1:(pts.El pts.var (le (plus m1 n1) (plus m2 n2))) -> pts.El pts.var (le n1 n2)
  :=
  m1:(pts.El pts.var nat) =>
  m2:(pts.El pts.var nat) =>
  H:(pts.El pts.var (le m2 m1)) =>
  n1:(pts.El pts.var nat) =>
  n2:(pts.El pts.var nat) =>
  matita_basics_logic.eq_ind_r
    nat
    (plus n1 m1)
    (x:(pts.El pts.var nat) =>
     __:(pts.El pts.var (matita_basics_logic.eq nat x (plus n1 m1))) =>
     pts.Prod
       pts.var
       pts.var
       (le x (plus m2 n2))
       (__1:(pts.El pts.var (le x (plus m2 n2))) => le n1 n2))
    (H0:(pts.El pts.var (le (plus n1 m1) (plus m2 n2))) =>
     matita_basics_logic.And_ind
       (le n1 (minus (plus m2 n2) m1))
       (le m1 (plus m2 n2))
       (_x_118:(pts.El
                  pts.var
                  (matita_basics_logic.And (le n1 (minus (plus m2 n2) m1)) (le m1 (plus m2 n2)))) =>
        le n1 n2)
       (matita_basics_logic.eq_ind_r
          nat
          (plus n2 m2)
          (x:(pts.El pts.var nat) =>
           __:(pts.El pts.var (matita_basics_logic.eq nat x (plus n2 m2))) =>
           pts.Prod
             pts.var
             pts.var
             (le n1 (minus x m1))
             (_x_120:(pts.El pts.var (le n1 (minus x m1))) =>
              pts.Prod pts.var pts.var (le m1 x) (_x_119:(pts.El pts.var (le m1 x)) => le n1 n2)))
          (matita_basics_logic.eq_ind
             nat
             (minus n2 (minus m1 m2))
             (x_1:(pts.El pts.var nat) =>
              _x_2:(pts.El pts.var (matita_basics_logic.eq nat (minus n2 (minus m1 m2)) x_1)) =>
              pts.Prod
                pts.var
                pts.var
                (le n1 x_1)
                (_x_120:(pts.El pts.var (le n1 x_1)) =>
                 pts.Prod
                   pts.var
                   pts.var
                   (le m1 (plus n2 m2))
                   (_x_119:(pts.El pts.var (le m1 (plus n2 m2))) => le n1 n2)))
             (H1:(pts.El pts.var (le n1 (minus n2 (minus m1 m2)))) =>
              __:(pts.El pts.var (le m1 (plus n2 m2))) =>
              transitive_le n1 (minus n2 (minus m1 m2)) n2 H1 (minus_le n2 (minus m1 m2)))
             (minus (plus n2 m2) m1)
             (minus_le_minus_minus_comm m1 m2 n2 H))
          (plus m2 n2)
          (commutative_plus m2 n2))
       (le_inv_plus_l n1 m1 (plus m2 n2) H0))
    (plus m1 n1)
    (commutative_plus m1 n1).

def eqb :
  __:(pts.El pts.var nat) -> __1:(pts.El pts.var nat) -> pts.El pts.var matita_basics_bool.bool.

def eqb_body :
  __:(pts.El pts.var nat) -> __1:(pts.El pts.var nat) -> pts.El pts.var matita_basics_bool.bool.

[__]
  eqb __
  -->
  filter_nat
    pts.var
    (__:(pts.El pts.var nat) =>
     pts.Prod pts.var pts.var nat (__1:(pts.El pts.var nat) => matita_basics_bool.bool))
    eqb_body
    __.

[__]
  eqb_body __
  -->
  m:(pts.El pts.var nat) =>
  match_nat
    pts.var
    (__1:(pts.El pts.var nat) => matita_basics_bool.bool)
    (match_nat
       pts.var
       (__1:(pts.El pts.var nat) => matita_basics_bool.bool)
       matita_basics_bool.true
       (q:(pts.El pts.var nat) => matita_basics_bool.false)
       m)
    (p:(pts.El pts.var nat) =>
     match_nat
       pts.var
       (__1:(pts.El pts.var nat) => matita_basics_bool.bool)
       matita_basics_bool.false
       (q:(pts.El pts.var nat) => eqb p q)
       m)
    __.

def eqb_elim :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  P:(__:(pts.El pts.var matita_basics_bool.bool) -> pts.U pts.var) ->
  __:(__:(pts.El pts.var (matita_basics_logic.eq nat n m)) -> pts.El pts.var (P matita_basics_bool.true)) ->
  __1:(__1:(pts.El pts.var (matita_basics_logic.Not (matita_basics_logic.eq nat n m))) ->
       pts.El pts.var (P matita_basics_bool.false)) ->
  pts.El pts.var (P (eqb n m))
  :=
  nat_elim2
    (__:(pts.El pts.var nat) =>
     _0:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       (pts.Prod
          pts.var
          pts.var
          matita_basics_bool.bool
          (__1:(pts.El pts.var matita_basics_bool.bool) => pts.u pts.var))
       (P:(__1:(pts.El pts.var matita_basics_bool.bool) -> pts.U pts.var) =>
        pts.Prod
          pts.var
          pts.var
          (pts.Prod
             pts.var
             pts.var
             (matita_basics_logic.eq nat __ _0)
             (__1:(pts.El pts.var (matita_basics_logic.eq nat __ _0)) => P matita_basics_bool.true))
          (__1:(__1:(pts.El pts.var (matita_basics_logic.eq nat __ _0)) ->
                pts.El pts.var (P matita_basics_bool.true)) =>
           pts.Prod
             pts.var
             pts.var
             (pts.Prod
                pts.var
                pts.var
                (matita_basics_logic.Not (matita_basics_logic.eq nat __ _0))
                (__2:(pts.El
                        pts.var
                        (matita_basics_logic.Not (matita_basics_logic.eq nat __ _0))) =>
                 P matita_basics_bool.false))
             (__2:(__2:(pts.El
                          pts.var
                          (matita_basics_logic.Not (matita_basics_logic.eq nat __ _0))) ->
                   pts.El pts.var (P matita_basics_bool.false)) =>
              P (eqb __ _0)))))
    (n:(pts.El pts.var nat) =>
     match_nat
       pts.var
       (__:(pts.El pts.var nat) =>
        pts.Prod
          pts.var
          pts.var
          (pts.Prod
             pts.var
             pts.var
             matita_basics_bool.bool
             (__1:(pts.El pts.var matita_basics_bool.bool) => pts.u pts.var))
          (P:(__1:(pts.El pts.var matita_basics_bool.bool) -> pts.U pts.var) =>
           pts.Prod
             pts.var
             pts.var
             (pts.Prod
                pts.var
                pts.var
                (matita_basics_logic.eq nat O __)
                (__1:(pts.El pts.var (matita_basics_logic.eq nat O __)) =>
                 P matita_basics_bool.true))
             (__1:(__1:(pts.El pts.var (matita_basics_logic.eq nat O __)) ->
                   pts.El pts.var (P matita_basics_bool.true)) =>
              pts.Prod
                pts.var
                pts.var
                (pts.Prod
                   pts.var
                   pts.var
                   (matita_basics_logic.Not (matita_basics_logic.eq nat O __))
                   (__2:(pts.El
                           pts.var
                           (matita_basics_logic.Not (matita_basics_logic.eq nat O __))) =>
                    P matita_basics_bool.false))
                (__2:(__2:(pts.El
                             pts.var
                             (matita_basics_logic.Not (matita_basics_logic.eq nat O __))) ->
                      pts.El pts.var (P matita_basics_bool.false)) =>
                 P (eqb O __)))))
       (P:(__:(pts.El pts.var matita_basics_bool.bool) -> pts.U pts.var) =>
        auto:(__:(pts.El pts.var (matita_basics_logic.eq nat O O)) ->
              pts.El pts.var (P matita_basics_bool.true)) =>
        auto':(__:(pts.El pts.var (matita_basics_logic.Not (matita_basics_logic.eq nat O O))) ->
               pts.El pts.var (P matita_basics_bool.false)) =>
        auto (matita_basics_logic.refl nat O))
       (auto:(pts.El pts.var nat) =>
        P:(__:(pts.El pts.var matita_basics_bool.bool) -> pts.U pts.var) =>
        auto':(__:(pts.El pts.var (matita_basics_logic.eq nat O (S auto))) ->
               pts.El pts.var (P matita_basics_bool.true)) =>
        auto'':(__:(pts.El
                      pts.var
                      (matita_basics_logic.Not (matita_basics_logic.eq nat O (S auto)))) ->
                pts.El pts.var (P matita_basics_bool.false)) =>
        auto'' (not_eq_O_S auto))
       n)
    (n:(pts.El pts.var nat) =>
     P:(__:(pts.El pts.var matita_basics_bool.bool) -> pts.U pts.var) =>
     auto:(__:(pts.El pts.var (matita_basics_logic.eq nat (S n) O)) ->
           pts.El pts.var (P matita_basics_bool.true)) =>
     auto':(__:(pts.El pts.var (matita_basics_logic.Not (matita_basics_logic.eq nat (S n) O))) ->
            pts.El pts.var (P matita_basics_bool.false)) =>
     auto' (matita_basics_logic.sym_not_eq nat O (S n) (not_eq_O_S n)))
    (n:(pts.El pts.var nat) =>
     m:(pts.El pts.var nat) =>
     auto:(P:(__:(pts.El pts.var matita_basics_bool.bool) -> pts.U pts.var) ->
           __:(__:(pts.El pts.var (matita_basics_logic.eq nat n m)) ->
               pts.El pts.var (P matita_basics_bool.true)) ->
           __1:(__1:(pts.El pts.var (matita_basics_logic.Not (matita_basics_logic.eq nat n m))) ->
                pts.El pts.var (P matita_basics_bool.false)) ->
           pts.El pts.var (P (eqb n m))) =>
     P:(__:(pts.El pts.var matita_basics_bool.bool) -> pts.U pts.var) =>
     auto':(__:(pts.El pts.var (matita_basics_logic.eq nat (S n) (S m))) ->
            pts.El pts.var (P matita_basics_bool.true)) =>
     auto'':(__:(pts.El pts.var (matita_basics_logic.Not (matita_basics_logic.eq nat (S n) (S m)))) ->
             pts.El pts.var (P matita_basics_bool.false)) =>
     auto
       P
       (auto''':(pts.El pts.var (matita_basics_logic.eq nat n m)) =>
        auto'
          (matita_basics_logic.rewrite_l
             nat
             n
             (__:(pts.El pts.var nat) => matita_basics_logic.eq nat (S n) (S __))
             (matita_basics_logic.refl nat (S n))
             m
             auto'''))
       (auto''':(pts.El pts.var (matita_basics_logic.Not (matita_basics_logic.eq nat n m))) =>
        auto'' (not_eq_S n m auto'''))).

def eqb_n_n :
  n:(pts.El pts.var nat) ->
  pts.El pts.var (matita_basics_logic.eq matita_basics_bool.bool (eqb n n) matita_basics_bool.true)
  :=
  n:(pts.El pts.var nat) =>
  nat_ind
    (_x_365:(pts.El pts.var nat) =>
     matita_basics_logic.eq matita_basics_bool.bool (eqb _x_365 _x_365) matita_basics_bool.true)
    (matita_basics_logic.refl matita_basics_bool.bool matita_basics_bool.true)
    (x_366:(pts.El pts.var nat) =>
     _x_368:(pts.El
               pts.var
               (matita_basics_logic.eq
                  matita_basics_bool.bool
                  (eqb x_366 x_366)
                  matita_basics_bool.true)) =>
     matita_basics_logic.rewrite_r
       matita_basics_bool.bool
       matita_basics_bool.true
       (__:(pts.El pts.var matita_basics_bool.bool) =>
        matita_basics_logic.eq matita_basics_bool.bool __ matita_basics_bool.true)
       (matita_basics_logic.refl matita_basics_bool.bool matita_basics_bool.true)
       (eqb x_366 x_366)
       _x_368)
    n.

def eqb_true_to_eq :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (matita_basics_logic.eq matita_basics_bool.bool (eqb n m) matita_basics_bool.true)) ->
  pts.El pts.var (matita_basics_logic.eq nat n m)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  eqb_elim
    n
    m
    (__:(pts.El pts.var matita_basics_bool.bool) =>
     pts.Prod
       pts.var
       pts.var
       (matita_basics_logic.eq matita_basics_bool.bool __ matita_basics_bool.true)
       (__1:(pts.El
               pts.var
               (matita_basics_logic.eq matita_basics_bool.bool __ matita_basics_bool.true)) =>
        matita_basics_logic.eq nat n m))
    (auto:(pts.El pts.var (matita_basics_logic.eq nat n m)) =>
     auto':(pts.El
              pts.var
              (matita_basics_logic.eq
                 matita_basics_bool.bool
                 matita_basics_bool.true
                 matita_basics_bool.true)) =>
     matita_basics_logic.rewrite_l
       nat
       n
       (__:(pts.El pts.var nat) => matita_basics_logic.eq nat n __)
       (matita_basics_logic.refl nat n)
       m
       auto)
    (__:(pts.El pts.var (matita_basics_logic.Not (matita_basics_logic.eq nat n m))) =>
     abs:(pts.El
            pts.var
            (matita_basics_logic.eq
               matita_basics_bool.bool
               matita_basics_bool.false
               matita_basics_bool.true)) =>
     matita_basics_logic.False_ind
       (_x_66:(pts.El pts.var matita_basics_logic.False) => matita_basics_logic.eq nat n m)
       (matita_basics_logic.absurd
          (matita_basics_logic.eq
             matita_basics_bool.bool
             matita_basics_bool.true
             matita_basics_bool.false)
          (matita_basics_logic.rewrite_r
             matita_basics_bool.bool
             matita_basics_bool.true
             (__1:(pts.El pts.var matita_basics_bool.bool) =>
              matita_basics_logic.eq matita_basics_bool.bool matita_basics_bool.true __1)
             (matita_basics_logic.refl matita_basics_bool.bool matita_basics_bool.true)
             matita_basics_bool.false
             abs)
          matita_basics_bool.not_eq_true_false)).

def eqb_false_to_not_eq :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (matita_basics_logic.eq matita_basics_bool.bool (eqb n m) matita_basics_bool.false)) ->
  pts.El pts.var (matita_basics_logic.Not (matita_basics_logic.eq nat n m))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  eqb_elim
    n
    m
    (__:(pts.El pts.var matita_basics_bool.bool) =>
     pts.Prod
       pts.var
       pts.var
       (matita_basics_logic.eq matita_basics_bool.bool __ matita_basics_bool.false)
       (__1:(pts.El
               pts.var
               (matita_basics_logic.eq matita_basics_bool.bool __ matita_basics_bool.false)) =>
        matita_basics_logic.Not (matita_basics_logic.eq nat n m)))
    (auto:(pts.El pts.var (matita_basics_logic.eq nat n m)) =>
     auto':(pts.El
              pts.var
              (matita_basics_logic.eq
                 matita_basics_bool.bool
                 matita_basics_bool.true
                 matita_basics_bool.false)) =>
     matita_basics_logic.not_to_not
       (matita_basics_logic.eq nat n m)
       (matita_basics_logic.eq
          matita_basics_bool.bool
          matita_basics_bool.true
          matita_basics_bool.false)
       (auto'':(pts.El pts.var (matita_basics_logic.eq nat n m)) =>
        matita_basics_logic.rewrite_l
          matita_basics_bool.bool
          matita_basics_bool.true
          (__:(pts.El pts.var matita_basics_bool.bool) =>
           matita_basics_logic.eq matita_basics_bool.bool matita_basics_bool.true __)
          (matita_basics_logic.refl matita_basics_bool.bool matita_basics_bool.true)
          matita_basics_bool.false
          auto')
       matita_basics_bool.not_eq_true_false)
    (auto:(pts.El pts.var (matita_basics_logic.Not (matita_basics_logic.eq nat n m))) =>
     auto':(pts.El
              pts.var
              (matita_basics_logic.eq
                 matita_basics_bool.bool
                 matita_basics_bool.false
                 matita_basics_bool.false)) =>
     auto).

def eq_to_eqb_true :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (matita_basics_logic.eq nat n m)) ->
  pts.El pts.var (matita_basics_logic.eq matita_basics_bool.bool (eqb n m) matita_basics_bool.true)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (matita_basics_logic.eq nat n m)) =>
  matita_basics_logic.rewrite_l
    nat
    n
    (__:(pts.El pts.var nat) =>
     matita_basics_logic.eq matita_basics_bool.bool (eqb n __) matita_basics_bool.true)
    (matita_basics_logic.rewrite_r
       matita_basics_bool.bool
       matita_basics_bool.true
       (__:(pts.El pts.var matita_basics_bool.bool) =>
        matita_basics_logic.eq matita_basics_bool.bool __ matita_basics_bool.true)
       (matita_basics_logic.refl matita_basics_bool.bool matita_basics_bool.true)
       (eqb n n)
       (eqb_n_n n))
    m
    auto.

def not_eq_to_eqb_false :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (matita_basics_logic.Not (matita_basics_logic.eq nat n m))) ->
  pts.El pts.var (matita_basics_logic.eq matita_basics_bool.bool (eqb n m) matita_basics_bool.false)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  noteq:(pts.El pts.var (matita_basics_logic.Not (matita_basics_logic.eq nat n m))) =>
  eqb_elim
    n
    m
    (__:(pts.El pts.var matita_basics_bool.bool) =>
     matita_basics_logic.eq matita_basics_bool.bool __ matita_basics_bool.false)
    (Heq:(pts.El pts.var (matita_basics_logic.eq nat n m)) =>
     matita_basics_logic.False_ind
       (_x_66:(pts.El pts.var matita_basics_logic.False) =>
        matita_basics_logic.eq
          matita_basics_bool.bool
          matita_basics_bool.true
          matita_basics_bool.false)
       (matita_basics_logic.absurd
          (matita_basics_logic.eq nat n m)
          (matita_basics_logic.rewrite_l
             nat
             n
             (__:(pts.El pts.var nat) => matita_basics_logic.eq nat n __)
             (matita_basics_logic.refl nat n)
             m
             Heq)
          noteq))
    (auto:(pts.El pts.var (matita_basics_logic.Not (matita_basics_logic.eq nat n m))) =>
     matita_basics_logic.refl matita_basics_bool.bool matita_basics_bool.false).

def leb :
  __:(pts.El pts.var nat) -> __1:(pts.El pts.var nat) -> pts.El pts.var matita_basics_bool.bool.

def leb_body :
  __:(pts.El pts.var nat) -> __1:(pts.El pts.var nat) -> pts.El pts.var matita_basics_bool.bool.

[__]
  leb __
  -->
  filter_nat
    pts.var
    (__:(pts.El pts.var nat) =>
     pts.Prod pts.var pts.var nat (__1:(pts.El pts.var nat) => matita_basics_bool.bool))
    leb_body
    __.

[__]
  leb_body __
  -->
  m:(pts.El pts.var nat) =>
  match_nat
    pts.var
    (__1:(pts.El pts.var nat) => matita_basics_bool.bool)
    matita_basics_bool.true
    (p:(pts.El pts.var nat) =>
     match_nat
       pts.var
       (__1:(pts.El pts.var nat) => matita_basics_bool.bool)
       matita_basics_bool.false
       (q:(pts.El pts.var nat) => leb p q)
       m)
    __.

def leb_elim :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  P:(__:(pts.El pts.var matita_basics_bool.bool) -> pts.U pts.var) ->
  __:(__:(pts.El pts.var (le n m)) -> pts.El pts.var (P matita_basics_bool.true)) ->
  __1:(__1:(pts.El pts.var (matita_basics_logic.Not (le n m))) ->
       pts.El pts.var (P matita_basics_bool.false)) ->
  pts.El pts.var (P (leb n m))
  :=
  nat_elim2
    (__:(pts.El pts.var nat) =>
     _0:(pts.El pts.var nat) =>
     pts.Prod
       pts.var
       pts.var
       (pts.Prod
          pts.var
          pts.var
          matita_basics_bool.bool
          (__1:(pts.El pts.var matita_basics_bool.bool) => pts.u pts.var))
       (P:(__1:(pts.El pts.var matita_basics_bool.bool) -> pts.U pts.var) =>
        pts.Prod
          pts.var
          pts.var
          (pts.Prod
             pts.var
             pts.var
             (le __ _0)
             (__1:(pts.El pts.var (le __ _0)) => P matita_basics_bool.true))
          (__1:(__1:(pts.El pts.var (le __ _0)) -> pts.El pts.var (P matita_basics_bool.true)) =>
           pts.Prod
             pts.var
             pts.var
             (pts.Prod
                pts.var
                pts.var
                (matita_basics_logic.Not (le __ _0))
                (__2:(pts.El pts.var (matita_basics_logic.Not (le __ _0))) =>
                 P matita_basics_bool.false))
             (__2:(__2:(pts.El pts.var (matita_basics_logic.Not (le __ _0))) ->
                   pts.El pts.var (P matita_basics_bool.false)) =>
              P (leb __ _0)))))
    (n:(pts.El pts.var nat) =>
     P:(__:(pts.El pts.var matita_basics_bool.bool) -> pts.U pts.var) =>
     auto:(__:(pts.El pts.var (le O n)) -> pts.El pts.var (P matita_basics_bool.true)) =>
     auto':(__:(pts.El pts.var (matita_basics_logic.Not (le O n))) ->
            pts.El pts.var (P matita_basics_bool.false)) =>
     auto (le_O_n n))
    (n:(pts.El pts.var nat) =>
     P:(__:(pts.El pts.var matita_basics_bool.bool) -> pts.U pts.var) =>
     auto:(__:(pts.El pts.var (le (S n) O)) -> pts.El pts.var (P matita_basics_bool.true)) =>
     auto':(__:(pts.El pts.var (matita_basics_logic.Not (le (S n) O))) ->
            pts.El pts.var (P matita_basics_bool.false)) =>
     auto' (not_le_Sn_O n))
    (n:(pts.El pts.var nat) =>
     m:(pts.El pts.var nat) =>
     Hind:(P:(__:(pts.El pts.var matita_basics_bool.bool) -> pts.U pts.var) ->
           __:(__:(pts.El pts.var (le n m)) -> pts.El pts.var (P matita_basics_bool.true)) ->
           __1:(__1:(pts.El pts.var (matita_basics_logic.Not (le n m))) ->
                pts.El pts.var (P matita_basics_bool.false)) ->
           pts.El pts.var (P (leb n m))) =>
     P:(__:(pts.El pts.var matita_basics_bool.bool) -> pts.U pts.var) =>
     Pt:(__:(pts.El pts.var (le (S n) (S m))) -> pts.El pts.var (P matita_basics_bool.true)) =>
     Pf:(__:(pts.El pts.var (matita_basics_logic.Not (le (S n) (S m)))) ->
         pts.El pts.var (P matita_basics_bool.false)) =>
     Hind
       P
       (lenm:(pts.El pts.var (le n m)) => Pt (le_S_S n m lenm))
       (nlenm:(pts.El pts.var (matita_basics_logic.Not (le n m))) =>
        Pf (not_le_to_not_le_S_S n m nlenm))).

def leb_true_to_le :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (matita_basics_logic.eq matita_basics_bool.bool (leb n m) matita_basics_bool.true)) ->
  pts.El pts.var (le n m)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  leb_elim
    n
    m
    (__:(pts.El pts.var matita_basics_bool.bool) =>
     pts.Prod
       pts.var
       pts.var
       (matita_basics_logic.eq matita_basics_bool.bool __ matita_basics_bool.true)
       (__1:(pts.El
               pts.var
               (matita_basics_logic.eq matita_basics_bool.bool __ matita_basics_bool.true)) =>
        le n m))
    (auto:(pts.El pts.var (le n m)) =>
     auto':(pts.El
              pts.var
              (matita_basics_logic.eq
                 matita_basics_bool.bool
                 matita_basics_bool.true
                 matita_basics_bool.true)) =>
     auto)
    (__:(pts.El pts.var (matita_basics_logic.Not (le n m))) =>
     abs:(pts.El
            pts.var
            (matita_basics_logic.eq
               matita_basics_bool.bool
               matita_basics_bool.false
               matita_basics_bool.true)) =>
     matita_basics_logic.False_ind
       (_x_66:(pts.El pts.var matita_basics_logic.False) => le n m)
       (matita_basics_logic.absurd
          (matita_basics_logic.eq
             matita_basics_bool.bool
             matita_basics_bool.true
             matita_basics_bool.false)
          (matita_basics_logic.rewrite_r
             matita_basics_bool.bool
             matita_basics_bool.true
             (__1:(pts.El pts.var matita_basics_bool.bool) =>
              matita_basics_logic.eq matita_basics_bool.bool matita_basics_bool.true __1)
             (matita_basics_logic.refl matita_basics_bool.bool matita_basics_bool.true)
             matita_basics_bool.false
             abs)
          matita_basics_bool.not_eq_true_false)).

def leb_false_to_not_le :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (matita_basics_logic.eq matita_basics_bool.bool (leb n m) matita_basics_bool.false)) ->
  pts.El pts.var (matita_basics_logic.Not (le n m))
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  leb_elim
    n
    m
    (__:(pts.El pts.var matita_basics_bool.bool) =>
     pts.Prod
       pts.var
       pts.var
       (matita_basics_logic.eq matita_basics_bool.bool __ matita_basics_bool.false)
       (__1:(pts.El
               pts.var
               (matita_basics_logic.eq matita_basics_bool.bool __ matita_basics_bool.false)) =>
        matita_basics_logic.Not (le n m)))
    (__:(pts.El pts.var (le n m)) =>
     abs:(pts.El
            pts.var
            (matita_basics_logic.eq
               matita_basics_bool.bool
               matita_basics_bool.true
               matita_basics_bool.false)) =>
     matita_basics_logic.False_ind
       (_x_66:(pts.El pts.var matita_basics_logic.False) => matita_basics_logic.Not (le n m))
       (matita_basics_logic.absurd
          (matita_basics_logic.eq
             matita_basics_bool.bool
             matita_basics_bool.true
             matita_basics_bool.false)
          (matita_basics_logic.rewrite_l
             matita_basics_bool.bool
             matita_basics_bool.true
             (__1:(pts.El pts.var matita_basics_bool.bool) =>
              matita_basics_logic.eq matita_basics_bool.bool matita_basics_bool.true __1)
             (matita_basics_logic.refl matita_basics_bool.bool matita_basics_bool.true)
             matita_basics_bool.false
             abs)
          matita_basics_bool.not_eq_true_false))
    (auto:(pts.El pts.var (matita_basics_logic.Not (le n m))) =>
     auto':(pts.El
              pts.var
              (matita_basics_logic.eq
                 matita_basics_bool.bool
                 matita_basics_bool.false
                 matita_basics_bool.false)) =>
     auto).

def le_to_leb_true :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le n m)) ->
  pts.El pts.var (matita_basics_logic.eq matita_basics_bool.bool (leb n m) matita_basics_bool.true)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  leb_elim
    n
    m
    (__:(pts.El pts.var matita_basics_bool.bool) =>
     pts.Prod
       pts.var
       pts.var
       (le n m)
       (__1:(pts.El pts.var (le n m)) =>
        matita_basics_logic.eq matita_basics_bool.bool __ matita_basics_bool.true))
    (auto:(pts.El pts.var (le n m)) =>
     auto':(pts.El pts.var (le n m)) =>
     matita_basics_logic.refl matita_basics_bool.bool matita_basics_bool.true)
    (H:(pts.El pts.var (matita_basics_logic.Not (le n m))) =>
     H1:(pts.El pts.var (le n m)) =>
     matita_basics_logic.False_ind
       (_x_66:(pts.El pts.var matita_basics_logic.False) =>
        matita_basics_logic.eq
          matita_basics_bool.bool
          matita_basics_bool.false
          matita_basics_bool.true)
       (matita_basics_logic.absurd (le n m) H1 H)).

def not_le_to_leb_false :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (matita_basics_logic.Not (le n m))) ->
  pts.El pts.var (matita_basics_logic.eq matita_basics_bool.bool (leb n m) matita_basics_bool.false)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  leb_elim
    n
    m
    (__:(pts.El pts.var matita_basics_bool.bool) =>
     pts.Prod
       pts.var
       pts.var
       (matita_basics_logic.Not (le n m))
       (__1:(pts.El pts.var (matita_basics_logic.Not (le n m))) =>
        matita_basics_logic.eq matita_basics_bool.bool __ matita_basics_bool.false))
    (H:(pts.El pts.var (le n m)) =>
     H1:(pts.El pts.var (matita_basics_logic.Not (le n m))) =>
     matita_basics_logic.False_ind
       (_x_66:(pts.El pts.var matita_basics_logic.False) =>
        matita_basics_logic.eq
          matita_basics_bool.bool
          matita_basics_bool.true
          matita_basics_bool.false)
       (matita_basics_logic.absurd (le n m) H H1))
    (auto:(pts.El pts.var (matita_basics_logic.Not (le n m))) =>
     auto':(pts.El pts.var (matita_basics_logic.Not (le n m))) =>
     matita_basics_logic.refl matita_basics_bool.bool matita_basics_bool.false).

def lt_to_leb_false :
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (lt m n)) ->
  pts.El pts.var (matita_basics_logic.eq matita_basics_bool.bool (leb n m) matita_basics_bool.false)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (lt m n)) => not_le_to_leb_false n m (lt_to_not_le m n auto).

def min :
  __:(pts.El pts.var nat) -> __1:(pts.El pts.var nat) -> pts.El pts.var nat
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  matita_basics_bool.match_bool
    pts.var
    (__:(pts.El pts.var matita_basics_bool.bool) => nat)
    n
    m
    (leb n m).

def max :
  __:(pts.El pts.var nat) -> __1:(pts.El pts.var nat) -> pts.El pts.var nat
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  matita_basics_bool.match_bool
    pts.var
    (__:(pts.El pts.var matita_basics_bool.bool) => nat)
    m
    n
    (leb n m).

def commutative_min :
  pts.El pts.var (matita_basics_relations.commutative nat min)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  leb_elim
    n
    m
    (__:(pts.El pts.var matita_basics_bool.bool) =>
     matita_basics_logic.eq
       nat
       (matita_basics_bool.match_bool
          pts.var
          (_0:(pts.El pts.var matita_basics_bool.bool) => nat)
          n
          m
          __)
       (matita_basics_bool.match_bool
          pts.var
          (_0:(pts.El pts.var matita_basics_bool.bool) => nat)
          m
          n
          (leb m n)))
    (leb_elim
       m
       n
       (__:(pts.El pts.var matita_basics_bool.bool) =>
        pts.Prod
          pts.var
          pts.var
          (le n m)
          (__1:(pts.El pts.var (le n m)) =>
           matita_basics_logic.eq
             nat
             (matita_basics_bool.match_bool
                pts.var
                (_0:(pts.El pts.var matita_basics_bool.bool) => nat)
                n
                m
                matita_basics_bool.true)
             (matita_basics_bool.match_bool
                pts.var
                (_0:(pts.El pts.var matita_basics_bool.bool) => nat)
                m
                n
                __)))
       (auto:(pts.El pts.var (le m n)) =>
        auto':(pts.El pts.var (le n m)) => le_to_le_to_eq n m auto' auto)
       (auto:(pts.El pts.var (matita_basics_logic.Not (le m n))) =>
        auto':(pts.El pts.var (le n m)) => matita_basics_logic.refl nat n))
    (notle:(pts.El pts.var (matita_basics_logic.Not (le n m))) =>
     matita_basics_logic.eq_ind_r
       matita_basics_bool.bool
       matita_basics_bool.true
       (x:(pts.El pts.var matita_basics_bool.bool) =>
        __:(pts.El
              pts.var
              (matita_basics_logic.eq matita_basics_bool.bool x matita_basics_bool.true)) =>
        matita_basics_logic.eq
          nat
          (matita_basics_bool.match_bool
             pts.var
             (_0:(pts.El pts.var matita_basics_bool.bool) => nat)
             n
             m
             matita_basics_bool.false)
          (matita_basics_bool.match_bool
             pts.var
             (_0:(pts.El pts.var matita_basics_bool.bool) => nat)
             m
             n
             x))
       (matita_basics_logic.refl
          nat
          (matita_basics_bool.match_bool
             pts.var
             (_0:(pts.El pts.var matita_basics_bool.bool) => nat)
             n
             m
             matita_basics_bool.false))
       (leb m n)
       (le_to_leb_true m n (transitive_le m (S m) n (le_n_Sn m) (not_le_to_lt n m notle)))).

def le_minr :
  i:(pts.El pts.var nat) ->
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) -> __:(pts.El pts.var (le i (min n m))) -> pts.El pts.var (le i m)
  :=
  i:(pts.El pts.var nat) =>
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  leb_elim
    n
    m
    (__:(pts.El pts.var matita_basics_bool.bool) =>
     pts.Prod
       pts.var
       pts.var
       (le
          i
          (matita_basics_bool.match_bool
             pts.var
             (_0:(pts.El pts.var matita_basics_bool.bool) => nat)
             n
             m
             __))
       (__1:(pts.El
               pts.var
               (le
                  i
                  (matita_basics_bool.match_bool
                     pts.var
                     (_0:(pts.El pts.var matita_basics_bool.bool) => nat)
                     n
                     m
                     __))) =>
        le i m))
    (auto:(pts.El pts.var (le n m)) =>
     auto':(pts.El pts.var (le i n)) => transitive_le i n m auto' auto)
    (auto:(pts.El pts.var (matita_basics_logic.Not (le n m))) =>
     auto':(pts.El pts.var (le i m)) => auto').

def le_minl :
  i:(pts.El pts.var nat) ->
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) -> __:(pts.El pts.var (le i (min n m))) -> pts.El pts.var (le i n)
  :=
  i:(pts.El pts.var nat) =>
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (le i (min n m))) =>
  le_minr
    i
    m
    n
    (matita_basics_logic.eq_coerc
       (le i (min n m))
       (le i (min m n))
       auto
       (matita_basics_logic.rewrite_r
          nat
          (min m n)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq (pts.u pts.var) (le i __) (le i (min m n)))
          (matita_basics_logic.refl (pts.u pts.var) (le i (min m n)))
          (min n m)
          (commutative_min n m))).

def to_min :
  i:(pts.El pts.var nat) ->
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le i n)) -> __1:(pts.El pts.var (le i m)) -> pts.El pts.var (le i (min n m))
  :=
  i:(pts.El pts.var nat) =>
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  lein:(pts.El pts.var (le i n)) =>
  leim:(pts.El pts.var (le i m)) =>
  matita_basics_bool.match_bool
    pts.var
    (__:(pts.El pts.var matita_basics_bool.bool) =>
     le
       i
       (matita_basics_bool.match_bool
          pts.var
          (_0:(pts.El pts.var matita_basics_bool.bool) => nat)
          n
          m
          __))
    lein
    leim
    (leb n m).

def commutative_max :
  pts.El pts.var (matita_basics_relations.commutative nat max)
  :=
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  leb_elim
    n
    m
    (__:(pts.El pts.var matita_basics_bool.bool) =>
     matita_basics_logic.eq
       nat
       (matita_basics_bool.match_bool
          pts.var
          (_0:(pts.El pts.var matita_basics_bool.bool) => nat)
          m
          n
          __)
       (matita_basics_bool.match_bool
          pts.var
          (_0:(pts.El pts.var matita_basics_bool.bool) => nat)
          n
          m
          (leb m n)))
    (leb_elim
       m
       n
       (__:(pts.El pts.var matita_basics_bool.bool) =>
        pts.Prod
          pts.var
          pts.var
          (le n m)
          (__1:(pts.El pts.var (le n m)) =>
           matita_basics_logic.eq
             nat
             (matita_basics_bool.match_bool
                pts.var
                (_0:(pts.El pts.var matita_basics_bool.bool) => nat)
                m
                n
                matita_basics_bool.true)
             (matita_basics_bool.match_bool
                pts.var
                (_0:(pts.El pts.var matita_basics_bool.bool) => nat)
                n
                m
                __)))
       (auto:(pts.El pts.var (le m n)) =>
        auto':(pts.El pts.var (le n m)) => le_to_le_to_eq m n auto auto')
       (auto:(pts.El pts.var (matita_basics_logic.Not (le m n))) =>
        auto':(pts.El pts.var (le n m)) => matita_basics_logic.refl nat m))
    (notle:(pts.El pts.var (matita_basics_logic.Not (le n m))) =>
     matita_basics_logic.eq_ind_r
       matita_basics_bool.bool
       matita_basics_bool.true
       (x:(pts.El pts.var matita_basics_bool.bool) =>
        __:(pts.El
              pts.var
              (matita_basics_logic.eq matita_basics_bool.bool x matita_basics_bool.true)) =>
        matita_basics_logic.eq
          nat
          (matita_basics_bool.match_bool
             pts.var
             (_0:(pts.El pts.var matita_basics_bool.bool) => nat)
             m
             n
             matita_basics_bool.false)
          (matita_basics_bool.match_bool
             pts.var
             (_0:(pts.El pts.var matita_basics_bool.bool) => nat)
             n
             m
             x))
       (matita_basics_logic.refl
          nat
          (matita_basics_bool.match_bool
             pts.var
             (_0:(pts.El pts.var matita_basics_bool.bool) => nat)
             m
             n
             matita_basics_bool.false))
       (leb m n)
       (le_to_leb_true m n (transitive_le m (S m) n (le_n_Sn m) (not_le_to_lt n m notle)))).

def le_maxl :
  i:(pts.El pts.var nat) ->
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) -> __:(pts.El pts.var (le (max n m) i)) -> pts.El pts.var (le n i)
  :=
  i:(pts.El pts.var nat) =>
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  leb_elim
    n
    m
    (__:(pts.El pts.var matita_basics_bool.bool) =>
     pts.Prod
       pts.var
       pts.var
       (le
          (matita_basics_bool.match_bool
             pts.var
             (_0:(pts.El pts.var matita_basics_bool.bool) => nat)
             m
             n
             __)
          i)
       (__1:(pts.El
               pts.var
               (le
                  (matita_basics_bool.match_bool
                     pts.var
                     (_0:(pts.El pts.var matita_basics_bool.bool) => nat)
                     m
                     n
                     __)
                  i)) =>
        le n i))
    (auto:(pts.El pts.var (le n m)) =>
     auto':(pts.El pts.var (le m i)) => transitive_le n m i auto auto')
    (auto:(pts.El pts.var (matita_basics_logic.Not (le n m))) =>
     auto':(pts.El pts.var (le n i)) => auto').

def le_maxr :
  i:(pts.El pts.var nat) ->
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) -> __:(pts.El pts.var (le (max n m) i)) -> pts.El pts.var (le m i)
  :=
  i:(pts.El pts.var nat) =>
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  auto:(pts.El pts.var (le (max n m) i)) =>
  le_maxl
    i
    m
    n
    (matita_basics_logic.eq_coerc
       (le (max n m) i)
       (le (max m n) i)
       auto
       (matita_basics_logic.rewrite_r
          nat
          (max m n)
          (__:(pts.El pts.var nat) =>
           matita_basics_logic.eq (pts.u pts.var) (le __ i) (le (max m n) i))
          (matita_basics_logic.refl (pts.u pts.var) (le (max m n) i))
          (max n m)
          (commutative_max n m))).

def to_max :
  i:(pts.El pts.var nat) ->
  n:(pts.El pts.var nat) ->
  m:(pts.El pts.var nat) ->
  __:(pts.El pts.var (le n i)) -> __1:(pts.El pts.var (le m i)) -> pts.El pts.var (le (max n m) i)
  :=
  i:(pts.El pts.var nat) =>
  n:(pts.El pts.var nat) =>
  m:(pts.El pts.var nat) =>
  leni:(pts.El pts.var (le n i)) =>
  lemi:(pts.El pts.var (le m i)) =>
  matita_basics_bool.match_bool
    pts.var
    (__:(pts.El pts.var matita_basics_bool.bool) =>
     le
       (matita_basics_bool.match_bool
          pts.var
          (_0:(pts.El pts.var matita_basics_bool.bool) => nat)
          m
          n
          __)
       i)
    lemi
    leni
    (leb n m).

